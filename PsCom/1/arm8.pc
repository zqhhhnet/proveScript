C2.4.369 VMAX, VMAXA
           1   EncodingSpecificOperations();
           2   ExecuteFPCheck();
           3
           4   (curBeat, elmtMask) = GetCurInstrBeat();
           5
           6   result = Zeros(32);
           7   op1    = Q[n, curBeat];
           8   op2    = Q[m, curBeat];
           9   for e = 0 to elements-1
          10       value1 = Int(Elem[op1, e, esize], unsigned || absolute);
          11       value2 = Int(Elem[op2, e, esize], unsigned);
          12       if absolute then
          13           value2 = Abs(value2);
          14       Elem[result, e, esize] = Max(value1, value2)[esize-1:0];
          15
          16   for e = 0 to 3
          17       if elmtMask[e] == '1' then
          18           Elem[Q[d, curBeat], e, 8] = Elem[result, e, 8];

C2.4.370 VMAXNM
           1   EncodingSpecificOperations();
           2   ExecuteFPCheck();
           3   case size of
           4       when '01'
           5           if maximum then
           6                S[d] = Zeros(16) : FPMaxNum(S[n][15:0], S[m][15:0], TRUE);
           7           else
           8                S[d] = Zeros(16) : FPMinNum(S[n][15:0], S[m][15:0], TRUE);
           9       when '10'
          10           if maximum then
          11                S[d] = FPMaxNum(S[n], S[m], TRUE);
          12           else
          13                S[d] = FPMinNum(S[n], S[m], TRUE);
          14       when '11'
          15           if maximum then
          16                D[d] = FPMaxNum(D[n], D[m], TRUE);
          17           else
          18                D[d] = FPMinNum(D[n], D[m], TRUE);

C2.4.371 VMAXNM, VMAXNMA (floating-point)
           1   EncodingSpecificOperations();
           2   ExecuteFPCheck();
           3
           4   (curBeat, elmtMask) = GetCurInstrBeat();
           5
           6   result = Zeros(32);
           7   op1    = Q[n, curBeat];
           8   op2    = Q[m, curBeat];
           9   for e = 0 to elements-1
          10       // Avoid Floating-point exceptions on a predicated lane by checking the element mask
          11       predicated = (elmtMask[e*(esize>>3)] == '0');
          12       value1     = Elem[op1, e, esize];
          13       value2     = Elem[op2, e, esize];
          14       if absolute then
          15           value1 = FPAbs(value1);
          16           value2 = FPAbs(value2);
          17       Elem[result, e, esize] = FPMaxNum(value1, value2, FALSE, predicated);
          18
          19   for e = 0 to 3
          20       if elmtMask[e] == '1' then
          21           Elem[Q[d, curBeat], e, 8] = Elem[result, e, 8];

C2.4.372 VMAXNMV, VMAXNMAV (floating-point)
           1   EncodingSpecificOperations();
           2   ExecuteFPCheck();
           3
           4   (curBeat, elmtMask) = GetCurInstrBeat();
           5
           6   op1    = Q[m, curBeat];
           7   result = Elem[R[da], 0, esize];
           8   for e = 0 to elements-1
           9       if elmtMask[e*(esize>>3)] == '1' then
          10           value = Elem[op1, e, esize];
          11           result = FPConvertNaN(result, FALSE);
          12           value = FPConvertNaN(value, FALSE);
          13           if absolute then
          14               value = FPAbs(value);
          15           result = FPMaxNum(value, result, FALSE);
          16
          17   R[da] = ZeroExtend(result);

C2.4.373 VMAXV, VMAXAV
           1   EncodingSpecificOperations();
           2   ExecuteFPCheck();
           3
           4   (curBeat, elmtMask) = GetCurInstrBeat();
           5
           6   op1    = Q[m, curBeat];
           7   result = Int(Elem[R[da], 0, esize], absolute || unsigned);
           8   for e = 0 to elements-1
           9       if elmtMask[e*(esize>>3)] == '1' then
          10           value = Int(Elem[op1, e, esize], unsigned);
          11           if absolute then
          12               value = Abs(value);
          13           result = Max(value, result);
          14
          15   R[da] = result[31:0];

C2.4.374 VMIN, VMINA
           1   EncodingSpecificOperations();
           2   ExecuteFPCheck();
           3
           4   (curBeat, elmtMask) = GetCurInstrBeat();
           5
           6   result = Zeros(32);
           7   op1    = Q[n, curBeat];
           8   op2    = Q[m, curBeat];
           9   for e = 0 to elements-1
          10       value1 = Int(Elem[op1, e, esize], unsigned || absolute);
          11       value2 = Int(Elem[op2, e, esize], unsigned);
          12       if absolute then
          13           value2 = Abs(value2);
          14       Elem[result, e, esize] = Min(value1, value2)[esize-1:0];
          15
          16   for e = 0 to 3
          17       if elmtMask[e] == '1' then
          18           Elem[Q[d, curBeat], e, 8] = Elem[result, e, 8];

C2.4.375 VMINNM
           1   EncodingSpecificOperations();
           2   ExecuteFPCheck();
           3   case size of
           4       when '01'
           5           if maximum then
           6                S[d] = Zeros(16) : FPMaxNum(S[n][15:0], S[m][15:0], TRUE);
           7           else
           8                S[d] = Zeros(16) : FPMinNum(S[n][15:0], S[m][15:0], TRUE);
           9       when '10'
          10           if maximum then
          11                S[d] = FPMaxNum(S[n], S[m], TRUE);
          12           else
          13                S[d] = FPMinNum(S[n], S[m], TRUE);
          14       when '11'
          15           if maximum then
          16                D[d] = FPMaxNum(D[n], D[m], TRUE);
          17           else
          18                D[d] = FPMinNum(D[n], D[m], TRUE);

C2.4.376 VMINNM, VMINNMA (floating-point)
           1   EncodingSpecificOperations();
           2   ExecuteFPCheck();
           3
           4   (curBeat, elmtMask) = GetCurInstrBeat();
           5
           6   result = Zeros(32);
           7   op1    = Q[n, curBeat];
           8   op2    = Q[m, curBeat];
           9   for e = 0 to elements-1
          10       // Avoid Floating-point exceptions on a predicated lane by checking the element mask
          11       predicated = (elmtMask[e*(esize>>3)] == '0');
          12       value1     = Elem[op1, e, esize];
          13       value2     = Elem[op2, e, esize];
          14       if absolute then
          15           value1 = FPAbs(value1);
          16           value2 = FPAbs(value2);
          17       Elem[result, e, esize] = FPMinNum(value1, value2, FALSE, predicated);
          18
          19   for e = 0 to 3
          20       if elmtMask[e] == '1' then
          21           Elem[Q[d, curBeat], e, 8] = Elem[result, e, 8];

C2.4.377 VMINNMV, VMINNMAV (floating-point)
           1   EncodingSpecificOperations();
           2   ExecuteFPCheck();
           3
           4   (curBeat, elmtMask) = GetCurInstrBeat();
           5
           6   op1    = Q[m, curBeat];
           7   result = Elem[R[da], 0, esize];
           8   for e = 0 to elements-1
           9       if elmtMask[e*(esize>>3)] == '1' then
          10           value = Elem[op1, e, esize];
          11           result = FPConvertNaN(result, FALSE);
          12           value = FPConvertNaN(value, FALSE);
          13           if absolute then
          14               value = FPAbs(value);
          15           result = FPMinNum(value, result, FALSE);
          16
          17   R[da] = ZeroExtend(result);

C2.4.378 VMINV, VMINAV
           1   EncodingSpecificOperations();
           2   ExecuteFPCheck();
           3
           4   (curBeat, elmtMask) = GetCurInstrBeat();
           5
           6   op1    = Q[m, curBeat];
           7   result = Int(Elem[R[da], 0, esize], absolute || unsigned);
           8   for e = 0 to elements-1
           9       if elmtMask[e*(esize>>3)] == '1' then
          10           value = Int(Elem[op1, e, esize], unsigned);
          11           if absolute then
          12               value = Abs(value);
          13           result = Min(value, result);
          14
          15   R[da] = result[31:0];


E2.1.1 _AdvanceVPTState
          1   // Advances VPT state
          2
          3   boolean _AdvanceVPTState;

E2.1.2 _ITStateChanged
          1   // Indicates a write to ITSTATE
          2
          3   boolean   _ITStateChanged;

E2.1.3 _Mem
          1   // _Mem[] - non-assignment (read) form
          2   // ===================================
          3   // Perform single-copy atomic, aligned, little-endian read from physical memory
          4
          5   (boolean, bits(8*size)) _Mem(AddressDescriptor memaddrdesc, integer size);
          6
          7   // _Mem[] - assignment (write) form
          8   // ================================
          9   // Perform single-copy atomic, aligned, little-endian write to physical memory
         10
         11   boolean _Mem(AddressDescriptor memaddrdesc, integer size, bits(8*size) value);

E2.1.4 _NextInstrAddr
          1   // Address of    next instruction to be fetched in case of branch type operation
          2
          3   bits(32) _NextInstrAddr;

E2.1.5 _NextInstrITState
          1   // Updated ITSTATE for next instruction
          2
          3   ITSTATEType _NextInstrITState;

E2.1.6 _PCChanged
          1   // Indicates a change in instruction fetch address due to branch type operations
          2
          3   boolean   _PCChanged;

E2.1.7 _PendingReturnOperation
          1   // Indicate any pending exception returns
          2
          3   boolean _PendingReturnOperation;

E2.1.8 _RName
          1   // The physical array of core registers.
          2   // _R[RName_PC] is defined to be the address of the current instruction.
          3   // The offset of 4 bytes is applied to it by the register access functions.
          4
          5   array bits(32) _RName[RNames];

E2.1.9 _S
          1   // The 32-bit extension register bank for the FP extension.
          2
          3   array bits(32) _S[0..31];

E2.1.10 _SP
          1   // _SP()
          2   // =====
          3
          4   // Non-assignment form
          5
          6   bits(32) _SP(RNames      spreg)
          7       assert ( (spreg      == RNamesSP_Main_NonSecure)                       ||
          8               ((spreg      == RNamesSP_Main_Secure)    && HaveSecurityExt()) ||
          9                (spreg      == RNamesSP_Process_NonSecure)                    ||
         10               ((spreg      == RNamesSP_Process_Secure) && HaveSecurityExt()) );
         11
         12       return _RName[spreg][31:2]:'00';
         13
         14   // Assignment form
         15
         16   ExcInfo _SP(RNames spreg, boolean excEntry, boolean skipLimitCheck, bits(32) value)
         17       assert ( (spreg == RNamesSP_Main_NonSecure)                       ||
         18               ((spreg == RNamesSP_Main_Secure)    && HaveSecurityExt()) ||
         19                (spreg == RNamesSP_Process_NonSecure)                    ||
         20               ((spreg == RNamesSP_Process_Secure) && HaveSecurityExt()) );
         21
         22       excInfo = DefaultExcInfo();
         23       if !skipLimitCheck && ViolatesSPLim(spreg, value) then
         24           isSecure = ((spreg == RNamesSP_Main_Secure) ||
         25                       (spreg == RNamesSP_Process_Secure));
         26           // If the stack limit is violated during exception entry then the stack
         27           // pointer is set to the limit value. This both prevents violations and 28           // ensures that the stack pointer is 8 byte aligned.
         29           if excEntry then
         30               _RName[spreg] = LookUpSPLim(spreg);
         31
         32              // Raise the appropriate exception and syndrome information
         33              if isSecure then
         34                  UFSR_S.STKOF = '1';
         35              else
         36                  UFSR_NS.STKOF = '1';
         37              // Create the exception. NOTE: If Main Extension is not implemented the fault always
         38              // escalates to HardFault.
         39              excInfo = CreateException(UsageFault, TRUE, isSecure);
         40              if !excEntry then
         41                  HandleException(excInfo);
         42       else
         43           // Stack pointer only updated normally if limit not violated
         44           _RName[spreg] = value[31:2]:'00';
         45       return excInfo;

E2.1.11 Abs
          1   // Abs()
          2   // =====
          3
          4   integer Abs(integer x)
          5       return if x >= 0 then x else -x;
          6
          7   real Abs(real x)
          8       return if x >= 0.0 then x else -x;

E2.1.12 AccessAttributes
          1   // Memory access attributes
          2
          3   type AccessAttributes is (
          4       boolean iswrite,       // TRUE for memory stores, FALSE for load accesses
          5       boolean ispriv,        // TRUE if the access is privileged, FALSE if unprivileged
          6       AccType acctype
          7   )

E2.1.13 AccType
          1   // Memory reference access type
          2
          3   enumeration AccType { AccType_NORMAL,                  //   Normal loads and stores
          4                         AccType_MVE,                     //   Loads and stores generated by MVE instructions
          5                         AccType_ORDERED,                 //   Load-Acquire and Store-Release
          6                         AccType_STACK,                   //   HW generated stacking / unstacking operation
          7                         AccType_LAZYFP,                  //   HW generated stacking due to lazy
          8                                                          //   floating point state preservation
          9                              AccType_IFETCH,             //   Instruction fetch
         10                              AccType_DBG,                //   Loads and Stores generated by the Debugger
         11                              AccType_VECTABLE            //   Vector table fetch
         12                            };

E2.1.14 ActivateException
          1   // ActivateException()
          2   // ===================
          3
          4   ActivateException(integer exceptionNumber, boolean excIsSecure)
          5       // If the exception is Secure, directly entry the Secure state.
          6       CurrentState = if excIsSecure
          7                      then SecurityState_Secure else SecurityState_NonSecure;
          8       IPSR.Exception = exceptionNumber[8:0];         // Update IPSR to this exception.
          9                                                      // This also causes a transition to
         10                                                      // privileged handler
         11                                                      // mode as IPSR.Exception != 0
         12       if HaveMainExt() then
         13           EPSR.IT = Zeros(8);                        // IT/ICI/ECI bits cleared
         14       if HavePACBTIExt() then
         15           EPSR.B = '0';                              // Clear BTI state
         16       // PRIMASK, FAULTMASK, BASEPRI unchanged on exception entry
         17       if HaveMveOrFPExt() then
         18           CONTROL.FPCA   = '0';                      // Floating-point Extension only
         19           CONTROL_S.SFPA = '0';
         20       CONTROL.SPSEL = '0';                           // CONTORL.SPSEL is updated to indicate
         21                                                      // the selection of the Main stack pointer
         22                                                      // (SP_main), CONTROL.nPRIV unchanged
         23       // Transition exception from pending to active
         24       SetPending(exceptionNumber, excIsSecure, FALSE);
         25       SetActive(exceptionNumber, excIsSecure, TRUE);

E2.1.15 ActiveFPState
          1   // ActiveFPState()
          2   // ===============
          3
          4   boolean ActiveFPState()
          5       // Is the FP state accessible
          6       (active, -) = IsCPEnabled(10);
          7
          8       // Is FP lazy state preservation active
          9       if active then
         10           if FPCCR_S.S == '1' then
         11               lspact = FPCCR_S.LSPACT;
         12           else
         13               lspact = FPCCR_NS.LSPACT;
         14           active = lspact == '0';
         15
         16       // Check ASPEN to determine if the PE or software is managing the FP state
         17       if active && FPCCR.ASPEN == '1' then
         18           // If the PE is managing the FP state then FPCA can be used to indicate
         19           // if the current context has an active FP state. Similarly SFPA is also
         20           // checked to determine if the FP state is active for the Secure state.
         21           active = CONTROL.FPCA == '1' && (!IsSecure() || CONTROL_S.SFPA == '1');
         22       return active;

E2.1.16 AddressDescriptor
          1   // Descriptor used to access the underlying memory array
          2
          3   type AddressDescriptor is (
          4       MemoryAttributes memattrs,
          5       bits(32)         paddress,          // Physical Address
          6       AccessAttributes accattrs
          7   )

E2.1.17 AddrType
          1   // Indicates address type
          2
          3   enumeration AddrType { AddrType_NORMAL,
          4                           AddrType_EXC_RETURN,
          5                           AddrType_FNC_RETURN
          6                        };

E2.1.18 AddWithCarry
          1   // AddWithCarry()
          2   // ==============
          3
          4   (bits(N), bit, bit) AddWithCarry(bits(N) x, bits(N) y, bit carry_in)
          5       unsigned_sum = UInt(x) + UInt(y) + UInt(carry_in);
          6       signed_sum   = SInt(x) + SInt(y) + UInt(carry_in);
          7       result       = unsigned_sum[N-1:0]; // same value as signed_sum[N-1:0]
          8       carry_out    = if UInt(result) == unsigned_sum then '0' else '1';
          9       overflow     = if SInt(result) == signed_sum then '0' else '1';
         10       return (result, carry_out, overflow);

E2.1.19 AdvSIMDExpandImm
          1   // AdvSIMDExpandImm()
          2   // ==================
          3
          4   bits(64) AdvSIMDExpandImm(bit op, bits(4) cmode, bits(8) imm8)
          5
          6       case cmode[3:1]      of
          7           when '000'
          8               imm64 =      Replicate(Zeros(24):imm8, 2);
          9           when '001'
         10               imm64 =      Replicate(Zeros(16):imm8:Zeros(8), 2);
         11           when '010'
         12               imm64 =      Replicate(Zeros(8):imm8:Zeros(16), 2);
         13           when '011'
         14               imm64 =      Replicate(imm8:Zeros(24), 2);
         15           when '100'
         16               imm64 =      Replicate(Zeros(8):imm8, 4);
         17           when '101'
         18                  imm64 = Replicate(imm8:Zeros(8), 4);
         19              when '110'
         20                  if cmode[0] == '0' then
         21                       imm64 = Replicate(Zeros(16):imm8:Ones(8), 2);
         22                  else
         23                       imm64 = Replicate(Zeros(8):imm8:Ones(16), 2);
         24              when '111'
         25                  if cmode[0] == '0' && op == '0' then
         26                       imm64 = Replicate(imm8, 8);
         27                  if cmode[0] == '0' && op == '1' then
         28                       imm8a = Replicate(imm8[7], 8); imm8b = Replicate(imm8[6], 8);
         29                       imm8c = Replicate(imm8[5], 8); imm8d = Replicate(imm8[4], 8);
         30                       imm8e = Replicate(imm8[3], 8); imm8f = Replicate(imm8[2], 8);
         31                       imm8g = Replicate(imm8[1], 8); imm8h = Replicate(imm8[0], 8);
         32                       imm64 = imm8a:imm8b:imm8c:imm8d:imm8e:imm8f:imm8g:imm8h;
         33                  if cmode[0] == '1' && op == '0' then
         34                       imm32 = imm8[7]:NOT(imm8[6]):Replicate(imm8[6],5):imm8[5:0]:Zeros(19);
         35                       imm64 = Replicate(imm32, 2);
         36                  if cmode[0] == '1' && op == '1' then
         37                       UNDEFINED;
         38
         39       return imm64;

E2.1.20 AlgorithmPAC
          1   // Algorithm used for computing PAC
          2
          3   enumeration AlgorithmPAC {AlgorithmPAC_None, // PACBTI not implemented
          4                             AlgorithmPAC_QARMA, // QARMA algorithm implemented
          5                             AlgorithmPAC_IMPDEF // IMPLEMENTATION DEFINED algorithm implemented
          6                            };

E2.1.21 Align
          1   // Align()
          2   // =======
          3
          4   integer Align(integer x, integer y)
          5       return y * (x DIV y);
          6
          7   bits(N) Align(bits(N) x, integer y)
          8       return Align(UInt(x), y)[N-1:0];

E2.1.22 ArchVersion
          1   // Indicates architecture version
          2
          3   enumeration ArchVersion {
          4       Armv8p0,
          5       Armv8p1
          6   };

E2.1.23 ASR
          1   // ASR()
          2   // =====
          3
          4   bits(N) ASR(bits(N) x, integer shift)
          5       assert shift >= 0;
          6       if shift == 0 then
          7            result = x;
          8       else
          9            (result, -) = ASR_C(x, shift);
         10       return result;

E2.1.24 ASR_C
          1   // ASR_C()
          2   // =======
          3
          4   (bits(N), bit) ASR_C(bits(N) x, integer shift)
          5       assert shift > 0;
          6       extended_x = SignExtend(x, shift+N);
          7       result = extended_x[shift+N-1:shift];
          8       carry_out = extended_x[shift-1];
          9       return (result, carry_out);

E2.1.25 BeatComplete
          1   // BeatComplete
          2   // ============
          3
          4   //   The BeatComplete value indicates whether the 4 beats from 2 instructions have
          5   //   been performed. The flags are packed into an 8 bit value as follows:
          6   //   bit 0: beat 0 of instruction 0
          7   //   bit 1: beat 1 of instruction 0
          8   //   ...
          9   //   bit 4: beat 0 of instruction 1
         10   //   bit 5: beat 1 of instruction 1
         11   //   ...
         12   //
         13   //   NOTE: The beat execution rules mean that only a few flag combinations are
         14   //         valid.
         15
         16   // Non-assignment form
         17   bits(8) BeatComplete
         18       bits(8) beatComplete;
         19       case EPSR.ECI of
         20           when '00000000' beatComplete           =   '0000   0000';
         21           when '00000001' beatComplete           =   '0000   0001';
         22           when '00000010' beatComplete           =   '0000   0011';
         23           when '00000100' beatComplete           =   '0000   0111';
         24           when '00000101' beatComplete           =   '0001   0111';
         25           otherwise assert(FALSE);
         26       return beatComplete;
         27
         28   // Assignment form
         29   BeatComplete = bits(8) value
         30       case value of
         31           when '0000 0000' EPSR.ECI         =   0[7:0];
         32           when '0000 0001' EPSR.ECI         =   1[7:0];
         33           when '0000 0011' EPSR.ECI         =   2[7:0];
         34           when '0000 0111' EPSR.ECI         =   4[7:0];
         35           when '0001 0111' EPSR.ECI         =   5[7:0];
         36           otherwise
         37               assert(FALSE);

E2.1.26 BeatSchedule
          1   // BeatSchedule()
          2   // ==============
          3
          4   type InstInfoType is (
          5       bits(32) Opcode,
          6       integer   Length,
          7       boolean   Valid
          8   )
          9
         10   array [0..MAX_OVERLAPPING_INSTRS-1] of InstInfoType _InstInfo;
         11   integer _InstID;
         12   integer _BeatID;

E2.1.27 BigEndian
          1   // BigEndian()
          2   // ===========
          3
          4   boolean BigEndian(bits(32) startAddress, integer size)
          5       // If AIRCR.ENDINANESS is 0 then the PE is in little endian mode
          6       if AIRCR.ENDIANNESS == '0' then
          7           return FALSE;
          8       // ...otherwise the PE is in big endian mode, however; the PPB
          9       // space (0xE0000000 to 0xE00FFFFF) is always little endian.
         10       endAddress     = startAddress + size;
         11       startPpbAccess = IsPPB(startAddress);
         12       endPpbAccess   = IsPPB(endAddress);
         13       // If an access crosses the PPB boundary then it is
         14       // CONSTRAINED_UNPREDICTABLE if the PE is in big endian mode
         15       if startPpbAccess != endPpbAccess then
         16           CONSTRAINED_UNPREDICTABLE;
         17       return !startPpbAccess;

E2.1.28 BigEndianReverse
          1   // BigEndianReverse()
          2   // ==================
          3
          4   bits(8*N) BigEndianReverse (bits(8*N) value, integer N)
          5       assert N == 1 || N == 2 || N == 4;
          6       bits(8*N) result;
          7       case N of
          8           when 1
          9               result[7:0] = value[7:0];
         10           when 2
         11               result[15:8] = value[7:0];
         12               result[7:0] = value[15:8];
         13           when 4
         14               result[31:24] = value[7:0];
         15               result[23:16] = value[15:8];
         16               result[15:8] = value[23:16];
         17               result[7:0]   = value[31:24];
         18       return result;

E2.1.29 BitCount
          1   // BitCount()
          2   // ==========
          3
          4   integer BitCount(bits(N) x)
          5       integer result = 0;
          6       for i = 0 to N-1
          7           if x[i] == '1' then
          8               result = result + 1;
          9       return result;

E2.1.30 BitReverseShiftRight
          1   // BitReverseShiftRight()
          2   // ======================
          3
          4   bits(N) BitReverseShiftRight(bits(N) x, integer R)
          5       reversed = Zeros(N);
          6       if R > N then
          7           R = N;
          8       for i = 0 to R-1
          9           reversed[R-i-1] = x[i];
         10       return reversed;

E2.1.31 BranchCall
          1   // BranchCall()
          2   // ============
          3
          4   BranchCall(bits(32) address, boolean allowNonSecure, boolean setBti)
          5       // If in the Secure state and transitions to the Non-secure state are allowed
          6       // then the target state is specified by the LSB of the target address
          7       if HaveSecurityExt() && allowNonSecure && IsSecure() then
          8            EPSR.T = '1';
          9            if address[0] == '0' then
         10                CurrentState = SecurityState_NonSecure;
         11                if HaveMveOrFPExt() then CONTROL_S.SFPA = '0';
         12                if HaveLOBExt() then
         13                    LO_BRANCH_INFO.VALID = '0';
         14       else
         15            EPSR.T = address[0];
         16            // If EPSR.T == 0 then an exception is taken on the next
         17            // instruction: UsageFault('Invalid State') if the Main Extension is
         18            // implemented; HardFault otherwise
         19
         20       BranchTo(address[31:1]:'0', FALSE, setBti);

E2.1.32 BranchReturn
          1   // BranchReturn()
          2   // ==============
          3
          4   ExcInfo BranchReturn(bits(32) address, boolean allowNonSecure, boolean setBti)
          5       exc = DefaultExcInfo();
          6
          7       case IsReturn(address) of
          8           when AddrType_NORMAL
          9               BranchCall(address, allowNonSecure, setBti);
         10           when AddrType_FNC_RETURN
         11               // Unlike exception return, any faults raised during a FNC_RETURN
         12               // unstacking are raised synchronously with the instruction that triggered
         13               // the unstacking.
         14               exc = FunctionReturn();
         15           when AddrType_EXC_RETURN
         16               // If enabled, the IESB contains asynchronous RAS / BusFault errors to the
         17               // exception context.
         18               if AIRCR.IESB == '1' then
         19                   exc = SynchronizeBusFault();
         20               // The actual exception return is performed when the
         21               // current instruction completes. This is because faults that occur
         22               // during the exception return are handled differently from faults
         23               // raised during the instruction execution.
         24               if exc.fault == NoFault then
         25                   PendReturnOperation(address);
         26
         27       return exc;
         28
         29   ExcInfo BranchReturn(bits(32) address, boolean allowNonSecure)
         30       return BranchReturn(address, allowNonSecure, FALSE);

E2.1.33 BranchTo
          1   // BranchTo()
          2   // ==========
          3
          4   BranchTo(bits(32) address, boolean commit, boolean setBti)
          5       if HaveLOBExt() then
          6           // Any branch between a branch future instruction and the associated
          7           // branch point invalidates the branch info cache
          8           if LO_BRANCH_INFO.VALID == '1' && LO_BRANCH_INFO.BF == '1' then
          9                LO_BRANCH_INFO.VALID = '0';
         10
         11       // EPSR.B is set to ensure that the target of the branch is either a BTI clearing
         12       // instruction or a BTI agnostic instruction
         13       if setBti then
         14           EPSR.B = '1';
         15
         16       // Sets the address to fetch the next instruction from. NOTE: The current PC
         17       // is not changed directly as this would modify the result of
         18       // ThisInstrAddr(), which would cause the wrong return addresses to be used
         19       // for some types of exception. The actual update of the PC is done in the
         20       // InstructionAdvance() function after the instruction finishes executing.
         21       _NextInstrAddr = address[31:1]:'0';
         22       _PCChanged     = TRUE;
         23       // Clear any pending exception returns
         24       _PendingReturnOperation = FALSE;
         25
         26       if commit then
         27           // This directly commits the change to the PC, so ThisInstrAddr()
         28           // and NextInstrAddr() both point to the target address. Used for exception
         29           // returns and resets so the state is consistent before the next instruction
         30           // (or exception) is taken.
         31           _RName[RNamesPC] = _NextInstrAddr;
         32
         33   BranchTo(bits(32) address)
         34       BranchTo(address, FALSE, FALSE);

E2.1.34 BTIEnabled
          1   // BTIEnabled()
          2   // ============
          3   // Check whether BTI is enabled.
          4
          5   boolean BTIEnabled(boolean isSecure)
          6       enabled = FALSE;
          7       // The PACBTI Extension must be implemented in order to use BTI functionality.
          8       if HavePACBTIExt() then
          9           control = if isSecure then CONTROL_S else CONTROL_NS;
         10           if CurrentModeIsPrivileged(isSecure) then
         11               enabled = control.BTI_EN == '1'; // Privileged BTI enabled
         12           else
         13               enabled = control.UBTI_EN == '1'; // Unprivileged BTI enabled
         14       return enabled;
         15
         16
         17   boolean BTIEnabled()
         18       return BTIEnabled(IsSecure());

E2.1.35 BusFaultBarrier
          1   // BusFaultBarrier()
          2   // =================
          3
          4   // Forces any latent BusFault (both RAS and non-RAS) to be recognised.
          5   // This function returns TRUE if a BusFault was detected.
          6   boolean BusFaultBarrier();

E2.1.36 CallSupervisor
          1   // CallSupervisor()
          2   // ================
          3
          4   CallSupervisor()
          5       excInfo = CreateException(SVCall);
          6       HandleException(excInfo);

E2.1.37 CanDebugAccessFP
          1   // CanDebugAccessFP()
          2   // ==================
          3
          4   boolean CanDebugAccessFP()
          5       canAccessFP = (!HaveSecurityExt() || DHCSR.S_SDE == '1' ||
          6                       (FPCCR_S.S == '0' && NSACR.CP10 == '1'));
          7
          8       // Unprivileged-only debug for the state associated with the floating-point
          9       // context restricts access via CPACR checking and if a lazy context is active.
         10       if HaveUDE() then
         11           if FPCCR_S.S == '1' && DHCSR.S_SUIDE == '1' then
         12               canAccessFP = canAccessFP && CPACR_S.CP10 == '11' && FPCCR_S.LSPACT != '1';
         13           elsif FPCCR_S.S == '0' && DHCSR.S_NSUIDE == '1' then
         14               canAccessFP = canAccessFP && CPACR_NS.CP10 == '11' && FPCCR_NS.LSPACT != '1';
         15       return canAccessFP;

E2.1.38 CanHaltOnEvent
          1   // CanHaltOnEvent()
          2   // ================
          3
          4   boolean CanHaltOnEvent(boolean is_secure, boolean isPriv)
          5       if !HaveSecurityExt() then assert !is_secure;
          6
          7       if !HaveHaltingDebug() || Halted || DHCSR.C_DEBUGEN == '0' then return FALSE;
          8
          9       if is_secure then
         10            if DHCSR.S_SDE == '1' && (!HaveUDE() || DHCSR.S_SUIDE == '0') then return TRUE;
         11       else
         12            if HaltingDebugAllowed() then return TRUE;
         13
         14       return (!isPriv && UnprivHaltingDebugEnabled(is_secure));

E2.1.39 CanPendMonitorOnEvent
          1   // CanPendMonitorOnEvent()
          2   // =======================
          3
          4   boolean CanPendMonitorOnEvent(boolean isSecure, boolean checkPri, boolean checkEn,
          5                                 boolean isPriv, boolean checkSecure)
          6       if !HaveSecurityExt() then assert !isSecure;
          7
          8       result = HaveDebugMonitor() && !CanHaltOnEvent(isSecure, isPriv) && !Halted;
          9
         10       if checkEn then
         11           if HaveUDE() && !isPriv then
         12               result = result && (DEMCR.MON_EN == '1' || DEMCR.UMON_EN == '1');
         13           else
         14               result = result && DEMCR.MON_EN == '1';
         15
         16       if checkSecure then
         17           result = result && (!isSecure || DEMCR.SDME == '1');
         18
         19       if checkPri then
         20           mon_secure = (HaveSecurityExt() && DEMCR.SDME == '1');
         21           result     = (result && (ExceptionPriority(DebugMonitor, mon_secure, TRUE) <
         22                                    ExecutionPriority()));
         23
         24       return result;

E2.1.40 CdeImpDefValue
          1   // CdeImpDefValue()
          2   // ================
          3   // IMPLEMENTATION DEFINED value functions for the Custom Datapath Extension
          4
          5   bits(size)   CdeImpDefValue(bits(N)       instr);
          6   bits(size)   CdeImpDefValue(bits(N)       instr, bits(M) opa);
          7   bits(size)   CdeImpDefValue(bits(N)       instr, bits(M) opa, bits(L) opb);
          8   bits(size)   CdeImpDefValue(bits(N)       instr, bits(M) opa, bits(L) opb, bits(K) opc);
          9
         10   bits(size) CdeImpDefValue(bits(N) instr, integer curBeat, bits(4) elmtMask);
         11   bits(size) CdeImpDefValue(bits(N) instr, bits(M) opa, integer curBeat, bits(4) elmtMask);
         12   bits(size) CdeImpDefValue(bits(N) instr, bits(M) opa, bits(L) opb, integer curBeat,
         13                             bits(4) elmtMask);
         14   bits(size) CdeImpDefValue(bits(N) instr, bits(M) opa, bits(L) opb, bits(K) opc,
         15                             integer curBeat, bits(4) elmtMask);

E2.1.41 CheckCPEnabled
          1   // CheckCPEnabled()
          2   // ================
          3
          4   ExcInfo CheckCPEnabled(integer cp, boolean privileged, boolean secure)
          5       (enabled, toSecure) = IsCPEnabled(cp, privileged, secure);
          6       if !enabled then
          7            if toSecure then
          8                UFSR_S.NOCP = '1';
          9            else
         10                UFSR_NS.NOCP = '1';
         11            excInfo = CreateException(UsageFault, TRUE, toSecure);
         12       else
         13            excInfo = DefaultExcInfo();
         14       return excInfo;
         15
         16   ExcInfo CheckCPEnabled(integer cp)
         17       return CheckCPEnabled(cp, CurrentModeIsPrivileged(), IsSecure());

E2.1.42 CheckDecodeFaults
          1   // CheckDecodeFaults()
          2   // ===================
          3   // Check and raise faults in the correct order for MVE and floating-point instructions.
          4
          5   CheckDecodeFaults(ExtType extType)
          6       // Is the instruction in the co-processer space
          7       (isCP, cpNumber) = IsCPInstruction(ThisInstr());
          8       assert(isCP);
          9
         10       // Is the co-processer enabled, this may raise a NOCP UsageFault
         11       excInfo = CheckCPEnabled(cpNumber);
         12       HandleException(excInfo);
         13
         14       // Check if the type of instruction is supported.
         15       case extType of
         16           when ExtType_HpFp      if MVFR1.FP16 == '0000'     then UNDEFINED;
         17           when ExtType_SpFp      if MVFR0.FPSP == '0000'     then UNDEFINED;
         18           when ExtType_DpFp      if MVFR0.FPDP == '0000'     then UNDEFINED;
         19           when ExtType_Mve       if MVFR1.MVE == '0000'      then UNDEFINED;
         20           when ExtType_MveFp     if MVFR1.MVE != '0010'      then UNDEFINED;
         21           when ExtType_MveOrFp
         22               // Raises an UNDEFINED fault if MVE and the Floating-point extension are missing
         23               if MVFR1.MVE == '0000' && MVFR0.FPSP == '0000' then UNDEFINED;
         24           when ExtType_MveOrDpFp
         25               if MVFR1.MVE == '0000' && MVFR0.FPDP == '0000' then UNDEFINED;
         26           when ExtType_Unknown                                    UNDEFINED;
         27           otherwise assert(FALSE);

E2.1.43 CheckFPDecodeFaults
          1   // CheckFPDecodeFaults()
          2   // ===================
          3
          4   CheckFPDecodeFaults(bits(2) size)
          5       // Checks the size field and identifies the correct ExtType
          6       case size of
          7           when '00' CheckDecodeFaults(ExtType_Unknown);
          8           when '01' CheckDecodeFaults(ExtType_HpFp);
          9           when '10' CheckDecodeFaults(ExtType_SpFp);
         10           when '11' CheckDecodeFaults(ExtType_DpFp);

E2.1.44 CheckPermission
          1   // CheckPermission()
          2   // =================
          3
          4   ExcInfo CheckPermission(Permissions perms, bits(32) address, AccType acctype,
          5                             boolean iswrite, boolean ispriv, boolean isSecure)
          6       if !perms.apValid then
          7            fault = TRUE;
          8       elsif (perms.xn == '1') && (acctype == AccType_IFETCH) then
          9            fault = TRUE;
         10       else
         11            case perms.ap of
         12                when '00' fault = !ispriv;
         13                when '01' fault = FALSE;
         14                when '10' fault = !ispriv || iswrite;
         15                when '11' fault = iswrite;
         16                otherwise    UNPREDICTABLE;
         17
         18       // If a fault occurred generate the syndrome info and create the exception.
         19       if fault then
         20           // Create and write out the syndrome information on implementations with
         21           // the Main Extension.
         22           if HaveMainExt() then
         23               MMFSR_Type fsr = Zeros(8);
         24               case acctype of
         25                   when AccType_IFETCH
         26                       fsr.IACCVIOL = '1';
         27                   when AccType_STACK
         28                       if iswrite then
         29                            fsr.MSTKERR = '1';
         30                       else
         31                            fsr.MUNSTKERR = '1';
         32                   when AccType_LAZYFP
         33                       fsr.MLSPERR    = '1';
         34                   when AccType_NORMAL, AccType_MVE, AccType_ORDERED
         35                       fsr.MMARVALID = '1';
         36                       fsr.DACCVIOL = '1';
         37                   when AccType_DBG
         38                       // DAP errors do not set syndrome
         39                   otherwise
         40                       assert(FALSE);
         41
         42                // Write the syndrome information to the correct instance of banked
         43                // registers
         44                if isSecure then
         45                     MMFSR_S = MMFSR_S OR fsr;
         46                     if fsr.MMARVALID == '1' then
         47                         MMFAR_S = address;
         48                else
         49                     MMFSR_NS = MMFSR_NS OR fsr;
         50                     if fsr.MMARVALID == '1' then
         51                         MMFAR_NS = address;
         52
         53               // Create the exception. NOTE: If Main Extension is not implemented the fault
         54               // escalates to a HardFault
         55               excInfo = CreateException(MemManage, TRUE, isSecure);
         56        else
         57            excInfo = DefaultExcInfo();
         58        return excInfo;

E2.1.45 ClearEventRegister
          1   // ClearEventRegister
          2   // ==================
          3   // Clears the Event register
          4
          5   ClearEventRegister();

E2.1.46 ClearExclusiveByAddress
          1   //   ClearExclusiveByAddress
          2   //   =======================
          3   //   Clear the global exclusive monitor for all PEs, except for the PE specified
          4   //   by processorid for which an address region including any of size bytes
          5   //   starting from address has had a request for an exclusive access
          6
          7   ClearExclusiveByAddress(bits(32) address, integer exclprocessorid, integer size);

E2.1.47 ClearExclusiveLocal
          1   // ClearExclusiveLocal()
          2   // =====================
          3   // Clear local exclusive monitor records for the PE.
          4
          5   ClearExclusiveLocal(integer processorid);

E2.1.48 ClearInFlightInstructions
          1   // ClearInFlightInstructions()
          2   // ===========================
          3
          4   ClearInFlightInstructions()
          5       for i = 0 to MAX_OVERLAPPING_INSTRS-1
          6           _InstInfo[i].Valid = FALSE;

E2.1.49 ComparePriorities
          1   // ComparePriorities()
          2   // ===================
          3
          4   boolean ComparePriorities(integer exc0Pri, integer exc0Number, boolean exc0IsSecure,
          5                              integer exc1Pri, integer exc1Number, boolean exc1IsSecure)
          6       if exc0Pri != exc1Pri then
          7            takeE0 = exc0Pri < exc1Pri;
          8       elsif exc0Number != exc1Number then
          9            takeE0 = exc0Number < exc1Number;
         10       elsif exc0IsSecure != exc1IsSecure then
         11            takeE0 = exc0IsSecure;
         12       else
         13            // The two exceptions have exactly the same priority, so exception 0
         14            // cannot be taken in preference to exception 1.
         15            takeE0 = FALSE;
         16       return takeE0;
         17
         18
         19   boolean ComparePriorities(ExcInfo exc0Info, boolean groupPri,
         20                              integer exc1Pri, integer exc1Number, boolean exc1IsSecure)
         21        exc0Pri = ExceptionPriority(exc0Info.fault, exc0Info.isSecure, groupPri);
         22        return ComparePriorities(exc0Pri, exc0Info.fault, exc0Info.isSecure,
         23                                 exc1Pri, exc1Number,     exc1IsSecure);

E2.1.50 ComputePAC
          1   //   ComputePAC()
          2   //   ============
          3   //   QARMA cryptographic algorithm.
          4   //   When an IMPLEMENTATION DEFINED cryptographic algorithm is used, the
          5   //   input arguments must match the input arguments of this function.
          6
          7   array bits(64) RC[0..4];
          8
          9   bits(64) ComputePAC(bits(64) data, bits(64) modifier, bits(64) key0, bits(64) key1)
         10       bits(64) workingval;
         11       bits(64) runningmod;
         12       bits(64) roundkey;
         13       bits(64) modk0;
         14       constant bits(64) Alpha = 0xC0AC29B7C97C50DD[63:0];
         15
         16        RC[0]   =   0x0000000000000000[63:0];
         17        RC[1]   =   0x13198A2E03707344[63:0];
         18        RC[2]   =   0xA4093822299F31D0[63:0];
         19        RC[3]   =   0x082EFA98EC4E6C89[63:0];
         20        RC[4]   =   0x452821E638D01377[63:0];
         21
         22        modk0 = key0[0]:key0[63:2]:(key0[63] EOR key0[1]);
         23        runningmod = modifier;
         24        workingval = data EOR key0;
         25        for i = 0 to 4
         26            roundkey = key1 EOR runningmod;
         27            workingval = workingval EOR roundkey;
         28            workingval = workingval EOR RC[i];
         29            if i > 0 then
         30                workingval = PACCellShuffle(workingval);
         31                workingval = PACMult(workingval);
         32            workingval = PACSub(workingval);
         33            runningmod = TweakShuffle(runningmod[63:0]);
         34        roundkey = modk0 EOR runningmod;
         35        workingval = workingval EOR roundkey;
         36        workingval = PACCellShuffle(workingval);
         37        workingval = PACMult(workingval);
         38        workingval = PACSub(workingval);
         39        workingval = PACCellShuffle(workingval);
         40        workingval = PACMult(workingval);
         41        workingval = key1 EOR workingval;
         42        workingval = PACCellInvShuffle(workingval);
         43        workingval = PACInvSub(workingval);
         44        workingval = PACMult(workingval);
         45        workingval = PACCellInvShuffle(workingval);
         46        workingval = workingval EOR key0;
         47        workingval = workingval EOR runningmod;
         48        for i = 0 to 4
         49            workingval = PACInvSub(workingval);
         50            if i < 4 then
         51                workingval = PACMult(workingval);
         52                workingval = PACCellInvShuffle(workingval);
         53            runningmod = TweakInvShuffle(runningmod[63:0]);
         54            roundkey = key1 EOR runningmod;
         55            workingval = workingval EOR RC[4-i];
         56            workingval = workingval EOR roundkey;
         57            workingval = workingval EOR Alpha;
         58        workingval = workingval EOR modk0;
         59
         60        return workingval;

E2.1.51 Cond
          1   // Condition code definitions
          2   // ===========================
          3
          4   constant   bits(4)   CondEQ   =   0x0[3:0];
          5   constant   bits(4)   CondNE   =   0x1[3:0];
          6   constant   bits(4)   CondCS   =   0x2[3:0];
          7   constant   bits(4)   CondCC   =   0x3[3:0];
          8   constant   bits(4)   CondMI   =   0x4[3:0];
          9   constant   bits(4)   CondPL   =   0x5[3:0];
         10   constant   bits(4)   CondVS   =   0x6[3:0];
         11   constant   bits(4)   CondVC   =   0x7[3:0];
         12   constant   bits(4)   CondHI   =   0x8[3:0];
         13   constant   bits(4)   CondLS   =   0x9[3:0];
         14   constant   bits(4)   CondGE   =   0xA[3:0];
         15   constant   bits(4)   CondLT   =   0xB[3:0];
         16   constant   bits(4)   CondGT   =   0xC[3:0];
         17   constant   bits(4)   CondLE   =   0xD[3:0];
         18   constant   bits(4)   CondAL   =   0xE[3:0];
         19   constant   bits(4)   CondNV   =   0xF[3:0];

E2.1.52 ConditionHolds
          1   // ConditionHolds()
          2   // ================
          3
          4   boolean ConditionHolds(bits(3) shortCond, bit n, bit z, bit c, bit v)
          5       // Expand the short condition to the standard 4 bit representation
          6       case shortCond of
          7           when '000' cond = CondEQ;
          8           when '001' cond = CondNE;
          9           when '010' cond = CondCS;
         10           when '011' cond = CondHI;
         11           when '100' cond = CondGE;
         12           when '101' cond = CondLT;
         13           when '110' cond = CondGT;
         14           when '111' cond = CondLE;
         15       return ConditionHolds(cond, n, z, c, v, TRUE);
         16
         17   boolean ConditionHolds(bits(4) cond)
         18       return ConditionHolds(cond, APSR.N, APSR.Z, APSR.C, APSR.V, FALSE);
         19
         20   boolean ConditionHolds(bits(4) cond, bit n, bit z, bit               c, bit v, boolean allowNV)
         21       // Evaluate base condition.
         22       case cond[3:1] of
         23           when '000' result = (z == '1');                              //   EQ   or   NE
         24           when '001' result = (c == '1');                              //   CS   or   CC
         25           when '010' result = (n == '1');                              //   MI   or   PL
         26           when '011' result = (v == '1');                              //   VS   or   VC
         27           when '100' result = (c == '1') && (z == '0');                //   HI   or   LS
         28           when '101' result = (n == v);                                //   GE   or   LT
         29           when '110' result = (n == v)    && (z == '0');               //   GT   or   LE
         30           when '111' result = TRUE;                                    //   AL   or   possibly NV
         31
         32       // The LSB of the condition code is an invert flag. Some situations prohibit
         33       // execute never, and treat it the same as execute always. This applies the
         34       // invert taking into account whether the inverse of always is allowed.
         35       if cond[0] == '1' && (cond != CondNV || allowNV)then
         36           result = !result;
         37       return result;

E2.1.53 ConditionPassed
          1   // ConditionPassed()
          2   // =================
          3
          4   boolean ConditionPassed()
          5       return ConditionPassed(CurrentCond());
          6
          7   boolean ConditionPassed(bits(4) cond)
          8       passed = ConditionHolds(cond);
          9       return passed;

E2.1.54 ConstrainUnpredictable
          1   //   ConstrainUnpredictable()
          2   //   ========================
          3   //   Return the appropriate Constraint result to control the caller's behavior.
          4   //   The return value is IMPLEMENTATION DEFINED within a permitted list for
          5   //   each UNPREDICTABLE case.
          6   //   (The permitted list is determined by an assert or case statement at the call site.)
          7
          8   Constraint ConstrainUnpredictable(Unpredictable which);

E2.1.55 ConstrainUnpredictableBits
          1   //   ConstrainUnpredictableBits()
          2   //   ============================
          3   //   This is a variant of ConstrainUnpredictable for when the result can be Constraint_UNKNOWN.
          4   //   If the result is Constraint_UNKNOWN then the function also returns UNKNOWN value, but that
          5   //   value is always an allocated value; that is, one for which the behavior is not itself
          6   //   CONSTRAINED.
          7
          8   (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which);

E2.1.56 ConstrainUnpredictableBool
          1   //   ConstrainUnpredictableBool()
          2   //   ============================
          3   //   This is a wrapper for UNPREDICTABLE cases where the constrained result is
          4   //   either TRUE or FALSE.
          5
          6   boolean ConstrainUnpredictableBool(Unpredictable which);

E2.1.57 ConstrainUnpredictableInteger
          1   //   ConstrainUnpredictableInteger()
          2   //   ===============================
          3   //   This is a variant of ConstrainUnpredictable for when the result can be Constraint_UNKNOWN.
          4   //   If the result is Constraint_UNKNOWN then the function also returns an UNKNOWN value in
          5   //   the range low to high, inclusive.
          6
          7   (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high,
          8                                                      Unpredictable which);

E2.1.58 ConsumeExcStackFrame
          1   // ConsumeExcStackFrame()
          2   // ======================
          3
          4   ConsumeExcStackFrame(EXC_RETURN_Type excReturn, bit fourByteAlign)
          5       // Calculate the size of the integer part of the stack frame
          6       toSecure = HaveSecurityExt() && excReturn.S == '1';
          7       if toSecure && (excReturn.ES == '0' ||
          8                        excReturn.DCRS == '0') then
          9            framesize = 0x48;
         10       else
         11            framesize = 0x20;
         12       // Add on the size of the FP part of the stack frame if present
         13       if HaveMveOrFPExt() && excReturn.FType == '0' then
         14           if toSecure && FPCCR_S.TS == '1' then
         15               framesize = framesize + 0x88;
         16           else
         17               framesize = framesize + 0x48;
         18
         19       // Update stack pointer. NOTE: Stack pointer limit not checked on exception
         20       // return as stack pointer guaranteed to be ascending not descending.
         21       mode   = if excReturn.Mode == '1' then PEMode_Thread else PEMode_Handler;
         22       spName = LookUpSP_with_security_mode(toSecure, mode);
         23       exc    = _SP(spName, FALSE, TRUE, (_SP(spName) + framesize) OR 24                                          ZeroExtend(fourByteAlign:'00',32));
         25       assert exc.fault == NoFault;

E2.1.59 ConsumptionOfSpeculativeDataBarrier
          1   // Consumption of Speculative Data Barrier
          2   // =======================================
          3   // Perform a Consumption of Speculative Data Barrier operation.
          4
          5   ConsumptionOfSpeculativeDataBarrier();

E2.1.60 Coproc_Accepted
          1   // Coproc_Accepted
          2   // ================
          3   // Check whether a coprocessor accepts an instruction.
          4
          5   boolean Coproc_Accepted(integer cp_num, bits(32) instr);

E2.1.61 Coproc_DoneLoading
          1   // Coproc_DoneLoading
          2   // ==================
          3   // Check whether enough 32-bit words have been loaded for an LDC instruction
          4
          5   boolean Coproc_DoneLoading(integer cp_num, bits(32) instr);

E2.1.62 Coproc_DoneStoring
          1   // Coproc_DoneStoring
          2   // ==================
          3   // Check whether enough 32-bit words have been stored for a STC instruction
          4
          5   boolean Coproc_DoneStoring(integer cp_num, bits(32) instr);

E2.1.63 Coproc_GetOneWord
          1   // Coproc_GetOneWord
          2   // =================
          3   // Gets the 32-bit word for an MRC instruction from the coprocessor
          4
          5   bits(32) Coproc_GetOneWord(integer cp_num, bits(32) instr);

E2.1.64 Coproc_GetTwoWords
          1   // Coproc_GetTwoWords
          2   // ==================
          3   // Get two 32-bit words for an MRRC instruction from the coprocessor
          4
          5   (bits(32), bits(32)) Coproc_GetTwoWords(integer cp_num, bits(32) instr);

E2.1.65 Coproc_GetWordToStore
          1   // Coproc_GetWordToStore
          2   // =====================
          3   // Gets the next 32-bit word to store for an STC instruction from the coprocessor
          4
          5   bits(32) Coproc_GetWordToStore(integer cp_num, bits(32) instr);

E2.1.66 Coproc_InternalOperation
          1   //   Coproc_InternalOperation
          2   //   ========================
          3   //   Instructs a coprocessor to perform the internal operation requested
          4   //   by a CDP instruction
          5
          6   Coproc_InternalOperation(integer cp_num, bits(32) instr);

E2.1.67 Coproc_SendLoadedWord
          1   // Coproc_SendLoadedWord
          2   // =====================
          3   // Sends a loaded 32-bit word for an LDC instruction to the coprocessor
          4
          5   Coproc_SendLoadedWord(bits(32) word, integer cp_num, bits(32) instr);

E2.1.68 Coproc_SendOneWord
          1   // Coproc_SendOneWord
          2   // ==================
          3   // Sends the 32-bit word for an MCR instruction to the coprocessor
          4
          5   Coproc_SendOneWord(bits(32) word, integer cp_num, bits(32) instr);

E2.1.69 Coproc_SendTwoWords
          1   // Coproc_SendTwoWords
          2   // ===================
          3   // Send two 32-bit words for an MCRR instruction to the coprocessor.
          4
          5   Coproc_SendTwoWords(bits(32) word2, bits(32) word1, integer cp_num, bits(32) instr);

E2.1.70 CoprocType
          1   //   CoprocType
          2   //   ==========
          3   //   Returns the architecture defined enumeration of the instruction set
          4   //   supported by the given coprocessor space.
          5
          6   CPDef CoprocType(integer coproc)
          7       // The CDE extension defines two encoding patterns:
          8       // - CP_GCP   : The architected coprocessor encodings for MRC, MCR, CDP etc.
          9       // - CP_CDEv1 : Version 1 of the Custom Datapath Extension.
         10       coprocType = CP_GCP;
         11       if coproc >= 0 && coproc <= 7 then
         12           if boolean IMPLEMENTATION_DEFINED "CDE enabled coprocessor" then
         13               coprocType = CP_CDEv1;
         14       return coprocType;

E2.1.71 CountLeadingSignBits
          1   // CountLeadingSignBits()
          2   // ======================
          3
          4   integer CountLeadingSignBits(bits(N) x)
          5       return CountLeadingZeroBits(x[N-1:1] EOR x[N-2:0]);

E2.1.72 CountLeadingZeroBits
          1   // CountLeadingZeroBits()
          2   // ======================
          3
          4   integer CountLeadingZeroBits(bits(N) x)
          5       return N - 1 - HighestSetBit(x);

E2.1.73 CPDef
          1   // CPDef
          2   // =====
          3   // The CDE extension defines two encoding patterns
          4
          5   enumeration CPDef { CP_GCP, // The architected coprocessor encodings for MRC, MCR, CDP etc.
          6                       CP_CDEv1 // Version 1 of the Custom Datapath Extension.
          7                     };

E2.1.74 CreateException
          1   // CreateException()
          2   // =================
          3
          4   ExcInfo CreateException(integer exception, boolean forceSecurity,
          5                           boolean isSecure, boolean isSynchronous)
          6
          7       // Work out the effective target state of the exception
          8       if HaveSecurityExt() then
          9            if !forceSecurity then
         10                isSecure = ExceptionTargetsSecure(exception, isSecure);
         11       else
         12            isSecure = FALSE;
         13
         14       // An implementation without Security Extensions cannot cause a fault targetting
         15       // Secure state
         16       assert HaveSecurityExt() || !isSecure;
         17
         18       // Get the remaining exception details
         19       (escalateToHf, termInst) = ExceptionDetails(exception, isSecure, isSynchronous);
         20
         21       // Fill in the default      exception info
         22       info                        = DefaultExcInfo();
         23       info.fault                  = exception;
         24       info.termInst               = termInst;
         25       info.origFault              = exception;
         26       info.origFaultIsSecure      = isSecure;
         27
         28       //   Check for HardFault escalation
         29       //   In some cases (for example faults during lazy floating-point state preservation)
         30       //   the decision to escalate below is ignored and instead based on the info.origFault*
         31       //   fields and other factors.
         32       if   escalateToHf && info.fault != HardFault then
         33             // Update the exception info with the escalation details, including
         34             // whether there's a change in destination Security state.
         35             info.fault        = HardFault;
         36             isSecure          = ExceptionTargetsSecure(HardFault, isSecure);
         37             (escalateToHf, -) = ExceptionDetails(HardFault, isSecure, isSynchronous);
         38
         39       // If the requested exception was already a HardFault then the PE cannot escalate
         40        //   to a HardFault, so lockup. NOTE: Asynchronous BusFaults never cause
         41        //   lockups, if the BusFault is disabled it escalates to a HardFault that is
         42        //   pended.
         43        if   escalateToHf && isSynchronous && info.fault == HardFault then
         44              info.lockup = TRUE;
         45
         46        // Fill in the remaining exception info
         47        info.isSecure = isSecure;
         48        return info;
         49
         50   ExcInfo CreateException(integer exception, boolean forceSecurity, boolean isSecure)
         51       return CreateException(exception, forceSecurity, isSecure, TRUE);
         52
         53   ExcInfo CreateException(integer exception)
         54       return CreateException(exception, FALSE, IsSecure(), TRUE);

E2.1.75 CreatePAC
          1   //   CreatePAC()
          2   //   ===========
          3   //   Returns a 32-bit value containing the pointer authentication code, where the pointer
          4   //   authentication code is derived using a cryptographic algorithm as a combination of
          5   //   x, y and the cryptographic key. The cryptographic key is selected on the basis of the
          6   //   current Security state and privilege level.
          7
          8   bits(32) CreatePAC(bits(32) x, bits(32) y)
          9       // Where <x> is the pointer and <y> is the modifier. Both are zero extended to 64 bits.
         10       bits(64) extPtr   = Zeros(32) : x;
         11       bits(64) modifier = Zeros(32) : y;
         12
         13        // Get the key to use. The top 64bits are the whitening key
         14        key = PACKey[IsSecure(), CurrentModeIsPrivileged()];
         15        // Return the 32 least significant bits of the computed PAC value.
         16        return ComputePAC(extPtr, modifier, key[127:64], key[63:0])[31:0];

E2.1.76 CurrentCond
          1   // CurrentCond()
          2   // =============
          3   // Returns condition specifier of current instruction.
          4
          5   bits(4) CurrentCond();

E2.1.77 CurrentMode
          1   // CurrentMode()
          2   // =============
          3
          4   PEMode CurrentMode()
          5       return if IPSR.Exception == NoFault[8:0] then PEMode_Thread else PEMode_Handler;

E2.1.78 CurrentModeIsPrivileged
          1   // CurrentModeIsPrivileged()
          2   // =========================
          3
          4   boolean CurrentModeIsPrivileged()
          5       return CurrentModeIsPrivileged(IsSecure());
          6
          7   boolean CurrentModeIsPrivileged(boolean isSecure)
          8       nPriv = if isSecure then CONTROL_S.nPRIV else CONTROL_NS.nPRIV;
          9       return (CurrentMode() == PEMode_Handler || nPriv == '0');

E2.1.79 CX_op0
          1   // CX_op0
          2   // ======
          3
          4   bits(size) CX_op0(bits(32) instr, integer size)
          5       assert size IN {32, 64};
          6
          7       // Custom data path returning IMPLEMENTATION DEFINED value based on
          8       // instruction opcode only.
          9       return CdeImpDefValue(instr);

E2.1.80 CX_op1
          1   // CX_op1
          2   // ======
          3
          4   bits(size) CX_op1(bits(32) instr, bits(N) opa, integer size)
          5       assert N    IN {32, 64};
          6       assert size IN {32, 64};
          7
          8       // Custom data path returning IMPLEMENTATION DEFINED value based on
          9       // instruction opcode and single 32-bit or 64-bit operand, opa, only.
         10       return CdeImpDefValue(instr, opa);

E2.1.81 CX_op2
          1   // CX_op2
          2   // ======
          3
          4   bits(size) CX_op2(bits(32) instr, bits(N) opa, bits(32) opb, integer size)
          5       assert N    IN {32, 64};
          6       assert size IN {32, 64};
          7
          8       // Custom data path returning IMPLEMENTATION DEFINED value based on instruction
          9       // opcode and two 32-bit or 64-bit operands, opa and opb, only.
         10       return CdeImpDefValue(instr, opa, opb);

E2.1.82 CX_op3
          1   // CX_op3
          2   // ======
          3
          4   bits(size) CX_op3(bits(32) instr, bits(N) opa, bits(32) opb, bits(32) opc, integer size)
          5       assert N    IN {32, 64};
          6       assert size IN {32, 64};
          7
          8       // Custom data path returning IMPLEMENTATION DEFINED value based on instruction
          9       // opcode and three 32-bit or 64-bit operands, opa, opb and opc, only.
         10       return CdeImpDefValue(instr, opa, opb, opc);

E2.1.83 D
          1   // D[]
          2   // ===
          3
          4   // Non-assignment form
          5
          6   bits(64) D[integer n]
          7       assert n >= 0 && n <= 31;
          8       return _S[(n*2)+1]:_S[n*2];
          9
         10   // Assignment form
         11
         12   D[integer n] = bits(64) value
         13       assert n >= 0 && n <= 31;
         14       _S[(n*2)+1] = value[63:32];
         15       _S[n*2]     = value[31:0];
         16       return;

E2.1.84 DAPCheck
          1   // DAPCheck()
          2   // ==========
          3
          4   (boolean, boolean, boolean) DAPCheck(bits(32) address, boolean isPriv,
          5       boolean isSecure, boolean isWrite)
          6
          7       assert(HaveSecurityExt() || !isSecure);
          8       err = FALSE;
          9
         10       // DAP accesses to SCS registers select the bank to access based on DSCSR.SBRSEL*, and 11       // not the security attribute of the DAP access itself.
         12       // If DHCSR.S_SDE is 0 then DSCSR.SBRSELEN reads as 1 and DSCSR.SBRSEL reads as 0. This
         13       // forces the Non-secure bank of the registers to be read if Secure debug isn't
         14       // permitted.
         15       if IsSCS(address) then
         16            if DSCSR.SBRSELEN == '0' then
         17                isSecure = IsSecure();
         18            else
         19                isSecure = DSCSR.SBRSEL == '1';
         20       else
         21            // DAP access falls back to Nonsecure when secure debug disabled
         22            isSecure = isSecure && DHCSR.S_SDE == '1';
         23
         24       // DAP access are demoted to unprivileged when unprivileged only debug is enabled
         25       if (isSecure && DHCSR.S_SUIDE == '1') || (!isSecure && DHCSR.S_NSUIDE == '1') then
         26           isPriv = FALSE;
         27
         28       if !(HaltingDebugAllowed()                ||
         29            (isSecure && DHCSR.S_SUIDE == '1') ||
         30            (!isSecure && DHCSR.S_NSUIDE == '1')) then
         31
         32            // Allow authorized unprivileged DAP requests to the System PPB.
         33            if DAUTHCTRL_S.UIDAPEN == '1'|| DAUTHCTRL_NS.UIDAPEN == '1' then
         34                err    = !IsPPB(address);
         35                isPriv = FALSE;
         36
         37            // Otherwise handle accesses based on NonInvasiveDebugAllowed or 38            // region-specific rules
         39            else
         40                // Accesses are denied, except where explicitly allowed below
         41                err = TRUE;
         42                priv_check = !NoninvasiveDebugAllowed(TRUE);
         43                case address of
         44                    when '1110 0000 0000 xxxx xxxx 1111 1011 0xxx'
         45                        err = priv_check;                        // CoreSight software lock
         46                    when '1110 0000 0000 xxxx xxxx 1111 1101 xxxx'
         47                        err = FALSE;                             // All ID registers RO
         48                    when '1110 0000 0000 xxxx xxxx 1111 111x xxxx'
         49                        err = FALSE;                             // All ID registers RO
         50                    when '1110 0000 0000 0000 0000 xxxx xxxx xxxx'
         51                        err = priv_check;                        // ITM
         52                    when '1110 0000 0000 0000 0001 xxxx xxxx xxxx'
         53                        err = priv_check;                        // DWT
         54                    when '1110 0000 0000 0000 0011 xxxx xxxx xxxx'
         55                        err = priv_check;                        // PMU
         56                    when '1110 0000 0000 0100 0000 xxxx xxxx xxxx'
         57                        err = FALSE;                             // TPIU
         58                    when '1110 0000 0000 0100 0001 xxxx xxxx xxxx'
         59                        err = FALSE;                             // ETM
         60                     when '1110 0000 0000 1111 1111 xxxx xxxx xxxx'
         61                         err = FALSE;                             // ROM Table
         62                     otherwise
         63                         address_uint = UInt(address);
         64                         if address_uint >= 0xE0042000 && address_uint <= 0xE00FEFFF then
         65                             err = boolean IMPLEMENTATION_DEFINED "IMPDEF DAP region";
         66                         elsif address_uint >= 0xE0100000 then
         67                             err = priv_check;                    // Vendor Sys
         68
         69       return (isSecure, isPriv, err);

E2.1.85 DataMemoryBarrier
          1   // DataMemoryBarrier()
          2   // ===================
          3   // Perform a Data Memory Barrier operation
          4
          5   DataMemoryBarrier(bits(4) option);

E2.1.86 DataSynchronizationBarrier
          1   // DataSynchronizationBarrier
          2   // ==========================
          3   // Perform a data synchronization barrier operation
          4
          5   DataSynchronizationBarrier(bits(4) option);

E2.1.87 DeActivate
          1   // DeActivate()
          2   // ============
          3
          4   DeActivate(integer returningExceptionNumber, boolean targetDomainSecure)
          5       // To prevent the execution priority remaining negative (and therefore
          6       // masking HardFault) when returning from NMI / HardFault with a corrupted
          7       // IPSR value, the active bits corresponding to the execution priority are
          8       // cleared if the raw execution priority (in other words the priority before
          9       // FAULTMASK and other priority boosting is considered) is negative.
         10       rawPri = RawExecutionPriority();
         11       if rawPri == -1 then
         12            SetActive(HardFault, AIRCR.BFHFNMINS == '0', FALSE);
         13       elsif rawPri == -2 then
         14            SetActive(NMI,       AIRCR.BFHFNMINS == '0', FALSE);
         15       elsif rawPri == -3 then
         16            SetActive(HardFault, TRUE,                   FALSE);
         17       else
         18            secure = HaveSecurityExt() && targetDomainSecure;
         19            SetActive(returningExceptionNumber, secure, FALSE);
         20
         21       /* PRIMASK and BASEPRI unchanged on exception exit */
         22       if HaveMainExt() && rawPri >= 0 then
         23           // clear FAULTMASK for exception security domain on any return except
         24           // NMI and HardFault
         25           if HaveSecurityExt() && targetDomainSecure then
         26               FAULTMASK_S[0] = '0';
         27           else
         28               FAULTMASK_NS[0] = '0';
         29       return;

E2.1.88 Debug_authentication
          1   // In the recommended CoreSight interface, there are four signals for external debug
          2   // authentication, DBGEN, SPIDEN, NIDEN and SPNIDEN. Each signal is active-HIGH.
          3
          4   signal   DBGEN;
          5   signal   SPIDEN;
          6   signal   NIDEN;
          7   signal   SPNIDEN;

E2.1.89 DebugCanMaskInts
          1   // DebugCanMaskInts()
          2   // ==================
          3
          4   boolean DebugCanMaskInts(boolean secure)
          5       if !HaltingDebugAllowed() || DHCSR.C_DEBUGEN == '0' then
          6            return FALSE;
          7       elsif secure && DHCSR.S_SDE == '0' then
          8            return FALSE;
          9       elsif HaveUDE() && secure && DHCSR.S_SUIDE == '1' then
         10            return FALSE;
         11       elsif HaveUDE() && DHCSR.S_NSUIDE == '1' then
         12            return FALSE;
         13       else
         14            return DHCSR.C_MASKINTS == '1';

E2.1.90 DebugRegisterTransfer
          1   // DebugRegisterTransfer()
          2   // =======================
          3
          4   DebugRegisterTransfer(bits(8) reg, boolean isWrite)
          5       isSecure    = IsSecure();
          6       unprivDbgS = HaveUDE() && DHCSR.S_SUIDE == '1';
          7       unprivDbgNS = HaveUDE() && DHCSR.S_NSUIDE == '1';
          8       unprivDbg   = if isSecure then unprivDbgS else unprivDbgNS;
          9
         10       if ((UInt(reg) >= UInt(DCRSR_REGSEL_R_LOW) && UInt(reg) <= UInt(DCRSR_REGSEL_R_HIGH)) ||
         11           reg == DCRSR_REGSEL_LR) then
         12           if isWrite then
         13               R[UInt(reg)] = DCRDR;
         14           else
         15               DCRDR = R[UInt(reg)];
         16
         17       elsif reg == DCRSR_REGSEL_SP then
         18           if isWrite then
         19               // This requires skipping stack limit checking,
         20               // hence a direct _RName access is used
         21               _RName[LookUpRName(UInt(reg))] = DCRDR[31:2]:'00';
         22           else
         23               DCRDR = _RName[LookUpRName(UInt(reg))];
         24
         25       elsif reg == DCRSR_REGSEL_DBGRETADDR then
         26           if isWrite then
         27               BranchTo(DCRDR, TRUE, FALSE);
         28           else
         29               DCRDR = _RName[RNamesPC];
         30
         31       elsif reg == DCRSR_REGSEL_XPSR then
         32           if isWrite then
         33               EAPSR = DCRDR[31:0];
         34           else
         35               DCRDR[31:0] = XPSR; // When accessed in unprivileged state the value of IPSR is 0
         36
         37       elsif reg == DCRSR_REGSEL_SP_MAIN then
         38           if isWrite then
         39               if !unprivDbg then
         40                   SP_Main = DCRDR;
         41           else
         42               if !unprivDbg then
         43                   DCRDR = SP_Main;
         44                else
         45                       DCRDR = Zeros();
         46
         47       elsif reg == DCRSR_REGSEL_SP_PROCESS then
         48           if isWrite then
         49               SP_Process = DCRDR;
         50           else
         51               DCRDR = SP_Process;
         52
         53       elsif reg == DCRSR_REGSEL_STATE then
         54           if isWrite then
         55               if !unprivDbg then
         56                    CONTROL[7:0] = DCRDR[31:24];
         57                    if HaveMainExt() then
         58                        FAULTMASK[7:0] = DCRDR[23:16];
         59                        BASEPRI[7:0]   = DCRDR[15:8];
         60                    PRIMASK[7:0] = DCRDR[7:0];
         61               else
         62                    if DHCSR.S_SDE == '1' then
         63                        CONTROL.SFPA = DCRDR[27];
         64                    CONTROL.FPCA = DCRDR[26];
         65                    if HavePACBTIExt() then
         66                        CONTROL.UPAC_EN = DCRDR[31];
         67                        CONTROL.UBTI_EN = DCRDR[29];
         68           else
         69               if !unprivDbg then
         70                    DCRDR[31:24] = CONTROL[7:0];
         71                    if HaveMainExt() then
         72                        DCRDR[23:16] = FAULTMASK[7:0];
         73                        DCRDR[15:8] = BASEPRI[7:0];
         74                    else
         75                        DCRDR[23:8] = Zeros(16);
         76                    DCRDR[7:0] = PRIMASK[7:0];
         77               else
         78                    bits(4) packet = Zeros(4);
         79                    if HavePACBTIExt() then
         80                        packet[3] = CONTROL.UPAC_EN;
         81                        packet[1] = CONTROL.UBTI_EN;
         82                    DCRDR[31:0] = (packet                        :
         83                                  (CONTROL.SFPA AND DHCSR.S_SDE) :
         84                                   CONTROL.FPCA                  :
         85                                   Zeros(26));
         86
         87       elsif reg == DCRSR_REGSEL_MSP_NS && HaveSecurityExt() then
         88           if isWrite then
         89               // Unprivileged-only debug is restricted even if MSP is being used by
         90               // unprivileged execution, a safe restriction that removes the
         91               // requirement to check other conditions here.
         92               if !unprivDbgNS then
         93                    SP_Main_NonSecure = DCRDR;
         94           else
         95               if !unprivDbgNS then
         96                    DCRDR = SP_Main_NonSecure;
         97               else
         98                    DCRDR[31:0] = Zeros();
         99
        100       elsif reg == DCRSR_REGSEL_PSP_NS && HaveSecurityExt() then
        101           if isWrite then
        102               SP_Process_NonSecure = DCRDR;
        103           else
        104               DCRDR = SP_Process_NonSecure;
        105
        106       elsif reg == DCRSR_REGSEL_MSP_S && HaveSecurityExt() then
        107           if isWrite then
        108               // Unprivileged-only debug is restricted even if MSP is being used by
        109               // unprivileged execution, a safe restriction that removes the
        110               // requirement to check other conditions here.
        111               if DHCSR.S_SDE == '1' && !unprivDbgS then
        112                   SP_Main_Secure = DCRDR;
        113           else
        114               if DHCSR.S_SDE == '1' && !unprivDbgS then
        115                    DCRDR = SP_Main_Secure;
        116               else
        117                    DCRDR = Zeros(32);
        118
        119       elsif reg == DCRSR_REGSEL_PSP_S && HaveSecurityExt() then
        120           if isWrite then
        121               if DHCSR.S_SDE == '1' then
        122                    SP_Process_Secure = DCRDR;
        123           else
        124               if DHCSR.S_SDE == '1' then
        125                    DCRDR = SP_Process_Secure;
        126               else
        127                    DCRDR = Zeros(32);
        128
        129       elsif reg == DCRSR_REGSEL_MSPLIM_S && HaveSecurityExt() then
        130           if isWrite then
        131               if DHCSR.S_SDE == '1' && !unprivDbgS then
        132                    MSPLIM_S = DCRDR[31:0];
        133           else
        134               if DHCSR.S_SDE == '1' && !unprivDbgS then
        135                    DCRDR[31:0] = MSPLIM_S;
        136               else
        137                    DCRDR = Zeros(32);
        138
        139       elsif reg == DCRSR_REGSEL_PSPLIM_S && HaveSecurityExt() then
        140           if isWrite then
        141               if DHCSR.S_SDE == '1' then
        142                    PSPLIM_S = DCRDR[31:0];
        143           else
        144               if DHCSR.S_SDE == '1' then
        145                    DCRDR[31:0] = PSPLIM_S;
        146               else
        147                    DCRDR = Zeros(32);
        148
        149       elsif reg == DCRSR_REGSEL_MSPLIM_NS && HaveMainExt() then
        150           if isWrite then
        151               if !unprivDbgNS then
        152                    MSPLIM_NS = DCRDR[31:0];
        153           else
        154               if !unprivDbgNS then
        155                    DCRDR[31:0] = MSPLIM_NS;
        156               else
        157                    DCRDR[31:0] = Zeros();
        158
        159       elsif reg == DCRSR_REGSEL_PSPLIM_NS && HaveMainExt() then
        160           if isWrite then
        161               PSPLIM_NS = DCRDR[31:0];
        162           else
        163               DCRDR[31:0] = PSPLIM_NS;
        164
        165       elsif reg == DCRSR_REGSEL_FPSCR && (HaveFPExt() || HaveMve()) then
        166           if isWrite then
        167               if CanDebugAccessFP() then
        168                    FPSCR = DCRDR[31:0];
        169           else
        170               if CanDebugAccessFP() then
        171                    DCRDR[31:0] = FPSCR;
        172               else
        173                    DCRDR = Zeros(32);
        174
        175       elsif reg == DCRSR_REGSEL_STATE_S && HaveSecurityExt() then
        176           if isWrite then
        177               if DHCSR.S_SDE == '1' then
        178                   if !unprivDbgS then
        179                       CONTROL_S[7:0] = DCRDR[31:24];
        180                       if HaveMainExt() then
        181                           FAULTMASK_S[7:0] = DCRDR[23:16];
        182                             BASEPRI_S[7:0]   = DCRDR[15:8];
        183                         PRIMASK_S[7:0] = DCRDR[7:0];
        184                     else
        185                         CONTROL_S.SFPA = DCRDR[27];
        186                         CONTROL_S.FPCA = DCRDR[26];
        187                         if HavePACBTIExt() then
        188                             CONTROL_S.UPAC_EN = DCRDR[31];
        189                             CONTROL_S.UBTI_EN = DCRDR[29];
        190           else
        191               if DHCSR.S_SDE == '1' then
        192                    if !unprivDbgS then
        193                        DCRDR[31:24] = CONTROL_S[7:0];
        194                        if HaveMainExt() then
        195                             DCRDR[23:16] = FAULTMASK_S[7:0];
        196                             DCRDR[15:8] = BASEPRI_S[7:0];
        197                        else
        198                             DCRDR[23:8] = Zeros(16);
        199                        DCRDR[7:0] = PRIMASK_S[7:0];
        200                    else
        201                        bits(4) packet = Zeros(4);
        202                        if HavePACBTIExt() then
        203                             packet[3] = CONTROL_S.UPAC_EN;
        204                             packet[1] = CONTROL_S.UBTI_EN;
        205                        DCRDR = packet : CONTROL_S.SFPA : CONTROL_S.FPCA : Zeros(26);
        206               else
        207                    DCRDR = Zeros(32);
        208
        209       elsif reg == DCRSR_REGSEL_STATE_NS && HaveSecurityExt() then
        210           if isWrite then
        211               if !unprivDbgNS then
        212                    CONTROL_NS[7:0] = DCRDR[31:24];
        213                    if HaveMainExt() then
        214                        FAULTMASK_NS[7:0] = DCRDR[23:16];
        215                        BASEPRI_NS[7:0]   = DCRDR[15:8];
        216                    PRIMASK_NS[7:0] = DCRDR[7:0];
        217               else
        218                    CONTROL_NS.FPCA = DCRDR[26];
        219                    if HavePACBTIExt() then
        220                        CONTROL_NS.UPAC_EN = DCRDR[31];
        221                        CONTROL_NS.UBTI_EN = DCRDR[29];
        222           else
        223               if !unprivDbgNS then
        224                    DCRDR[31:24] = CONTROL_NS[7:0];
        225                    if HaveMainExt() then
        226                        DCRDR[23:16] = FAULTMASK_NS[7:0];
        227                        DCRDR[15:8] = BASEPRI_NS[7:0];
        228                    else
        229                        DCRDR[23:8] = Zeros(16);
        230                    DCRDR[7:0] = PRIMASK_NS[7:0];
        231               else
        232                    bits(5) packet = Zeros(5);
        233                    if HavePACBTIExt() then
        234                        packet[4] = CONTROL_NS.UPAC_EN;
        235                        packet[2] = CONTROL_NS.UBTI_EN;
        236                    DCRDR = packet : CONTROL_NS.FPCA : Zeros(26);
        237
        238       elsif reg == DCRSR_REGSEL_VPR && HaveMve() then
        239           if isWrite then
        240               if CanDebugAccessFP() then
        241                    VPR = DCRDR[31:0];
        242           else
        243               if CanDebugAccessFP() then
        244                    DCRDR = VPR[31:0];
        245               else
        246                    DCRDR = Zeros(32);
        247
        248       elsif (UInt(reg) >= UInt(DCRSR_REGSEL_S_LOW) &&
        249              UInt(reg) <= UInt(DCRSR_REGSEL_S_HIGH) && (HaveFPExt() || HaveMve())) then
        250           if isWrite then
        251                  if CanDebugAccessFP() then
        252                       _S[UInt(reg[5:0])] = DCRDR;
        253              else
        254                  if CanDebugAccessFP() then
        255                       DCRDR = _S[UInt(reg[5:0])];
        256                  else
        257                       DCRDR = Zeros(32);
        258
        259       elsif (UInt(reg) >= UInt(DCRSR_REGSEL_PAC_KEY_P_LOW) &&
        260              UInt(reg) <= UInt(DCRSR_REGSEL_PAC_KEY_U_HIGH) && HavePACBTIExt()) then
        261           if isWrite then
        262               if !unprivDbg then
        263                    PACKeyReg[reg[2:0], isSecure] = DCRDR;
        264           else
        265               if !unprivDbg then
        266                    DCRDR = PACKeyReg[reg[2:0], isSecure];
        267               else
        268                    DCRDR = Zeros();
        269
        270       elsif (UInt(reg) >= UInt(DCRSR_REGSEL_PAC_KEY_P_S_LOW) &&
        271              UInt(reg) <= UInt(DCRSR_REGSEL_PAC_KEY_U_S_HIGH) &&
        272              HavePACBTIExt() && HaveSecurityExt()) then
        273           if isWrite then
        274               if DHCSR.S_SDE == '1' && !unprivDbgS then
        275                    PACKeyReg[reg[2:0], TRUE] = DCRDR;
        276           else
        277               if DHCSR.S_SDE == '1' && !unprivDbgS then
        278                    DCRDR = PACKeyReg[reg[2:0], TRUE];
        279               else
        280                    DCRDR = Zeros();
        281
        282       elsif (UInt(reg) >= UInt(DCRSR_REGSEL_PAC_KEY_P_NS_LOW) &&
        283              UInt(reg) <= UInt(DCRSR_REGSEL_PAC_KEY_U_NS_HIGH) &&
        284              HavePACBTIExt() && HaveSecurityExt()) then
        285           if isWrite then
        286               if !unprivDbgNS then
        287                    PACKeyReg[reg[2:0], FALSE] = DCRDR;
        288           else
        289               if !unprivDbgNS then
        290                    DCRDR = PACKeyReg[reg[2:0], FALSE];
        291               else
        292                    DCRDR = Zeros();
        293
        294       else
        295              DCRDR = bits(32) UNKNOWN;

E2.1.91 DecodeExecute
          1   // DecodeExecute
          2   // =============
          3   // Decode instruction and execute
          4
          5   DecodeExecute(bits(32) instr, bits(32) pc, boolean isT16, bits(4) defaultCond);

E2.1.92 DecodeImmShift
          1   // DecodeImmShift()
          2   // ================
          3
          4   (SRType, integer) DecodeImmShift(bits(2) sr_type, bits(5) imm5)
          5
          6       case sr_type of
          7           when '00'
          8               shift_t = SRType_LSL;           shift_n = UInt(imm5);
          9           when '01'
         10               shift_t = SRType_LSR;           shift_n = if imm5 == '00000' then 32 else UInt(imm5);
         11           when '10'
         12               shift_t = SRType_ASR; shift_n = if imm5 == '00000' then 32 else UInt(imm5);
         13           when '11'
         14               if imm5 == '00000' then
         15                    shift_t = SRType_RRX; shift_n = 1;
         16               else
         17                    shift_t = SRType_ROR; shift_n = UInt(imm5);
         18
         19       return (shift_t, shift_n);

E2.1.93 DecodeRegShift
          1   // DecodeRegShift()
          2   // ================
          3
          4   SRType DecodeRegShift(bits(2) sr_type)
          5       case sr_type of
          6           when '00' shift_t = SRType_LSL;
          7           when '01' shift_t = SRType_LSR;
          8           when '10' shift_t = SRType_ASR;
          9           when '11' shift_t = SRType_ROR;
         10       return shift_t;

E2.1.94 DefaultCond
          1   // DefaultCond()
          2   // =============
          3
          4   bits(4) DefaultCond()
          5       // If in an IT block us the IT condition, otherwise set the condition to
          6       // always (I.E. 0xE).
          7       // NOTE: This is only the default condition, as it may be overridden by an
          8       //        explicit condition code in the instruction itself.
          9       if ITSTATE[3:0] == Zeros(4) then
         10            cond = 0xE[3:0];
         11       else
         12            cond = ITSTATE[7:4];
         13       return cond;

E2.1.95 DefaultExcInfo
          1   // DefaultExcInfo()
          2   // ================
          3
          4   ExcInfo DefaultExcInfo()
          5       ExcInfo exc;
          6
          7       exc.fault         =   NoFault;
          8       exc.origFault     =   NoFault;
          9       exc.isSecure      =   boolean UNKNOWN;
         10       exc.isTerminal    =   FALSE;
         11       exc.inExcTaken    =   FALSE;
         12       exc.lockup        =   FALSE;
         13       exc.termInst      =   TRUE;
         14       return exc;

E2.1.96 DefaultMemoryAttributes
          1   // DefaultMemoryAttributes()
          2   // =========================
          3
          4   MemoryAttributes DefaultMemoryAttributes(bits(32) address)
          5
          6       MemoryAttributes memattrs;
          7
          8       case address[31:29] of
          9           when '000'
         10               memattrs.memtype = MemType_Normal;
         11               memattrs.device = DeviceType UNKNOWN;
         12               memattrs.innerattrs = '10';
         13               memattrs.shareable = FALSE;
         14           when '001'
         15               memattrs.memtype = MemType_Normal;
         16               memattrs.device = DeviceType UNKNOWN;
         17               memattrs.innerattrs = '11';
         18               memattrs.shareable = FALSE;
         19           when '010'
         20               memattrs.memtype = MemType_Device;
         21               memattrs.device = DeviceType_nGnRE;
         22               memattrs.innerattrs = '00';
         23               memattrs.shareable = TRUE;
         24           when '011'
         25               memattrs.memtype = MemType_Normal;
         26               memattrs.device = DeviceType UNKNOWN;
         27               memattrs.innerattrs = '11';
         28               memattrs.shareable = FALSE;
         29           when '100'
         30               memattrs.memtype = MemType_Normal;
         31               memattrs.device = DeviceType UNKNOWN;
         32               memattrs.innerattrs = '10';
         33               memattrs.shareable = FALSE;
         34           when '101'
         35               memattrs.memtype = MemType_Device;
         36               memattrs.device = DeviceType_nGnRE;
         37               memattrs.innerattrs = '00';
         38               memattrs.shareable = TRUE;
         39           when '110'
         40               memattrs.memtype = MemType_Device;
         41               memattrs.device = DeviceType_nGnRE;
         42               memattrs.innerattrs = '00';
         43               memattrs.shareable = TRUE;
         44           when '111'
         45               if address[28:20] == '000000000' then
         46                    memattrs.memtype = MemType_Device;
         47                    memattrs.device = DeviceType_nGnRnE;
         48                    memattrs.innerattrs = '00';
         49                    memattrs.shareable = TRUE;
         50               else
         51                    memattrs.memtype = MemType_Device;
         52                    memattrs.device = DeviceType_nGnRE;
         53                    memattrs.innerattrs = '00';
         54                    memattrs.shareable = TRUE;
         55
         56       // Outer attributes are the same as the inner attributes in all cases.
         57       memattrs.outerattrs = memattrs.innerattrs;
         58       memattrs.outershareable = memattrs.shareable;
         59
         60       // Setting as UNKNOWN by default. This flag will be                 overwritten based on
         61       // SAU/IDAU checking in SecurityCheck()
         62       memattrs.NS = boolean UNKNOWN;
         63       return memattrs;

E2.1.97 DefaultPermissions
          1   // DefaultPermissions()
          2   // ====================
          3
          4   Permissions DefaultPermissions(bits(32) address)
          5
          6       Permissions perms;
          7
          8       perms.ap              = '01';
          9       perms.apValid         = TRUE;
         10       perms.region      = Zeros(8);
         11       perms.regionValid = FALSE;
         12
         13       case address[31:29] of
         14           when '000'
         15               perms.xn = '0';
         16           when '001'
         17               perms.xn = '0';
         18           when '010'
         19               perms.xn = '1';
         20           when '011'
         21               perms.xn = '0';
         22           when '100'
         23               perms.xn = '0';
         24           when '101'
         25               perms.xn = '1';
         26           when '110'
         27               perms.xn = '1';
         28           when '111'
         29               perms.xn = '1';
         30
         31       return perms;

E2.1.98 DerivedLateArrival
          1   // DerivedLateArrival()
          2   // ====================
          3
          4   DerivedLateArrival(integer pePriority, integer peNumber, boolean peIsSecure, ExcInfo deInfo,
          5                      integer oeNumber, boolean oeIsSecure, EXC_RETURN_Type excReturn)
          6       // PE: the pre-empted exception - before exception entry
          7       // OE: the original exception - exception entry
          8       // DE: the derived exception - fault on exception entry
          9
         10       // Get the priorities of the exceptions
         11       // xePriority: the lower the value, the higher the priority
         12       oePriority = ExceptionPriority(oeNumber, oeIsSecure, FALSE);
         13       // NOTE: Comparison of dePriority against PE priority and possible
         14       // escalation to HardFault has already occurred. See CreateException().
         15
         16       // Is the derived exception a DebugMonitor
         17       if HaveMainExt() then
         18            deIsDbgMonFault = (deInfo.origFault == DebugMonitor);
         19       else
         20            deIsDbgMonFault = FALSE;
         21
         22       // Work out which fault to take, and what the target domain is
         23       if deInfo.isTerminal then
         24           // Derived exception is terminal and prevents the original exception
         25           // being taken (for example fault on vector fetch). As a result the
         26           // derived exception is treated as a HardFault.
         27           targetIsSecure = deInfo.isSecure;
         28           targetFault    = deInfo.fault;
         29           // If the derived fault does not have sufficient priority to pre-empt
         30           // lockup instead of taking it.
         31           if !ComparePriorities(deInfo, FALSE, oePriority, oeNumber, oeIsSecure) then
         32               _ = ExceptionTaken(oeNumber, deInfo.inExcTaken, oeIsSecure,
         33                                  IgnoreFaults_ALL, excReturn);
         34               // Since execution of original exception cannot be started, lockup
         35               // at the current priority level. That is the priority of the original
         36               // exception.
         37               Lockup(TRUE);
         38       elsif (deIsDbgMonFault &&
         39             !ComparePriorities(deInfo, TRUE, pePriority, peNumber, peIsSecure)) then
         40           // Ignore the DebugMonitorFault and take original exception
         41           SetPending(DebugMonitor, deInfo.isSecure, FALSE);
         42           targetFault    = oeNumber;
         43           targetIsSecure = oeIsSecure;
         44        elsif ComparePriorities(deInfo, FALSE, oePriority, oeNumber, oeIsSecure) then
         45             // Derive exception has a higher priority (that is a lower value) than the
         46             // original exception, so the derived exception first. Tail-chaining
         47             // IMPLEMENTATION DEFINED
         48             targetFault     = deInfo.fault;
         49             targetIsSecure = deInfo.isSecure;
         50        else
         51             // If the derived exception caused a lockup then this must be handled
         52             // now as the lockup cannot be pended until the original exception
         53             // returns
         54             if deInfo.lockup then
         55                 // Lockup at the priority of the original exception being entered.
         56                 _ = ExceptionTaken(oeNumber, deInfo.inExcTaken, oeIsSecure,
         57                                     IgnoreFaults_ALL, excReturn);
         58                 Lockup(TRUE);
         59             else
         60                 // DE will be pended below, start execution of the OE
         61                 targetFault     = oeNumber;
         62                 targetIsSecure = oeIsSecure;
         63
         64        // If none of the tests above have triggered a lockup (which would have
         65        // terminated execution of the pseudocode) then the derived exception
         66        // must be pended and any escalation syndrome info generated
         67        if HaveMainExt() &&
         68           (deInfo.fault     == HardFault) &&
         69           (deInfo.origFault != HardFault) then
         70            HFSR.FORCED = '1';
         71        SetPending(deInfo.fault, deInfo.isSecure, TRUE);
         72
         73        // Take the target exception. NOTE: None terminal faults are ignored when
         74        // handling the derived exception, allowing forward progress to be made.
         75        (excInfo, excReturn) = ExceptionTaken(targetFault, deInfo.inExcTaken,
         76                                              targetIsSecure, IgnoreFaults_STACK, excReturn);
         77        // If trying to take the resulting exception results in another fault, then handle
         78        // the derived derived fault.
         79        if excInfo.fault != NoFault then
         80            DerivedLateArrival(pePriority, peNumber, peIsSecure, excInfo, targetFault,
         81                               targetIsSecure, excReturn);

E2.1.99 DeviceType
          1   // Types of memory
          2
          3   enumeration DeviceType {DeviceType_GRE,   DeviceType_nGRE,
          4                           DeviceType_nGnRE, DeviceType_nGnRnE};

E2.1.100 DWT_AddressCompare
          1   //   DWT_AddressCompare()
          2   //   ====================
          3   //   Returns a pair of values. The first result is whether the (masked) addresses are equal,
          4   //   where the access address (addr) is masked according to DWT_FUNCTION[n].DATAVSIZE and the
          5   //   comparator address (compaddr) is masked according to the access size. The second result
          6   //   is whether the (unmasked) addr is greater than the (unmasked) compaddr.
          7
          8   (boolean,boolean) DWT_AddressCompare(bits(32) addr, bits(32) compaddr, integer size,
          9                                     integer compsize)
         10       // addr must be a multiple of size. Unaligned accesses are split into smaller accesses.
         11       assert Align(addr, size) == addr;
         12
         13        // compaddr must be a multiple of compsize
         14        if Align(compaddr, compsize) != compaddr then UNPREDICTABLE;
         15
         16        addrmatch   = (Align(addr, compsize) == Align(compaddr, size));
         17        addrgreater = (UInt(addr) > UInt(compaddr));
         18        return (addrmatch,addrgreater);

E2.1.101 DWT_CycCountMatch
          1   //   DWT_CycCountMatch
          2   //   =================
          3   //   Check for DWT cycle count match. This is called for each increment of
          4   //   DWT_CYCCNT.
          5
          6   DWT_CycCountMatch()
          7       boolean trigger_debug_event = FALSE;
          8       boolean debug_event = FALSE;
          9       N = UInt(DWT_CTRL.NUMCOMP);
         10       if N == 0 then return; // No comparator support
         11       secure_match = IsSecure() && DWT_CTRL.CYCDISS == '1';
         12       for i = 0 to N-1
         13           if IsDWTConfigUnpredictable(i) then UNPREDICTABLE;
         14           if DWT_FUNCTION[i].MATCH == '0001' && DWT_ValidMatch(i, secure_match, FindPriv())
         15                                              && DWT_CYCCNT == DWT_COMP[i] then
         16               DWT_FUNCTION[i].MATCHED = '1';
         17               debug_event = DWT_FUNCTION[i].ACTION == '01';
         18           trigger_debug_event = trigger_debug_event || debug_event;
         19
         20        // Setting the debug event if at least one comparator matches
         21        if trigger_debug_event then
         22            debug_event = SetDWTDebugEvent(secure_match, FindPriv());
         23        return;

E2.1.102 DWT_DataAddressMatch
          1   //   DWT_DataAddressMatch()
          2   //   ======================
          3   //   Check for match of access at "daddr". "dsize", "read", "NSreq", and "privilege" are the
          4   //   attributes for the access. Note that for a load or store instruction, "NSreq" is the
          5   //   current Security state of the PE, but this is not necessarily true for a hardware stack
          6   //   push/pop or vector table access. "NSreq" might not be the same as the "NSattr"
          7   //   attribute the PE finally uses to make the access.
          8   //   If comparators 'm' and 'm+1' form an Data Address Range comparator, then this function
          9   //   returns the range match result when N=m+1.
         10
         11   boolean DWT_DataAddressMatch(integer N, bits(32) daddr, integer dsize, boolean read,
         12                                boolean NSreq, boolean priv_match)
         13       assert N < UInt(DWT_CTRL.NUMCOMP) && dsize IN {1,2,4} && Align(daddr, dsize) == daddr;
         14
         15        valid_match = DWT_ValidMatch(N, !NSreq, priv_match);
         16        valid_addr = DWT_FUNCTION[N].MATCH == 'x1xx';
         17
         18        if valid_match && valid_addr then
         19            if N != UInt(DWT_CTRL.NUMCOMP)-1 then
         20                linked_to_addr = DWT_FUNCTION[N+1].MATCH == '0111';                    // Data Address Limit
         21                linked_to_data = DWT_FUNCTION[N+1].MATCH == '1011';                    // Linked Data Value
         22            else
         23                linked_to_addr = FALSE; linked_to_data = FALSE;
         24
         25             case DWT_FUNCTION[N].MATCH[1:0] of
         26                 when '00' match_lsc = TRUE;    linked = FALSE;
         27                 when '01' match_lsc = !read; linked = FALSE;
         28                 when '10' match_lsc = read;    linked = FALSE;
         29                 when '11'
         30
         31                     case DWT_FUNCTION[N-1].MATCH[1:0] of
         32                         when '00' match_lsc = TRUE;    linked = TRUE;
         33                         when '01' match_lsc = !read; linked = TRUE;
         34                         when '10' match_lsc = read;    linked = TRUE;
         35
         36             if !linked_to_addr then
         37                 vsize = 2^UInt(DWT_FUNCTION[N].DATAVSIZE);
         38                 (match_eq,match_gt) = DWT_AddressCompare(daddr, DWT_COMP[N], dsize, vsize);
         39
         40                  if linked then
         41                       valid_match = DWT_ValidMatch(N-1, !NSreq, priv_match);
         42                       (lower_eq,lower_gt) = DWT_AddressCompare(daddr, DWT_COMP[N-1], dsize, 1);
         43                       match_addr = valid_match && (lower_eq || lower_gt) && !match_gt;
         44                  else
         45                       match_addr = match_eq;
         46              else
         47                  match_addr = FALSE;
         48
         49              match = match_addr && match_lsc;
         50       else
         51              match = FALSE;
         52
         53       return match;

E2.1.103 DWT_DataMatch
          1   // DWT_DataMatch()
          2   // ===============
          3   // Perform varioius Data match checks for DWT
          4
          5   DWT_DataMatch(bits(32) daddr, integer dsize, bits(32) dvalue, boolean read, boolean NSreq,
          6                 boolean priv_match)
          7
          8       boolean trigger_debug_event = FALSE;
          9       boolean debug_event = FALSE;
         10
         11       if !HaveDWT() || IsZero(DWT_CTRL.NUMCOMP) then return; // No comparator support
         12
         13       for i = 0 to UInt(DWT_CTRL.NUMCOMP) - 1
         14           if IsDWTConfigUnpredictable(i) then UNPREDICTABLE;
         15           daddr_match = DWT_DataAddressMatch(i, daddr, dsize, read, NSreq, priv_match);
         16           dvalue_match = DWT_DataValueMatch(i, daddr, dvalue, dsize, read, NSreq, priv_match);
         17
         18              // Data Address and Data Address Limit
         19              if daddr_match && DWT_FUNCTION[i].MATCH == '01xx' then
         20                  // Data Address
         21                  if DWT_FUNCTION[i].MATCH != '0111' then
         22                      DWT_FUNCTION[i].MATCHED = '1';
         23                      debug_event = DWT_FUNCTION[i].ACTION == '01';
         24
         25                  // Data Address with Data Address Limit
         26                  else
         27                       //ith comparator
         28                       DWT_FUNCTION[i].MATCHED = bit UNKNOWN;
         29                       // (i-1)th comparator
         30                       DWT_FUNCTION[i-1].MATCHED = '1';
         31                       debug_event = DWT_FUNCTION[i-1].ACTION == '01';
         32
         33              // Data Value and Linked Data Value
         34              if dvalue_match && DWT_FUNCTION[i].MATCH == '10xx' then
         35                  // Data Value
         36                  if DWT_FUNCTION[i].MATCH != '1011' then
         37                      DWT_FUNCTION[i].MATCHED = '1';
         38                      debug_event = DWT_FUNCTION[i].ACTION == '01';
         39
         40                  // For Linked Data Value, daddr_match will be TRUE for [i-1]
         41                  else
         42                       DWT_FUNCTION[i].MATCHED = '1';
         43                       debug_event = DWT_FUNCTION[i].ACTION == '01';
         44
         45              // Data Address with Value
         46              if daddr_match && DWT_FUNCTION[i].MATCH == '11xx' then
         47                  DWT_FUNCTION[i].MATCHED = '1';
         48                  // No debug_event generated in the case of Data Address with Value
         49
         50              trigger_debug_event = trigger_debug_event || debug_event;
         51
         52        // Setting the debug event if at least one comparator matches
         53        if trigger_debug_event then
         54            debug_event = SetDWTDebugEvent(!NSreq, priv_match);
         55
         56        return;

E2.1.104 DWT_DataValueMatch
          1   //   DWT_DataValueMatch()
          2   //   ====================
          3   //   Check for match of access of "dvalue" at "daddr". "dsize", "read" and "NSreq"
          4   //   and "priv_match" are the attributes for the access. Note that for a load or store
          5   //   instruction, "NSreq" is the current Security state of the PE, but this is not
          6   //   necessarily true for a hardware stack push/pop or vector table access. "NSreq"
          7   //   might not be the same as the "NSattr" attribute the PE finally uses to make the access.
          8
          9   boolean DWT_DataValueMatch(integer N, bits(32) daddr, bits(32) dvalue, integer dsize,
         10                              boolean read, boolean NSreq, boolean priv_match)
         11       assert N < UInt(DWT_CTRL.NUMCOMP) && dsize IN {1,2,4} && Align(daddr,dsize) == daddr;
         12
         13        valid_match = DWT_ValidMatch(N, !NSreq, priv_match);
         14        valid_data = DWT_FUNCTION[N].MATCH[3:2] == '10';
         15
         16        if valid_match && valid_data then
         17            case DWT_FUNCTION[N].MATCH[1:0] of
         18                when '00' match_lsc = TRUE;    linked              = FALSE;
         19                when '01' match_lsc = !read; linked                = FALSE;
         20                when '10' match_lsc = read;    linked              = FALSE;
         21                when '11'
         22                    case DWT_FUNCTION[N-1].MATCH[1:0]              of
         23                        when '00' match_lsc = TRUE;                 linked = TRUE;
         24                        when '01' match_lsc = !read;                linked = TRUE;
         25                        when '10' match_lsc = read;                 linked = TRUE;
         26
         27             vsize = 2^UInt(DWT_FUNCTION[N].DATAVSIZE);
         28
         29             // Determine which bytes of dvalue to look at in the comparison.
         30             if linked then
         31                 byte_mask = '0000'; // Filled in below if there is an address match
         32                 if DWT_DataAddressMatch(N-1, daddr, dsize, read, NSreq, priv_match) then
         33                     case (vsize,dsize) of
         34                         when (1,1) byte_mask[0] = '1';
         35                         when (1,2) byte_mask[UInt(DWT_COMP[N-1][0])] = '1';
         36                         when (1,4) byte_mask[UInt(DWT_COMP[N-1][1:0])] = '1';
         37                         when (2,2) byte_mask[1:0] = '11';
         38                         when (2,4)
         39                             byte_mask[UInt(DWT_COMP[N-1][1:0])+1:UInt(DWT_COMP[N-1][1:0])]='11';
         40                         when (4,4) byte_mask = '1111';
         41                         otherwise   byte_mask = '0000';   // vsize > dsize: no match
         42             else
         43                 case dsize of
         44                     when 1 byte_mask = '0001';
         45                     when 2 byte_mask = '0011';
         46                     when 4 byte_mask = '1111';
         47
         48             // Perform bitwise mask on the candidate data value
         49             bit_mask = (if HasArchVersion(Armv8p1) then DWT_VMASK[N] else Zeros(32));
         50             dvalue = (dvalue AND NOT bit_mask);
         51
         52             // Split both values into byte lanes: DCBA and dcba.
         53             // This function relies on the values being correctly replicated across DWT_COMP[N].
         54             D = dvalue[31:24]; C = dvalue[23:16]; B = dvalue[15:8]; A = dvalue[7:0];
         55             d = DWT_COMP[N][31:24]; c = DWT_COMP[N][23:16];
         56             b = DWT_COMP[N][15:8]; a = DWT_COMP[N][7:0];
         57
         58             // Partial results
         59             D_d = byte_mask[3] == '1' && D == d;
         60             C_c = byte_mask[2] == '1' && C == c;
         61               B_b = byte_mask[1] == '1' && B == b;
         62               A_a = byte_mask[0] == '1' && A == a;
         63
         64               // Combined   partial results
         65               BA_ba = B_b   && A_a;
         66               DC_dc = D_d   && C_c;
         67               DCBA_dcba =   D_d && C_c && B_b && A_a;
         68
         69               // Generate full results
         70               case (vsize,dsize) of
         71                   when (1,-)         match_data         =   D_d || C_c || B_b || A_a;
         72                   when (2,2), (2,4) match_data          =   DC_dc || BA_ba;
         73                   when (4,4)         match_data         =   DCBA_dcba;
         74                   otherwise          match_data         =   FALSE;     // vsize > dsize: no match
         75
         76               match = match_data && match_lsc;
         77        else
         78               match = FALSE;
         79
         80        return match;

E2.1.105 DWT_InstructionAddressMatch
          1   //   DWT_InstructionAddressMatch()
          2   //   =============================
          3   //   Check for match of instruction access at "Iaddr".
          4   //   If comparators 'm' and 'm+1' form an Instruction Address Range comparator, then this
          5   //   function returns the range match when N=m+1.
          6
          7   boolean DWT_InstructionAddressMatch(integer N, bits(32) Iaddr, boolean isSecure,
          8                                       boolean isPriv)
          9       assert N < UInt(DWT_CTRL.NUMCOMP) && Align(Iaddr, 2) == Iaddr;
         10
         11        valid_match = DWT_ValidMatch(N, isSecure, isPriv);
         12        valid_instr = DWT_FUNCTION[N].MATCH == '001x';
         13
         14        if valid_match && valid_instr then
         15            if N != UInt(DWT_CTRL.NUMCOMP)-1 then
         16                linked_to_instr = DWT_FUNCTION[N+1].MATCH == '0011';
         17            else
         18                linked_to_instr = FALSE;
         19
         20               if DWT_FUNCTION[N].MATCH == '0011' then
         21                   linked = TRUE;
         22               else
         23                   linked = FALSE;
         24
         25               if !linked_to_instr then
         26                   (match_eq,match_gt) = DWT_AddressCompare(Iaddr, DWT_COMP[N], 2, 2);
         27                   if linked then
         28                        valid_match = DWT_ValidMatch(N-1, isSecure, isPriv);
         29                        (lower_eq,lower_gt) = DWT_AddressCompare(Iaddr, DWT_COMP[N-1], 2, 2);
         30                        match_addr = valid_match && (lower_eq || lower_gt) && !match_gt;
         31                   else
         32                        match_addr = match_eq;
         33               else
         34                   match_addr = FALSE;
         35               match = match_addr;
         36        else
         37               match = FALSE;
         38
         39        return match;

E2.1.106 DWT_InstructionMatch
          1   // DWT_InstructionMatch()
          2   // =====================
          3   // Perform various Instruction Address checks for DWT
          4
          5   DWT_InstructionMatch(bits(32) Iaddr, boolean isSecure, boolean isPriv)
          6
          7        boolean trigger_debug_event = FALSE;
          8        boolean debug_event = FALSE;
          9
         10        if !HaveDWT() || IsZero(DWT_CTRL.NUMCOMP) then return; // No comparator support
         11
         12        for i = 0 to UInt(DWT_CTRL.NUMCOMP) - 1
         13            if IsDWTConfigUnpredictable(i) then UNPREDICTABLE;
         14            instr_addr_match = DWT_InstructionAddressMatch(i, Iaddr, isSecure, isPriv);
         15            if instr_addr_match then
         16                // Instruction Address
         17                if DWT_FUNCTION[i].MATCH == '0010' then
         18                    DWT_FUNCTION[i].MATCHED = '1';
         19                    debug_event = DWT_FUNCTION[i].ACTION == '01';
         20
         21                 // Instruction Address Limit
         22                 elsif DWT_FUNCTION[i].MATCH == '0011' then
         23                     DWT_FUNCTION[i].MATCHED = bit UNKNOWN;
         24                     DWT_FUNCTION[i-1].MATCHED = '1';
         25                     debug_event = DWT_FUNCTION[i-1].ACTION == '01';
         26
         27                 trigger_debug_event = trigger_debug_event || debug_event;
         28
         29        if trigger_debug_event then
         30            debug_event = SetDWTDebugEvent(isSecure, isPriv);
         31        return;

E2.1.107 DWT_ValidMatch
          1   //   DWT_ValidMatch()
          2   //   ================
          3   //   Returns TRUE if this match is permitted by the current authentication controls,
          4   //   FALSE otherwise.
          5
          6   boolean DWT_ValidMatch(integer N, boolean secure_match, boolean priv_match)
          7       if !HaveSecurityExt() then assert !secure_match;
          8
          9        // Check for disabled
         10        if (((secure_match && !SecureNoninvasiveDebugAllowed(priv_match)) ||
         11             !NoninvasiveDebugAllowed(priv_match)) ||
         12             DEMCR.TRCENA == '0' ||
         13             DWT_FUNCTION[N].MATCH == '0000') then
         14            return FALSE;
         15
         16        // Check for Debug event
         17        if DWT_FUNCTION[N].ACTION == '01' then
         18             hlt_en = CanHaltOnEvent(secure_match, priv_match);
         19             // Ignore priority when checking whether DebugMonitor activates DWT matches
         20             mon_en = (HaveDebugMonitor() && CanPendMonitorOnEvent(secure_match, FALSE, TRUE,
         21                                                                   priv_match, TRUE));
         22             return (hlt_en || mon_en);
         23        else
         24             // Otherwise trace or trigger event
         25             return !secure_match || SecureNoninvasiveDebugAllowed(priv_match);

E2.1.108 Elem
          1   // Elem[]
          2   // ======
          3
          4   // Non-assignment form
          5
          6   bits(size) Elem[bits(N) vector, integer e, integer size]
          7       assert e >= 0 && (e+1)*size <= N;
          8       return vector[(e+1)*size-1:e*size];
          9
         10   bits(size) Elem[bits(N) vector, integer e]
         11       return Elem[vector, e, size];
         12
         13   // Assignment form
         14
         15   Elem[bits(N) &vector, integer e, integer size] = bits(size) value
         16       assert e >= 0 && (e+1)*size <= N;
         17       vector[(e+1)*size-1:e*size] = value;
         18       return;
         19
         20   Elem[bits(N) &vector, integer e] = bits(size) value
         21       Elem[vector, e, size] = value;
         22       return;

E2.1.109 EndOfInstruction
          1   // EndOfInstruction
          2   // ================
          3   // Terminates the processing of current instruction.
          4
          5   EndOfInstruction();

E2.1.110 EventRegistered
          1   // EventRegistered
          2   // ===============
          3   // Returns TRUE if PE Event Register is set to 1 and FALSE otherwise.
          4
          5   boolean EventRegistered();

E2.1.111 ExceptionActiveBitCount
          1   // ExceptionActiveBitCount()
          2   // =========================
          3
          4   integer ExceptionActiveBitCount()
          5       integer count = 0;
          6       for i = 0 to MaxExceptionNum()
          7           for j = 0 to 1
          8               if IsActiveForState(i, j == 0) then
          9                   count = count + 1;
         10       return count;

E2.1.112 ExceptionDetails
          1   // ExceptionDetails()
          2   // ==================
          3
          4   (boolean, boolean) ExceptionDetails(integer exception, boolean isSecure,
          5                                        boolean isSynchronous)
          6       // Is the exception subject to escalation
          7       case exception of
          8           when HardFault
          9               termInst     = TRUE;
         10               canPend      = TRUE;
         11               canEscalate = TRUE;
         12           when MemManage
         13               termInst     = TRUE;
         14               if HaveMainExt() then
         15                    val     = if isSecure then SHCSR_S else SHCSR_NS;
         16                    canPend = val.MEMFAULTENA == '1';
         17               else
         18                   canPend     = FALSE;
         19               canEscalate     = TRUE;
         20           when BusFault
         21               termInst     = isSynchronous;
         22               canPend      = if HaveMainExt()
         23                              then SHCSR_S.BUSFAULTENA == '1' else FALSE;
         24               // Async BusFaults only escalate if they are disabled
         25               canEscalate = termInst || !canPend;
         26           when UsageFault
         27               termInst     = TRUE;
         28               if HaveMainExt() then
         29                    val     = if isSecure then SHCSR_S else SHCSR_NS;
         30                    canPend = val.USGFAULTENA == '1';
         31               else
         32                    canPend = FALSE;
         33               canEscalate = TRUE;
         34           when SecureFault
         35               termInst     = TRUE;
         36               canPend      = if HaveMainExt()
         37                              then SHCSR_S.SECUREFAULTENA == '1' else FALSE;
         38               canEscalate = TRUE;
         39           when SVCall
         40               termInst     = FALSE;
         41               canPend      = TRUE;
         42               canEscalate = TRUE;
         43           when DebugMonitor
         44               termInst     = TRUE;
         45               // Only used by a BKPT or FPB event
         46               canPend      = (HaveMainExt() && CanPendMonitorOnEvent(isSecure, TRUE, TRUE,
         47                                                                      FindPriv(), TRUE));
         48               canEscalate = TRUE; // HardFault escalation for a BKPT
         49           otherwise
         50               termInst     = FALSE;
         51               canEscalate = FALSE;
         52
         53       // If the fault can escalate then check if exception can be taken immediately, or whether
         54       // it should escalate.
         55       // NOTE: In same cases (for example faults during lazy floating-point state preservation)
         56       //       the priority comparison below is ignored and the decision to escalate or not is
         57       //       based on other factors.
         58       escalateToHf = FALSE;
         59       if canEscalate then
         60           execPri = ExecutionPriority();
         61           excePri = ExceptionPriority(exception, isSecure, TRUE);
         62           if (excePri >= execPri) || !canPend then
         63               escalateToHf = TRUE;
         64
         65       return (escalateToHf, termInst);

E2.1.113 ExceptionEnabled
          1   // ExceptionEnabled()
          2   // ==================
          3
          4   boolean ExceptionEnabled(integer exception, boolean secure)
          5       assert 1 <= exception && exception < NUMEXN;
          6       if secure && !HaveSecurityExt() then
          7           enabled = FALSE;
          8       elsif exception < 16 then
          9           val = if secure then _SHCSR_S else _SHCSR_NS;
         10           case exception of
         11               when Reset
         12                   enabled = TRUE;
         13               when NMI
         14                   enabled = secure == (AIRCR_S.BFHFNMINS == '0');
         15               when HardFault
         16                   enabled = secure || AIRCR_S.BFHFNMINS == '1';
         17               when MemManage
         18                      enabled = val.MEMFAULTENA == '1';
         19                  when BusFault
         20                      enabled = ((_SHCSR_S.BUSFAULTENA == '1') &&
         21                                  (secure == (AIRCR_S.BFHFNMINS == '0')));
         22                  when UsageFault
         23                      enabled = val.USGFAULTENA == '1';
         24                  when SecureFault
         25                      enabled = secure && _SHCSR_S.SECUREFAULTENA == '1';
         26                  when SVCall
         27                      enabled = TRUE;
         28                  when DebugMonitor
         29                      enabled = ((secure == (DEMCR.SDME == '1')) &&
         30                                  !InstructionsInFlight());
         31                  when PendSV
         32                      enabled = !DebugCanMaskInts(secure);
         33                  when SysTick
         34                      enabled = ((!IsExceptionTargetConfigurable(SysTick) ||
         35                                  (secure == (_ICSR_S.STTNS == '0'))) &&
         36                                  !DebugCanMaskInts(secure));
         37                  otherwise
         38                      enabled = FALSE;
         39        else
         40               enabled = (IrqEnabled[exception-16] && !DebugCanMaskInts(secure) &&
         41                         ((NVIC_ITNS[exception-16] == '0') == secure));
         42
         43        return enabled;

E2.1.114 ExceptionEntry
          1   //   ExceptionEntry()
          2   //   ================
          3   //   Exception entry is modified according to the behavior of a derived
          4   //   exception, see DerivedLateArrival() also.
          5
          6   (ExcInfo, EXC_RETURN_Type) ExceptionEntry(integer exceptionType, boolean toSecure)
          7
          8        // PushStack() can abandon memory accesses if a fault occurs during the stacking
          9        // sequence.
         10        (exc, partialExcReturn) = PushStack();
         11        if exc.fault == NoFault then
         12            (exc, partialExcReturn) = ExceptionTaken(exceptionType, FALSE, toSecure,
         13                                                     IgnoreFaults_NONE, partialExcReturn);
         14        return (exc, partialExcReturn);

E2.1.115 ExceptionPriority
          1   // ExceptionPriority()
          2   // ===================
          3
          4   integer ExceptionPriority(integer n, boolean isSecure, boolean groupPri)
          5       if HaveMainExt() then
          6            assert 1 <= n && n < 512;
          7       else
          8            assert 1 <= n && n < 48;
          9
         10        if n == Reset then                             // Reset
         11            result = -4;
         12        elsif n == NMI then                            // NMI
         13            result = -2;
         14        elsif n == HardFault then                      // HardFault
         15            if isSecure && AIRCR.BFHFNMINS == '1' then
         16                result = -3;
         17            else
         18                result = -1;
         19        elsif HaveMainExt() && n == MemManage then     // MemManage
         20            result = UInt(if isSecure then SHPR1_S.PRI_4 else SHPR1_NS.PRI_4);
         21        elsif HaveMainExt() && n == BusFault then      // BusFault
         22            result = UInt(SHPR1_S.PRI_5);
         23       elsif HaveMainExt() && n == UsageFault then     // UsageFault
         24            result = UInt(if isSecure then SHPR1_S.PRI_6 else SHPR1_NS.PRI_6);
         25       elsif HaveMainExt() && n == SecureFault then    // SecureFault
         26            result = UInt(SHPR1_S.PRI_7);
         27       elsif n == SVCall then                          // SVCall
         28            result = UInt(if isSecure then SHPR2_S.PRI_11 else SHPR2_NS.PRI_11);
         29       elsif HaveMainExt() && n == DebugMonitor then // DebugMonitor
         30            result = UInt(SHPR3_S.PRI_12);
         31       elsif n == PendSV then                          // PendSV
         32            result = UInt(if isSecure then SHPR3_S.PRI_14 else SHPR3_NS.PRI_14);
         33       elsif n == SysTick                              // SysTick
         34              && ((HaveSysTick() == 2) ||
         35                  (HaveSysTick() == 1 && ((_ICSR_S.STTNS == '0') == isSecure))) then
         36            result = UInt(if isSecure then SHPR3_S.PRI_15 else SHPR3_NS.PRI_15);
         37       elsif n >= 16 then                              // External interrupt (n-16)
         38            r = (n - 16) DIV 4;
         39            v = n MOD 4;
         40            result = UInt(NVIC_IPR[r][v*8+7:v*8]);
         41       else                                            // Reserved exceptions
         42            result = 256;
         43
         44       assert result IN {-4 .. 256};
         45
         46       // Negative priorities (in other words Reset, NMI, and HardFault)
         47       // are not affected by PRIGROUP or PRIS
         48       if result >= 0 then
         49           // Include the PRIGROUP effect
         50           if HaveMainExt() && groupPri then
         51               integer subgroupshift;
         52               if isSecure then
         53                    subgroupshift = UInt(AIRCR_S.PRIGROUP);
         54               else
         55                    subgroupshift = UInt(AIRCR_NS.PRIGROUP);
         56               integer groupvalue     = 2 << subgroupshift;
         57               integer subgroupvalue = result MOD groupvalue;
         58               result                 = result - subgroupvalue;
         59
         60           PriSNsPri = RestrictedNSPri();
         61           if (AIRCR_S.PRIS == '1') && !isSecure then
         62               result = (result >> 1) + PriSNsPri;
         63
         64       assert result IN {-4 .. 256};
         65       return result;

E2.1.116 ExceptionReturn
          1   // ExceptionReturn()
          2   // =================
          3
          4   (ExcInfo, EXC_RETURN_Type, boolean) ExceptionReturn(EXC_RETURN_Type excReturn)
          5       integer returningExceptionNumber = UInt(IPSR.Exception);
          6
          7       (exc, excReturn) = ValidateExceptionReturn(excReturn, returningExceptionNumber);
          8       if exc.fault != NoFault then
          9           return (exc, excReturn, FALSE);
         10
         11       if HaveSecurityExt() then
         12            excSecure   = excReturn.ES == '1';
         13            retToSecure = excReturn.S == '1';
         14       else
         15            excSecure   = FALSE;
         16            retToSecure = FALSE;
         17
         18       // Restore SPSEL for the Security state we are returning from.
         19       if excSecure then
         20            CONTROL_S.SPSEL = excReturn.SPSEL;
         21       else
         22             CONTROL_NS.SPSEL = excReturn.SPSEL;
         23
         24       returningExcIsSecure = excReturn.ES == '1';
         25       DeActivate(returningExceptionNumber, returningExcIsSecure);
         26
         27       // If requested, clear the scratch FP values left in the caller saved
         28       // registers before returning/tail chaining.
         29       if HaveMveOrFPExt() && FPCCR.CLRONRET == '1' && CONTROL.FPCA == '1' then
         30           if FPCCR_S.LSPACT == '1' then
         31               SFSR.LSERR = '1';
         32               exc = CreateException(SecureFault);
         33               return (exc, excReturn, FALSE);
         34           else
         35               // Check if we have permission to clear the registers.
         36               if HasArchVersion(Armv8p1) then
         37                   exc = CheckCPEnabled(10, TRUE, returningExcIsSecure);
         38                   if exc.fault != NoFault then
         39                       return (exc, excReturn, FALSE);
         40
         41                 // Clear the FP / MVE registers
         42                 InvalidateFPRegs(TRUE, FALSE);
         43
         44       //   If TailChaining is supported, check if there is a pending exception with
         45       //   sufficient priority to be taken now. This check is done after the
         46       //   previous exception is deactivated so the priority of the previous
         47       //   exception does not mask any pending exceptions.
         48       //   The position of TailChain() within this function is the earliest point
         49       //   at which an tailchain is architecturally visible. Tail-chaining from a
         50       //   later point is permissible.
         51       if   boolean IMPLEMENTATION_DEFINED "Tail chaining supported" then
         52             (takeException, exception, excIsSecure) = PendingExceptionDetails();
         53             if takeException then
         54                 (exc, excReturn) = TailChain(exception, excIsSecure, excReturn);
         55                 return (exc, excReturn, TRUE);
         56
         57       // Return to the background Security state
         58       if HaveSecurityExt() then
         59           CurrentState = if retToSecure
         60                          then SecurityState_Secure else SecurityState_NonSecure;
         61
         62       //   Sleep-on-exit performs equivalent behavior to the WFI instruction.
         63       //   The position of SleepOnExit() within this function is the earliest point
         64       //   at which it can be performed. Performing SleepOnExit from a later point
         65       //   is permissible.
         66       if   (excReturn.Mode == '1' && SCR.SLEEPONEXIT == '1' &&
         67             ExceptionActiveBitCount() == 0) then
         68             SleepOnExit();                           // IMPLEMENTATION DEFINED
         69
         70       // Pop the stack and raise any exceptions that are generated
         71       exc = PopStack(excReturn);
         72       if exc.fault == NoFault then
         73           ClearExclusiveLocal(ProcessorID());
         74           ClearInFlightInstructions();
         75           SetEventRegister();                          // See WFE instruction for more details
         76           InstructionSynchronizationBarrier('1111');
         77
         78       return (exc, excReturn, FALSE);

E2.1.117 ExceptionTaken
          1   // ExceptionTaken()
          2   // ================
          3
          4   (ExcInfo, EXC_RETURN_Type) ExceptionTaken(integer exceptionNumber, boolean doTailChain,
          5                          boolean excIsSecure, IgnoreFaultsType ignoreFaults,
          6                          EXC_RETURN_Type excReturn)
          7       assert(HaveSecurityExt() || !excIsSecure);
          8
          9       // If the background code was running in the Secure state there are some
         10       // additional steps that might need to be taken to protect the callee saved
         11       // registers
         12       exc = DefaultExcInfo();
         13       if HaveSecurityExt() && excReturn.S == '1' then
         14           if excIsSecure then          // Transitioning to Secure state
         15               // If tail chaining is from Non-secure to Secure, then the callee registers
         16               // are already on stack. Set excReturn.DCRS accordingly
         17               if doTailChain && excReturn.ES == '0' then
         18                    excReturn.DCRS = '0';
         19           else                         // Transitioning to Non-secure state
         20               // If the callee registers are not already on the stack push them now
         21               if excReturn.DCRS == '1' && !(doTailChain && excReturn.ES == '0') then
         22                    exc = PushCalleeStack(doTailChain, excReturn);
         23               // Going to Non-secure exception. Set excReturn.DCRS to default
         24               // value
         25               excReturn.DCRS = '1';
         26
         27       // Finalise excReturn value
         28       if excIsSecure then
         29            excReturn.SPSEL = CONTROL_S.SPSEL;
         30            excReturn.ES = '1';
         31       else
         32            excReturn.SPSEL = CONTROL_NS.SPSEL;
         33            excReturn.ES = '0';
         34       LR = excReturn;
         35
         36       // Register clearing
         37       // Caller saved registers: These registers are cleared if exception targets
         38       // the Non-secure state, otherwise they are UNKNOWN. As of Armv8.1 the
         39       // registers are always cleared if the Security extension is implemented.
         40       // NOTE: The original values were pushed to the stack.
         41       if HaveSecurityExt() && (!excIsSecure || HasArchVersion(Armv8p1)) then
         42            callerRegValue = Zeros(32);
         43       else
         44            callerRegValue = bits(32) UNKNOWN;
         45       for n = 0 to 3
         46            R[n] = callerRegValue;
         47       R[12] = callerRegValue;
         48       EAPSR = callerRegValue;
         49       // Callee saved registers: If the background code was in the Secure state
         50       // these registers are cleared if the exception targets the Non-secure state,
         51       // and UNKNOWN if it targets the Secure state and the registers have been
         52       // pushed to the stack (as indicated by EXC_RETURN.DCRS).
         53       //
         54       // NOTE: Callee saved registers are preserved if the background code is
         55       //        Non-secure, or when the exception is Secure and the values have not
         56       //        been pushed to the stack.
         57       if HaveSecurityExt() && excReturn.S == '1' then
         58            if excIsSecure then
         59                if excReturn.DCRS == '0' then
         60                    for n = 4 to 11
         61                        R[n] = bits(32) UNKNOWN;
         62            else
         63                for n = 4 to 11
         64                    R[n] = Zeros();
         65
         66       //   If enabled, the IESB contains asynchronous RAS / BusFault errors to the background
         67       //   context. This is conditional on there being no stacking faults -- if there are, the
         68       //   errors will be synchronized when the subsequent exception is raised.
         69       if   AIRCR.IESB == '1' then
         70             exc = MergeExcInfo(exc, SynchronizeBusFault());
         71
         72       // If no errors so far (or errors that can be ignored) load the vector address
         73       if exc.fault == NoFault || ignoreFaults != IgnoreFaults_NONE then
         74           (exc, start) = Vector[exceptionNumber, excIsSecure];
         75
         76       // The state or mode of processor is not updated if an exception is raised
         77       // during the entry sequence.
         78       if exc.fault == NoFault || ignoreFaults == IgnoreFaults_ALL then
         79           ActivateException(exceptionNumber, excIsSecure);
         80           SCS_UpdateStatusRegs();
         81           ClearExclusiveLocal(ProcessorID());
         82           ClearInFlightInstructions();
         83           SetEventRegister();                            // See WFE instruction for details
         84           InstructionSynchronizationBarrier('1111');
         85           // Start execution of handler
         86           EPSR.T = start[0];
         87           // If EPSR.T == 0 then an exception is taken on the next
         88           // instruction: UsageFault('Invalid State') if the Main Extension is
         89           // implemented; HardFault otherwise
         90           BranchTo(start[31:1]:'0', TRUE, FALSE);
         91
         92       if exc.fault != NoFault then
         93           exc.inExcTaken = TRUE;
         94
         95       return (exc, excReturn);

E2.1.118 ExceptionTargetsSecure
          1   // ExceptionTargetsSecure()
          2   // ========================
          3
          4   // Determine the default Security state an exception is expected to target if the
          5   // exception is not forced to a specific domain.
          6
          7   boolean ExceptionTargetsSecure(integer exceptionNumber, boolean isSecure)
          8       if !HaveSecurityExt() then
          9           return FALSE;
         10
         11       boolean targetSecure = FALSE;
         12       case exceptionNumber of
         13           when NMI
         14               targetSecure = AIRCR.BFHFNMINS == '0';
         15
         16           when HardFault
         17               targetSecure = AIRCR.BFHFNMINS == '0' || isSecure;
         18
         19           when MemManage
         20               targetSecure = isSecure;
         21
         22           when BusFault
         23               targetSecure = AIRCR.BFHFNMINS == '0';
         24
         25           when UsageFault
         26               targetSecure = isSecure;
         27
         28           when SecureFault
         29               // SecureFault always targets Secure state.
         30               targetSecure = TRUE;
         31
         32           when SVCall
         33               targetSecure = isSecure;
         34
         35           when DebugMonitor
         36               targetSecure = DEMCR.SDME == '1';
         37
         38           when PendSV
         39               // This state should be unreachable as PendSV is a banked interrupt
         40               // and it is directly pended for the correct security state, so this
         41               // function is not called for this exception.
         42               assert FALSE;
         43
         44           when SysTick
         45               if HaveSysTick() != 1 then
         46                   // If there is a SysTick for each domain, then the exception
         47                   // targets the domain associated with the SysTick instance that
         48                        // raised the exception.
         49                        // This state should be unreachable as SysTick exception is banked
         50                        // and it is directly pended for the correct security state. This
         51                        // function can only be called when 1 SysTick is implemented.
         52                        assert FALSE;
         53                 else
         54                        // SysTick target state is configurable
         55                        targetSecure = ICSR_S.STTNS == '0';
         56
         57             otherwise
         58                 if exceptionNumber >= 16 then
         59                     // Interrupts target the state defined by the NVIC_ITNS register
         60                     targetSecure = NVIC_ITNS[exceptionNumber - 16] == '0';
         61
         62       return targetSecure;

E2.1.119 ExcInfo
          1   // Exception information
          2
          3   type ExcInfo is (
          4       integer fault,                      //   The ID of the resulting fault, or NoFault (or 0)
          5                                           //   if no fault occurred
          6       integer origFault,                  //   The ID if the original fault raised before
          7                                           //   escalation is considered.
          8       boolean isSecure,                   //   TRUE if the fault targets the Secure state.
          9       boolean origFaultIsSecure,          //   TRUE if the original fault raised targeted
         10                                           //   Secure state
         11       boolean isTerminal,                 //   Set to TRUE for derived faults (for example an
         12                                           //   exception on exception entry) that prevent the
         13                                           //   original exception being entered (for example a
         14                                           //   BusFault whilst fetching the exception vector address).
         15       boolean inExcTaken,                 //   TRUE if the exception occurred during ExceptionTaken()
         16                                           //   This is used to determine if the LR update and the
         17                                           //   callee stacking operations have been performed, and 18                                           //   therefore whether the derived exception should be
         19                                           //   treated as a tail chain.
         20       boolean lockup,                     //   Set to TRUE if the exception should cause a lockup.
         21       boolean termInst                    //   Set to TRUE if the exception should cause the
         22                                           //   instruction to be terminated.
         23   )

E2.1.120 ExclusiveMonitorsPass
          1   // ExclusiveMonitorsPass()
          2   // =======================
          3
          4   boolean ExclusiveMonitorsPass(bits(32) address, integer size)
          5
          6       //   It is IMPLEMENTATION DEFINED whether the detection of memory aborts happens
          7       //   before or after the check on the local Exclusive Monitor. As a result a failure
          8       //   of the local monitor can occur on some implementations even if the memory
          9       //   access would give a memory abort.
         10
         11       if address != Align(address, size) then
         12            UFSR.UNALIGNED = '1';
         13            excInfo = CreateException(UsageFault);
         14       else
         15            (excInfo, memaddrdesc) = ValidateAddress(address, AccType_NORMAL,
         16                                                     FindPriv(), IsSecure(), TRUE, TRUE);
         17       HandleException(excInfo);
         18
         19       passed = IsExclusiveLocal(memaddrdesc.paddress, ProcessorID(), size);
         20       if memaddrdesc.memattrs.shareable then
         21           passed = passed && IsExclusiveGlobal(memaddrdesc.paddress, ProcessorID(), size);
         22       if passed then
         23           ClearExclusiveLocal(ProcessorID());
         24       return passed;

E2.1.121 ExecBeats
          1   // ExecBeats()
          2   // ===========
          3
          4   boolean ExecBeats()
          5       // PEs are not constrained to following the beat execution pattern shown in
          6       // this function. Any pattern is permitted providing it meets the following
          7       // requirements:
          8       //     1) The new pattern of completed beats in representable as a valid ECI
          9       //        value.
         10       //     2) The beat execution rules are not violated (see specification).
         11       //     3) All ECI encodings are accepted an inputs, even if the PE cannot
         12       //        generate that ECI value.
         13       newBeatComplete = BeatComplete;
         14       for instId = 0 to MAX_OVERLAPPING_INSTRS-1
         15           if _InstInfo[instId].Valid then
         16               _InstID                 = instId;
         17               _CurrentInstrExecState = GetInstrExecState(instId);
         18               InstStateCheck(ThisInstr());
         19               // Find the first ticks worth of beats that is not complete
         20               beatBits   = Elem[newBeatComplete, instId, MAX_BEATS];
         21               baseBeatId = 0;
         22               while Elem[beatBits, baseBeatId, BEATS_PER_TICK] == Ones(BEATS_PER_TICK) do
         23                   baseBeatId = baseBeatId + BEATS_PER_TICK;
         24
         25                // Perform all the beats in this tick for the current instruction
         26                for beatInTick = 0 to BEATS_PER_TICK-1
         27                    beatId = baseBeatId + beatInTick;
         28                    // Only perform the beat if it has not already been completed
         29                    beatFlagIdx = (instId * MAX_BEATS) + beatId;
         30                    if newBeatComplete[beatFlagIdx] == '0' then
         31                        _BeatID           = beatId;
         32                        _AdvanceVPTState = TRUE;
         33                        cond              = DefaultCond();
         34                        DecodeExecute(ThisInstr(), ThisInstrAddr(),
         35                                       ThisInstrLength() == 2, cond);
         36                        newBeatComplete[beatFlagIdx] = '1';
         37                        // Advance the VPT state for the current beat if the instruction
         38                        // did not update the mask directly.
         39                        if _AdvanceVPTState then
         40                             VPTAdvance(beatId);
         41
         42       // If the older instruction is now complete advance the state and beat
         43       // complete flags
         44       commitState = newBeatComplete[MAX_BEATS-1:0] == Ones(MAX_BEATS);
         45       if commitState then
         46           newBeatComplete = LSR(newBeatComplete, MAX_BEATS);
         47
         48       // Update the beat complete flags. This is done after all the beats in the
         49       // tick have been executed, as such it is not advanced if an exception
         50       // terminates execution of the current tick
         51       BeatComplete = newBeatComplete;
         52
         53       return commitState;

E2.1.122 ExecuteCPCheck
          1   // ExecuteCPCheck()
          2   // ================
          3
          4   ExecuteCPCheck(integer cp)
          5       // Check access to coprocessor is enabled
          6       excInfo = CheckCPEnabled(cp);
          7       HandleException(excInfo);

E2.1.123 ExecuteCPCheckCDE
          1   // ExecuteCPCheckCDE()
          2   // ===================
          3   // Check whether the coprocessors and features required by CDE are implemented and enabled.
          4
          5   ExecuteCPCheckCDE(integer cp, boolean isMve)
          6       // Check whether access to the CDE coprocessor is enabled
          7       excInfo = CheckCPEnabled(cp);
          8       HandleException(excInfo);
          9
         10       if excInfo.fault == NoFault then
         11           // Check whether access to CP10 is enabled
         12           exc = CheckCPEnabled(10);
         13           HandleException(exc);
         14
         15              if exc.fault == NoFault then
         16                  if isMve then
         17                       // MVE extension is required
         18                       if MVFR1.MVE == '0000' then UNDEFINED;
         19                  else
         20                       // Either MVE or the Floating-point extension are required
         21                       if MVFR1.MVE == '0000' && MVFR0.FPSP == '0000' then UNDEFINED;
         22              else
         23                  UNDEFINED;
         24       else
         25              UNDEFINED;

E2.1.124 ExecuteFPCheck
          1   // ExecuteFPCheck()
          2   // ================
          3
          4   ExecuteFPCheck()
          5       // Preserve any lazy FP state
          6       PreserveFPState();
          7
          8       // Update the ownership of the FP context
          9       FPCCR_S.S = if IsSecure() then '1' else '0';
         10
         11       // Update CONTROL.FPCA, and create new FP context
         12       // if this has been enabled by setting FPCCR.ASPEN to 1
         13       if FPCCR.ASPEN == '1' &&
         14          (CONTROL.FPCA == '0' || (IsSecure() && CONTROL_S.SFPA == '0')) then
         15           CONTROL.FPCA = '1';
         16           if IsSecure() then
         17               CONTROL_S.SFPA = '1';
         18           FPSCR = FPDSCR[31:0];
         19           VPR   = Zeros();
         20       return;

E2.1.125 ExecutionPriority
          1   // ExecutionPriority()
          2   // ===================
          3   // Determine the current execution priority
          4
          5   integer ExecutionPriority()
          6
          7       boostedpri = HighestPri();                 // Priority influence of BASEPRI, PRIMASK and FAULTMASK
          8
          9       // Calculate boosted priority effect due to BASEPRI for both Security states
         10       PriSNsPri = RestrictedNSPri();
         11       if HaveMainExt() then
         12           if UInt(BASEPRI_NS[7:0]) != 0 then
         13               basepri = UInt(BASEPRI_NS[7:0]);
         14                 // Include the PRIGROUP effect
         15                 subgroupshift = UInt(AIRCR_NS.PRIGROUP);
         16                 groupvalue    = 2 << subgroupshift;
         17                 subgroupvalue = basepri MOD groupvalue;
         18                 boostedpri    = basepri - subgroupvalue;
         19                 if AIRCR_S.PRIS == '1' then
         20                     boostedpri = (boostedpri >> 1) + PriSNsPri;
         21
         22           if UInt(BASEPRI_S[7:0]) != 0 then
         23               basepri = UInt(BASEPRI_S[7:0]);
         24               // Include the PRIGROUP effect
         25               subgroupshift = UInt(AIRCR_S.PRIGROUP);
         26               groupvalue    = 2 << subgroupshift;
         27               subgroupvalue = basepri MOD groupvalue;
         28               basepri       = basepri - subgroupvalue;
         29               if boostedpri > basepri then
         30                   boostedpri = basepri;
         31
         32       // Calculate boosted priority effect due to PRIMASK for both Security states
         33       if PRIMASK_NS.PM == '1' then
         34           if AIRCR_S.PRIS == '0' then
         35               boostedpri = 0;
         36           else
         37               if boostedpri > PriSNsPri then
         38                   boostedpri = PriSNsPri;
         39
         40       if PRIMASK_S.PM == '1' then
         41           boostedpri = 0;
         42
         43       // Calculate boosted priority effect due to FAULTMASK for both Security states
         44       if HaveMainExt() then
         45           if FAULTMASK_NS.FM == '1' then
         46               if AIRCR.BFHFNMINS == '0' then
         47                    if AIRCR_S.PRIS == '0' then
         48                        boostedpri = 0;
         49                    else
         50                        if boostedpri > PriSNsPri then
         51                            boostedpri = PriSNsPri;
         52               else
         53                    boostedpri = -1;
         54
         55           if FAULTMASK_S.FM == '1' then
         56               boostedpri = if AIRCR.BFHFNMINS == '0' then -1 else -3;
         57
         58       // Finally calculate the resultant priority after boosting
         59       rawExecPri = RawExecutionPriority();
         60       if boostedpri < rawExecPri then
         61            priority = boostedpri;
         62       else
         63            priority = rawExecPri;
         64
         65       assert priority IN {-4 .. 256};
         66       return priority;

E2.1.126 Extend
          1   // Extend()
          2   // ========
          3
          4   bits(N) Extend(bits(M) x, integer N, boolean unsigned)
          5       return if unsigned then ZeroExtend(x, N) else SignExtend(x, N);
          6
          7   bits(N) Extend(bits(M) x, boolean unsigned)
          8       return Extend(x, N, unsigned);

E2.1.127 ExternalInvasiveDebugEnabled
          1   //   ExternalInvasiveDebugEnabled()
          2   //   ==============================
          3   //   Return TRUE if Halting debug is enabled by the
          4   //   IMPLEMENTATION DEFINED authentication interface.
          5
          6   boolean ExternalInvasiveDebugEnabled()
          7       // In the recommended interface, ExternalInvasiveDebugEnabled returns the state of
          8       // the DBGEN signal.
          9       return DBGEN == HIGH;

E2.1.128 ExternalNoninvasiveDebugEnabled
          1   //   ExternalNoninvasiveDebugEnabled()
          2   //   =================================
          3   //   Return TRUE if non-invasive debug is enabled by the IMPLEMENTATION DEFINED authentication
          4   //   interface.
          5
          6   boolean ExternalNoninvasiveDebugEnabled()
          7       // In the recommended interface, ExternalNoninvasiveDebugEnabled returns the state of
          8       // the (DBGEN OR NIDEN) signal.
          9       return ExternalInvasiveDebugEnabled() || NIDEN == HIGH;

E2.1.129 ExternalSecureInvasiveDebugEnabled
          1   //   ExternalSecureInvasiveDebugEnabled()
          2   //   ====================================
          3   //   Return TRUE if Secure Halting debug is enabled by the IMPLEMENTATION DEFINED
          4   //   authentication interface.
          5
          6   boolean ExternalSecureInvasiveDebugEnabled()
          7       // In the recommended interface, ExternalSecureInvasiveDebugEnabled returns the state
          8       // of the (DBGEN AND SPIDEN) signal.
          9       return ExternalInvasiveDebugEnabled() && SPIDEN == HIGH;

E2.1.130 ExternalSecureNoninvasiveDebugEnabled
          1   //   ExternalSecureNoninvasiveDebugEnabled()
          2   //   =======================================
          3   //   Return TRUE if Secure non-invasive debug is enabled by the IMPLEMENTATION DEFINED
          4   //   authentication interface.
          5
          6   boolean ExternalSecureNoninvasiveDebugEnabled()
          7       // In the recommended interface, ExternalSecureNoninvasiveDebugEnabled returns the
          8       // state of the (DBGEN OR NIDEN) AND (SPIDEN OR SPNIDEN) signal.
          9       return ExternalNoninvasiveDebugEnabled() && (SPIDEN == HIGH || SPNIDEN == HIGH);

E2.1.131 ExternalSecureSelfHostedDebugEnabled
          1   //   ExternalSecureSelfHostedDebugEnabled()
          2   //   ======================================
          3   //   Return TRUE if Secure self-hosted debug is enabled by the IMPLEMENTATION DEFINED
          4   //   authentication interface.
          5
          6   boolean ExternalSecureSelfHostedDebugEnabled()
          7       // In the recommended interface, ExternalSecureSelfHostedDebugEnabled returns the state
          8       // of the (DBGEN AND SPIDEN) signal.
          9       return DBGEN == HIGH && SPIDEN == HIGH;

E2.1.132 ExtType
          1   // Types of ISA extension
          2
          3   enumeration ExtType {ExtType_Mve,
          4                            ExtType_MveFp,
          5                            ExtType_MveOrFp,
          6                            ExtType_MveOrDpFp,
          7                            ExtType_Unknown,
          8                            ExtType_HpFp,
          9                            ExtType_SpFp,
         10                            ExtType_DpFp};

E2.1.133 FaultNumbers
          1   // Fault Numbers
          2   // =============
          3
          4   // The fault numbers are a subset of ExceptionNumber and can be one of the
          5   // following values:
          6   constant integer NoFault      = 0;
          7   constant integer Reset        = 1;
          8   constant integer NMI          = 2;
          9   constant integer HardFault    = 3;
         10   constant integer MemManage    = 4;
         11   constant integer BusFault     = 5;
         12   constant integer UsageFault   = 6;
         13   constant integer SecureFault = 7;
         14   constant integer SVCall       = 11;
         15   constant integer DebugMonitor = 12;
         16   constant integer PendSV       = 14;
         17   constant integer SysTick      = 15;

E2.1.134 FetchInstr
          1   // FetchInstr()
          2   // ============
          3
          4   (bits(32), boolean) FetchInstr(bits(32) addr)
          5       // NOTE: It is CONSTRAINED UNPREDICTABLE whether otherwise valid sequential
          6       //       instruction fetches that cross from Non-secure to Secure memory
          7       //       generate a INVEP SecureFault, or transition normally.
          8       sgOpcode = 0xE97FE97F[31:0];
          9
         10       hw1Attr = SecurityCheck(addr, TRUE, IsSecure());
         11       // Fetch the 16-bit T32 instruction, or the first half of a T32.
         12       hw1Instr = MemI[addr];
         13
         14       isT16 = UInt(hw1Instr[15:11]) < UInt('11101');
         15       len   = if isT16 then 2 else 4;
         16
         17       // Checking for FPB Breakpoint on instructions
         18       if HaveFPB() && FPB_CheckBreakPoint(addr, len, TRUE, IsSecure()) then
         19           GenerateDebugEventResponse(TRUE);
         20
         21       // If the T bit is clear then the instruction cannot be decoded
         22       if EPSR.T == '0' then
         23           // Attempted NS->S domain crossings with the T bit clear raise an INVEP
         24           // SecureFault
         25           if !IsSecure() && !hw1Attr.ns then
         26               SFSR.INVEP = '1';
         27               excInfo = CreateException(SecureFault);
         28           else
         29               UFSR.INVSTATE = '1';
         30               excInfo = CreateException(UsageFault);
         31           HandleException(excInfo);
         32
         33       //   Implementations are permitted to terminate the fetch process early if a
         34       //   domain crossing is being attempted and the first 16bits of the opcode
         35       //   is not the first part of the SG instruction.
         36       if   boolean IMPLEMENTATION_DEFINED "Early SG check" then
         37             if !IsSecure() && !hw1Attr.ns && (hw1Instr != sgOpcode[31:16]) then
         38                SFSR.INVEP = '1';
         39                excInfo = CreateException(SecureFault);
         40                HandleException(excInfo);
         41
         42       // NOTE: Implementations are also permitted to terminate the fetch process
         43       //       at this point with an UNDEFINSTR UsageFault if the first 16bit is
         44       //       an undefined T32 prefix.
         45
         46       // If the data fetched is the top half of a T32 instruction fetch the bottom
         47       // 16 bits
         48       if isT16 then
         49            instr = Zeros(16) : hw1Instr;
         50       else
         51            hw2Attr = SecurityCheck(addr+2, TRUE, IsSecure());
         52            // The following test covers 2 possible fault conditions:- 53            // 1) NS code branching to a T32 instruction where the first half is in
         54            //     NS memory, and the second half is in S memory.
         55            // 2) NS code branching to a T32 instruction in S & NSC memory, but
         56            //     where the second half of the instruction is in NS memory.
         57            if !IsSecure() && (hw1Attr.ns != hw2Attr.ns) then
         58                SFSR.INVEP = '1';
         59                excInfo = CreateException(SecureFault);
         60                HandleException(excInfo);
         61
         62           // Fetch the second half of T32 instruction
         63           instr   = hw1Instr : MemI[addr+2];
         64
         65       // Raise a fault if an otherwise valid NS->S transition that does not land on
         66       // an SG instruction.
         67       if !IsSecure() && !hw1Attr.ns && (instr != sgOpcode) then
         68           SFSR.INVEP = '1';
         69           excInfo = CreateException(SecureFault);
         70           HandleException(excInfo);
         71
         72       if EPSR.B == '1' then
         73           // BTI clearing instruction masks.
         74           // When BTI is set, these instructions do not cause an INVSTATE                     UsageFault.
         75           btiClearing = instr    IN {sgOpcode,                                                // SG
         76                                      '111100111010xxxx10x0x00000001111',                      // BTI
         77                                      '111100111010xxxx10x0x00000001101'};                     // PACBTI
         78           bkptIgnore = hw1Instr == '10111110xxxxxxxx';                                        // BKPT
         79           // A BKPT instruction ignores the EPSR.B bit.
         80           if !btiClearing && !bkptIgnore then
         81               // Generate a fault due to a BTI error.
         82               UFSR.INVSTATE = '1';
         83               excInfo = CreateException(UsageFault);
         84               HandleException(excInfo);
         85
         86       return (instr, isT16);

E2.1.135 FindMemPriv
          1   // FindMemPriv()
          2   // =============
          3
          4   Privilege FindMemPriv()
          5       return FindMemPriv(FindPriv());
          6
          7   Privilege FindMemPriv(boolean privileged)
          8       return if privileged then Privilege_Priv else Privilege_Unpriv;

E2.1.136 FindPriv
          1   // FindPriv()
          2   // ==========
          3
          4   boolean FindPriv()
          5       return CurrentModeIsPrivileged();

E2.1.137 FixedToFP
          1   // FixedToFP()
          2   // ===========
          3
          4   bits(N) FixedToFP(bits(M) operand, integer N, integer fraction_bits, boolean unsigned,
          5                     boolean round_to_nearest, boolean fpscr_controlled)
          6       return FixedToFP(operand, N, fraction_bits, unsigned, round_to_nearest,
          7                        fpscr_controlled, FALSE);
          8
          9   bits(N) FixedToFP(bits(M) operand, integer N, integer fraction_bits, boolean unsigned,
         10                      boolean round_to_nearest, boolean fpscr_controlled, boolean predicated)
         11       assert N IN {16,32,64};
         12       fpscr_val = if fpscr_controlled then FPSCR else StandardFPSCRValue();
         13       if round_to_nearest then fpscr_val.RMode = FPSCR_RMode_RN;
         14       int_operand = if unsigned then UInt(operand) else SInt(operand);
         15       real_operand = Real(int_operand) / 2.0^fraction_bits;
         16       if real_operand == 0.0 then
         17            result = FPZero('0', N);
         18       else
         19            result = FPRound(real_operand, N, fpscr_val, predicated);
         20       return result;

E2.1.138 FPAbs
          1   // FPAbs()
          2   // =======
          3
          4   bits(N) FPAbs(bits(N) operand)
          5       assert N IN {16,32,64};
          6       return '0' : operand[N-2:0];

E2.1.139 FPAdd
          1   // FPAdd()
          2   // =======
          3
          4   bits(N) FPAdd(bits(N) op1, bits(N) op2, boolean fpscr_controlled)
          5       return FPAdd(op1, op2, fpscr_controlled, FALSE);
          6
          7   bits(N) FPAdd(bits(N) op1, bits(N) op2, boolean fpscr_controlled, boolean predicated)
          8       assert N IN {16,32,64};
          9       fpscr_val = if fpscr_controlled then FPSCR else StandardFPSCRValue();
         10       (type1,sign1,value1) = FPUnpack(op1, fpscr_val, predicated);
         11       (type2,sign2,value2) = FPUnpack(op2, fpscr_val, predicated);
         12       (done,result) = FPProcessNaNs(type1, type2, op1, op2, fpscr_val, predicated);
         13       if !done then
         14           inf1 = (type1 == FPType_Infinity); inf2 = (type2 == FPType_Infinity);
         15           zero1 = (type1 == FPType_Zero);     zero2 = (type2 == FPType_Zero);
         16           if inf1 && inf2 && sign1 == NOT(sign2) then
         17               result = FPDefaultNaN(N);
         18               FPProcessException(FPExc_InvalidOp, fpscr_val, predicated);
         19           elsif (inf1 && sign1 == '0') || (inf2 && sign2 == '0') then
         20               result = FPInfinity('0', N);
         21           elsif (inf1 && sign1 == '1') || (inf2 && sign2 == '1') then
         22               result = FPInfinity('1', N);
         23           elsif zero1 && zero2 && sign1 == sign2 then
         24               result = FPZero(sign1, N);
         25           else
         26               result_value = value1 + value2;
         27               if result_value == 0.0 then // Sign of exact zero result depends
         28                                            // on rounding mode
         29                   result_sign = if fpscr_val.RMode == FPSCR_RMode_RM then '1' else '0';
         30                       result = FPZero(result_sign, N);
         31                else
         32                   result = FPRound(result_value, N, fpscr_val, predicated);
         33       return result;

E2.1.140 FPB_CheckBreakPoint
          1   // FPB_CheckBreakPoint
          2   // ===================
          3   // Check for Flash Patch Break point
          4
          5   boolean FPB_CheckBreakPoint(bits(32) iaddr, integer size,
          6                               boolean is_ifetch, boolean is_secure)
          7
          8       match = FPB_CheckMatchAddress(iaddr);
          9       if !match && size == 4 && FPB_CheckMatchAddress(iaddr + 2) then
         10           match = ConstrainUnpredictableBool(Unpredictable_FPBreakpoint);
         11       return match;

E2.1.141 FPB_CheckMatchAddress
          1   // FPB_CheckMatchAddress
          2   // =====================
          3   // Flash Patch breakpoint instruction address comparison
          4
          5   boolean FPB_CheckMatchAddress(bits(32) iaddr)
          6
          7       if FP_CTRL.ENABLE == '0' then return FALSE; // FPB not enabled
          8
          9       // Instruction Comparator.
         10       num_addr_cmp = UInt(FP_CTRL.NUM_CODE);
         11       if num_addr_cmp == 0 then return FALSE;                 // No comparator support
         12
         13       for N = 0 to (num_addr_cmp - 1)
         14           if FP_COMP[N].BE == '1' then            // Breakpoint enabled
         15               if iaddr[31:1] == FP_COMP[N].BPADDR then
         16                   return TRUE;
         17
         18       return FALSE;

E2.1.142 FPCompare
          1   // FPCompare()
          2   // ===========
          3
          4   (bit, bit, bit, bit) FPCompare(bits(N) op1, bits(N) op2, boolean quiet_nan_exc,
          5                                  boolean fpscr_controlled)
          6       return FPCompare(op1, op2, quiet_nan_exc, fpscr_controlled, FALSE);
          7
          8   (bit, bit, bit, bit) FPCompare(bits(N) op1, bits(N) op2, boolean quiet_nan_exc,
          9                                   boolean fpscr_controlled, boolean predicated)
         10       assert N IN {16,32,64};
         11       fpscr_val = if fpscr_controlled then FPSCR else StandardFPSCRValue();
         12       (type1,-,value1) = FPUnpack(op1, fpscr_val, predicated);
         13       (type2,-,value2) = FPUnpack(op2, fpscr_val, predicated);
         14       if type1 == FPType_SNaN || type1 == FPType_QNaN ||
         15          type2 == FPType_SNaN || type2 == FPType_QNaN then
         16            result = ('0','0','1','1');
         17            if type1==FPType_SNaN || type2==FPType_SNaN || quiet_nan_exc then
         18                FPProcessException(FPExc_InvalidOp, fpscr_val, predicated);
         19       else
         20            // All non-NaN cases can be evaluated on the values produced by FPUnpack()
         21            if value1 == value2 then
         22                result = ('0','1','1','0');
         23            elsif value1 < value2 then
         24                result = ('1','0','0','0');
         25            else // value1 > value2
         26                result = ('0','0','1','0');
         27        return result;

E2.1.143 FPConvertNaN
          1   //   FPConvertNaN()
          2   //   ==============
          3   //
          4   //   For half-precision data it ignores AHP, and observes FZ16.
          5   //   Calls FPConvertNaNBase() which demotes any input SNaN to a QNaN.
          6
          7   bits(N) FPConvertNaN(bits(N) fpval, boolean fpscr_controlled)
          8       fpscr_val = if fpscr_controlled then FPSCR else StandardFPSCRValue();
          9       fpscr_val.AHP = '0';
         10       return FPConvertNaNBase(fpval, fpscr_val);

E2.1.144 FPConvertNaNBase
          1   //   FPConvertNaNBase()
          2   //   ==============
          3   //
          4   //   Demotes any input SNaN to a QNaN and ensures that any comparison between a number and 5   //   a NaN, always returns the number and not the NaN.
          6
          7   bits(N) FPConvertNaNBase(bits(N) fpval, FPSCR_Type fpscr_val)
          8       assert N IN {16,32,64};
          9
         10        if N == 16 then
         11            exp16 = fpval[14:10];
         12            frac16 = fpval[9:0];
         13            if IsOnes(exp16) && fpscr_val.AHP == '0' then // Infinity or NaN in IEEE format
         14                if !IsZero(frac16) then                   // NaN in IEEE format
         15                    if frac16[9] == '0' then              // if the value is an SNaN
         16                        fpval[9] = '1';                   // Convert the value to a QNaN
         17                        FPProcessException(FPExc_InvalidOp, fpscr_val);
         18
         19        elsif N == 32 then
         20            exp32 = fpval[30:23];
         21            frac32 = fpval[22:0];
         22            if IsOnes(exp32) && !IsZero(frac32) then      // NaN in IEEE format
         23                if frac32[22] == '0' then                 // if the value is an SNaN
         24                    fpval[22] = '1';                      // Convert the value to a QNaN
         25                    FPProcessException(FPExc_InvalidOp, fpscr_val);
         26
         27        else // N == 64
         28            exp64 = fpval[62:52];
         29            frac64 = fpval[51:0];
         30            if IsOnes(exp64) && !IsZero(frac64) then      // NaN in IEEE format
         31                if frac64[51] == '0' then                 // if the value is an SNaN
         32                    fpval[51] = '1';                      // Convert the value to a QNaN
         33                    FPProcessException(FPExc_InvalidOp, fpscr_val);
         34
         35        return fpval;

E2.1.145 FPDefaultNaN
          1   // FPDefaultNaN()
          2   // ==============
          3
          4   bits(N) FPDefaultNaN(integer N)
          5       assert N IN {16,32,64};
          6       integer E = if N == 16 then 5 elsif N == 32 then 8 else 11;
          7       constant integer F = N - E - 1;
          8       bits(E) exp;
          9       bits(F) frac;
         10       sign = '0';
         11       exp = Ones(E);
         12       frac = '1':Zeros(F-1);
         13       return sign : exp : frac;

E2.1.146 FPDiv
          1   // FPDiv()
          2   // =======
          3
          4   bits(N) FPDiv(bits(N) op1, bits(N) op2, boolean fpscr_controlled)
          5       assert N IN {16,32,64};
          6       fpscr_val = if fpscr_controlled then FPSCR else StandardFPSCRValue();
          7       (fp_type1,sign1,value1) = FPUnpack(op1, fpscr_val);
          8       (fp_type2,sign2,value2) = FPUnpack(op2, fpscr_val);
          9       (done,result) = FPProcessNaNs(fp_type1, fp_type2, op1, op2, fpscr_val);
         10       if !done then
         11           inf1 = (fp_type1 == FPType_Infinity); inf2 = (fp_type2 == FPType_Infinity);
         12           zero1 = (fp_type1 == FPType_Zero);     zero2 = (fp_type2 == FPType_Zero);
         13           if (inf1 && inf2) || (zero1 && zero2) then
         14               result = FPDefaultNaN(N);
         15               FPProcessException(FPExc_InvalidOp, fpscr_val);
         16           elsif inf1 || zero2 then
         17               result_sign = if sign1 == sign2 then '0' else '1';
         18               result = FPInfinity(result_sign, N);
         19               if !inf1 then FPProcessException(FPExc_DivideByZero, fpscr_val);
         20           elsif zero1 || inf2 then
         21               result_sign = if sign1 == sign2 then '0' else '1';
         22               result = FPZero(result_sign, N);
         23           else
         24               result = FPRound(value1/value2, N, fpscr_val);
         25       return result;

E2.1.147 FPDoubleToHalf
          1   // FPDoubleToHalf()
          2   // ================
          3
          4   bits(16) FPDoubleToHalf(bits(64) operand, boolean fpscr_controlled)
          5       fpscr_val = if fpscr_controlled then FPSCR else StandardFPSCRValue();
          6       (fp_type,sign,value) = FPUnpackCV(operand, fpscr_val);
          7       if fp_type == FPType_SNaN || fp_type == FPType_QNaN then
          8            if fpscr_val.AHP == '1' then
          9                result = FPZero(sign, 16);
         10            elsif fpscr_val.DN == '1' then
         11                result = FPDefaultNaN(16);
         12            else
         13                result = sign : '11111 1' : operand[50:42];
         14            if fp_type == FPType_SNaN || fpscr_val.AHP == '1' then
         15                FPProcessException(FPExc_InvalidOp, fpscr_val);
         16       elsif fp_type == FPType_Infinity then
         17            if fpscr_val.AHP == '1' then
         18                result = sign : Ones(15);
         19                FPProcessException(FPExc_InvalidOp, fpscr_val);
         20            else
         21                result = FPInfinity(sign, 16);
         22       elsif fp_type == FPType_Zero then
         23            result = FPZero(sign, 16);
         24       else
         25            result = FPRoundCV(value, 16, fpscr_val);
         26       return result;

E2.1.148 FPDoubleToSingle
          1   // FPDoubleToSingle()
          2   // ==================
          3
          4   bits(32) FPDoubleToSingle(bits(64) operand, boolean fpscr_controlled)
          5       fpscr_val = if fpscr_controlled then FPSCR else StandardFPSCRValue();
          6       (fp_type,sign,value) = FPUnpackCV(operand, fpscr_val);
          7       if fp_type == FPType_SNaN || fp_type == FPType_QNaN then
          8            if fpscr_val.DN == '1' then
          9                result = FPDefaultNaN(32);
         10            else
         11                result = sign : '11111111 1' : operand[50:29];
         12            if fp_type == FPType_SNaN then
         13                FPProcessException(FPExc_InvalidOp, fpscr_val);
         14       elsif fp_type == FPType_Infinity then
         15            result = FPInfinity(sign, 32);
         16       elsif fp_type == FPType_Zero then
         17            result = FPZero(sign, 32);
         18       else
         19            result = FPRoundCV(value, 32, fpscr_val);
         20       return result;

E2.1.149 FPExc
          1   // Floating point exceptions
          2   // ==========================
          3
          4   enumeration FPExc {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,
          5                      FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm};

E2.1.150 FPHalfToDouble
          1   // FPHalfToDouble()
          2   // ================
          3
          4   bits(64) FPHalfToDouble(bits(16) operand, boolean fpscr_controlled)
          5       fpscr_val = if fpscr_controlled then FPSCR else StandardFPSCRValue();
          6       (fp_type,sign,value) = FPUnpackCV(operand, fpscr_val);
          7       if fp_type == FPType_SNaN || fp_type == FPType_QNaN then
          8            if fpscr_val.DN == '1' then
          9                result = FPDefaultNaN(64);
         10            else
         11                result = sign : '11111111111 1' : operand[8:0] : Zeros(42);
         12            if fp_type == FPType_SNaN then
         13                FPProcessException(FPExc_InvalidOp, fpscr_val);
         14       elsif fp_type == FPType_Infinity then
         15            result = FPInfinity(sign, 64);
         16       elsif fp_type == FPType_Zero then
         17            result = FPZero(sign, 64);
         18       else
         19            result = FPRoundCV(value, 64, fpscr_val); // Rounding will be exact
         20       return result;

E2.1.151 FPHalfToSingle
          1   // FPHalfToSingle()
          2   // ================
          3
          4   bits(32) FPHalfToSingle(bits(16) operand, boolean fpscr_controlled)
          5       return FPHalfToSingle(operand, fpscr_controlled, FALSE);
          6
          7   bits(32) FPHalfToSingle(bits(16) operand, boolean fpscr_controlled, boolean predicated)
          8       fpscr_val = if fpscr_controlled then FPSCR else StandardFPSCRValue();
          9       (fp_type,sign,value) = FPUnpackCV(operand, fpscr_val, predicated);
         10       if fp_type == FPType_SNaN || fp_type == FPType_QNaN then
         11           if fpscr_val.DN == '1' then
         12                result = FPDefaultNaN(32);
         13            else
         14                result = sign : '11111111 1' : operand[8:0] : Zeros(13);
         15            if fp_type == FPType_SNaN then
         16                FPProcessException(FPExc_InvalidOp, fpscr_val, predicated);
         17       elsif fp_type == FPType_Infinity then
         18            result = FPInfinity(sign, 32);
         19       elsif fp_type == FPType_Zero then
         20            result = FPZero(sign, 32);
         21       else
         22            result = FPRoundCV(value, 32, fpscr_val, predicated); // Rounding will be exact
         23       return result;

E2.1.152 FPInfinity
          1   // FPInfinity()
          2   // ============
          3
          4   bits(N) FPInfinity(bit sign, integer N)
          5       assert N IN {16,32,64};
          6       integer E = if N == 16 then 5 elsif N == 32 then 8 else 11;
          7       constant integer F = N - E - 1;
          8       bits(E) exp;
          9       bits(F) frac;
         10       exp = Ones(E);
         11       frac = Zeros(F);
         12       return sign : exp : frac;

E2.1.153 FPMax
          1   // FPMax()
          2   // =======
          3
          4   bits(N) FPMax(bits(N) op1, bits(N) op2, boolean fpscr_controlled)
          5       return FPMax(op1, op2, fpscr_controlled, FALSE);
          6
          7   bits(N) FPMax(bits(N) op1, bits(N) op2, boolean fpscr_controlled, boolean predicated)
          8       assert N IN {16,32,64};
          9       fpscr_val = if fpscr_controlled then FPSCR else StandardFPSCRValue();
         10       (fp_type1,sign1,value1) = FPUnpack(op1, fpscr_val, predicated);
         11       (fp_type2,sign2,value2) = FPUnpack(op2, fpscr_val, predicated);
         12       (done,result) = FPProcessNaNs(fp_type1, fp_type2, op1, op2, fpscr_val, predicated);
         13       if !done then
         14           if value1 > value2 then
         15               (fp_type,sign,value) = (fp_type1,sign1,value1);
         16           else
         17               (fp_type,sign,value) = (fp_type2,sign2,value2);
         18           if fp_type == FPType_Infinity then
         19               result = FPInfinity(sign, N);
         20           elsif fp_type == FPType_Zero then
         21               sign = sign1 AND sign2; // Use most positive sign
         22               result = FPZero(sign, N);
         23           else
         24               result = FPRound(value, N, fpscr_val, predicated);
         25       return result;

E2.1.154 FPMaxNormal
          1   // FPMaxNormal()
          2   // =============
          3
          4   bits(N) FPMaxNormal(bit sign, integer N)
          5       assert N IN {16,32,64};
          6       integer E = if N == 16 then 5 elsif N == 32 then 8 else 11;
          7       constant integer F = N - E - 1;
          8       bits(E) exp;
          9       bits(F) frac;
         10       exp = Ones(E-1):'0';
         11       frac = Ones(F);
         12       return sign : exp : frac;

E2.1.155 FPMaxNum
          1   // FPMaxNum()
          2   // ==========
          3
          4   bits(N) FPMaxNum(bits(N) op1, bits(N) op2, boolean fpscr_controlled)
          5       return FPMaxNum(op1, op2, fpscr_controlled, FALSE);
          6
          7   bits(N) FPMaxNum(bits(N) op1, bits(N) op2, boolean fpscr_controlled, boolean predicated)
          8       assert N IN {16,32,64};
          9
         10       fpscr_val = if fpscr_controlled then FPSCR else StandardFPSCRValue();
         11       (type1,-,-) = FPUnpack(op1, fpscr_val, predicated);
         12       (type2,-,-) = FPUnpack(op2, fpscr_val, predicated);
         13
         14       // Treat a single quiet-NaN as -Infinity
         15       if type1 == FPType_QNaN && type2 != FPType_QNaN then
         16           op1 = FPInfinity('1', N);
         17       elsif type1 != FPType_QNaN && type2 == FPType_QNaN then
         18           op2 = FPInfinity('1', N);
         19
         20       return FPMax(op1, op2, fpscr_controlled, predicated);

E2.1.156 FPMin
          1   // FPMin()
          2   // =======
          3
          4   bits(N) FPMin(bits(N) op1, bits(N) op2, boolean fpscr_controlled)
          5       return FPMin(op1, op2, fpscr_controlled, FALSE);
          6
          7   bits(N) FPMin(bits(N) op1, bits(N) op2, boolean fpscr_controlled, boolean predicated)
          8       assert N IN {16,32,64};
          9       fpscr_val = if fpscr_controlled then FPSCR else StandardFPSCRValue();
         10       (fp_type1,sign1,value1) = FPUnpack(op1, fpscr_val, predicated);
         11       (fp_type2,sign2,value2) = FPUnpack(op2, fpscr_val, predicated);
         12       (done,result) = FPProcessNaNs(fp_type1, fp_type2, op1, op2, fpscr_val, predicated);
         13       if !done then
         14           if value1 < value2 then
         15               (fp_type,sign,value) = (fp_type1,sign1,value1);
         16           else
         17               (fp_type,sign,value) = (fp_type2,sign2,value2);
         18           if fp_type == FPType_Infinity then
         19               result = FPInfinity(sign, N);
         20           elsif fp_type == FPType_Zero then
         21               sign = sign1 OR sign2; // Use most negative sign
         22               result = FPZero(sign, N);
         23           else
         24               result = FPRound(value, N, fpscr_val, predicated);
         25       return result;

E2.1.157 FPMinNum
          1   // FPMinNum()
          2   // ==========
          3
          4   bits(N) FPMinNum(bits(N) op1, bits(N) op2, boolean fpscr_controlled)
          5       return FPMinNum(op1, op2, fpscr_controlled, FALSE);
          6
          7   bits(N) FPMinNum(bits(N) op1, bits(N) op2, boolean fpscr_controlled, boolean predicated)
          8       assert N IN {16,32,64};
          9
         10       fpscr_val = if fpscr_controlled then FPSCR else StandardFPSCRValue();
         11       (fp_type1,-,-) = FPUnpack(op1, fpscr_val, predicated);
         12       (fp_type2,-,-) = FPUnpack(op2, fpscr_val, predicated);
         13
         14       // Treat a single quiet-NaN as +Infinity
         15       if fp_type1 == FPType_QNaN && fp_type2 != FPType_QNaN then
         16           op1 = FPInfinity('0', N);
         17       elsif fp_type1 != FPType_QNaN && fp_type2 == FPType_QNaN then
         18           op2 = FPInfinity('0', N);
         19
         20       return FPMin(op1, op2, fpscr_controlled, predicated);

E2.1.158 FPMul
          1   // FPMul()
          2   // =======
          3
          4   bits(N) FPMul(bits(N) op1, bits(N) op2, boolean fpscr_controlled)
          5       return FPMul(op1, op2, fpscr_controlled, FALSE);
          6
          7   bits(N) FPMul(bits(N) op1, bits(N) op2, boolean fpscr_controlled, boolean predicated)
          8       assert N IN {16,32,64};
          9       fpscr_val = if fpscr_controlled then FPSCR else StandardFPSCRValue();
         10       (type1,sign1,value1) = FPUnpack(op1, fpscr_val, predicated);
         11       (type2,sign2,value2) = FPUnpack(op2, fpscr_val, predicated);
         12       (done,result) = FPProcessNaNs(type1, type2, op1, op2, fpscr_val, predicated);
         13       if !done then
         14           inf1 = (type1 == FPType_Infinity); inf2 = (type2 == FPType_Infinity);
         15           zero1 = (type1 == FPType_Zero);      zero2 = (type2 == FPType_Zero);
         16           if (inf1 && zero2) || (zero1 && inf2) then
         17               result = FPDefaultNaN(N);
         18               FPProcessException(FPExc_InvalidOp, fpscr_val, predicated);
         19           elsif inf1 || inf2 then
         20               result_sign = if sign1 == sign2 then '0' else '1';
         21               result = FPInfinity(result_sign, N);
         22           elsif zero1 || zero2 then
         23               result_sign = if sign1 == sign2 then '0' else '1';
         24               result = FPZero(result_sign, N);
         25           else
         26               result = FPRound(value1*value2, N, fpscr_val, predicated);
         27       return result;

E2.1.159 FPMulAdd
          1   // FPMulAdd()
          2   // ==========
          3   // Calculates addend + op1*op2 with a single rounding.
          4
          5   bits(N) FPMulAdd(bits(N) addend, bits(N) op1, bits(N) op2, boolean fpscr_controlled)
          6       return FPMulAdd(addend, op1, op2, fpscr_controlled, FALSE);
          7
          8   bits(N) FPMulAdd(bits(N) addend, bits(N) op1, bits(N) op2, boolean fpscr_controlled,
          9                    boolean predicated)
         10       assert N IN {16,32,64};
         11       fpscr_val = if fpscr_controlled then FPSCR else StandardFPSCRValue();
         12       (typeA,signA,valueA) = FPUnpack(addend, fpscr_val, predicated);
         13       (type1,sign1,value1) = FPUnpack(op1, fpscr_val, predicated);
         14       (type2,sign2,value2) = FPUnpack(op2, fpscr_val, predicated);
         15       inf1 = (type1 == FPType_Infinity); zero1 = (type1 == FPType_Zero);
         16       inf2 = (type2 == FPType_Infinity); zero2 = (type2 == FPType_Zero);
         17       (done,result) = FPProcessNaNs3(typeA, type1, type2, addend, op1, op2, fpscr_val,
         18                                      predicated);
         19
         20       if typeA == FPType_QNaN && ((inf1 && zero2) || (zero1 && inf2)) then
         21             result = FPDefaultNaN(N);
         22             FPProcessException(FPExc_InvalidOp, fpscr_val, predicated);
         23
         24        if !done then
         25            infA = (typeA == FPType_Infinity);            zeroA = (typeA == FPType_Zero);
         26
         27             // Determine sign and type product will have if it does not cause an Invalid
         28             // Operation.
         29             signP = if sign1 == sign2 then '0' else '1';
         30             infP = inf1 || inf2;
         31             zeroP = zero1 || zero2;
         32
         33             // Non SNaN-generated Invalid Operation cases are multiplies of zero by infinity and 34             // additions of opposite-signed infinities.
         35             if (inf1 && zero2) || (zero1 && inf2) || (infA && infP && signA == NOT(signP)) then
         36                 result = FPDefaultNaN(N);
         37                 FPProcessException(FPExc_InvalidOp, fpscr_val, predicated);
         38
         39             // Other cases involving infinities produce an infinity of the same sign.
         40             elsif (infA && signA == '0') || (infP && signP == '0') then
         41                 result = FPInfinity('0', N);
         42             elsif (infA && signA == '1') || (infP && signP == '1') then
         43                 result = FPInfinity('1', N);
         44
         45             // Cases where the result is exactly zero and its sign is not determined by the
         46             // rounding mode are additions of same-signed zeros.
         47             elsif zeroA && zeroP && signA == signP then
         48                 result = FPZero(signA, N);
         49
         50             // Otherwise calculate numerical result and round it.
         51             else
         52                 result_value = valueA + (value1 * value2);
         53                 if result_value == 0.0 then // Sign of exact zero result depends
         54                                               // on rounding mode
         55                      result_sign = if fpscr_val.RMode == FPSCR_RMode_RM then '1' else '0';
         56                      result = FPZero(result_sign, N);
         57                 else
         58                      result = FPRound(result_value, N, fpscr_val, predicated);
         59
         60        return result;

E2.1.160 FPNeg
          1   // FPNeg()
          2   // =======
          3
          4   bits(N) FPNeg(bits(N) operand)
          5       assert N IN {16,32,64};
          6       return NOT(operand[N-1]) : operand[N-2:0];

E2.1.161 FPProcessException
          1   //   FPProcessException()
          2   //   ====================
          3   //   The 'fpscr_val' argument supplies FPSCR control bits. Status information is
          4   //   updated directly in FPSCR where appropriate.
          5
          6   FPProcessException(FPExc exception, FPSCR_Type fpscr_val)
          7       FPProcessException(exception, fpscr_val, FALSE);
          8       return;
          9
         10   FPProcessException(FPExc exception, FPSCR_Type fpscr_val, boolean predicated)
         11       // Get appropriate FPSCR bit numbers
         12       if !predicated then
         13           case exception of
         14               when FPExc_InvalidOp     enable = 8;   cumul = 0;
         15               when FPExc_DivideByZero enable = 9;    cumul = 1;
         16                when FPExc_Overflow      enable = 10;              cumul   =   2;
         17                when FPExc_Underflow     enable = 11;              cumul   =   3;
         18                when FPExc_Inexact       enable = 12;              cumul   =   4;
         19                when FPExc_InputDenorm   enable = 15;              cumul   =   7;
         20            if fpscr_val[enable] == '1' then
         21                IMPLEMENTATION_DEFINED "floating-point             trap handling";
         22            else
         23                FPSCR[cumul] = '1';
         24        return;

E2.1.162 FPProcessNaN
          1   //   FPProcessNaN()
          2   //   ==============
          3   //   The 'fpscr_val' argument supplies FPSCR control bits. Status information is
          4   //   updated directly in FPSCR where appropriate.
          5
          6   bits(N) FPProcessNaN(FPType fp_type, bits(N) operand, FPSCR_Type fpscr_val)
          7       return FPProcessNaN(fp_type, operand, fpscr_val, FALSE);
          8
          9   bits(N) FPProcessNaN(FPType fp_type, bits(N) operand, FPSCR_Type fpscr_val,
         10                         boolean predicated)
         11       assert N IN {16,32,64};
         12       if N == 16 then     topfrac = 9;
         13       elsif N == 32 then topfrac = 22;
         14       else                topfrac = 51;
         15       result = operand;
         16       if fp_type == FPType_SNaN then
         17            result[topfrac] = '1';
         18            FPProcessException(FPExc_InvalidOp, fpscr_val, predicated);
         19       if fpscr_val.DN == '1' then // DefaultNaN requested
         20            result = FPDefaultNaN(N);
         21       return result;

E2.1.163 FPProcessNaNs
          1   //   FPProcessNaNs()
          2   //   ===============
          3   //   The boolean part of the return value says whether a NaN has been found and 4   //   processed. The bits(N) part is only relevant if it has and supplies the
          5   //   result of the operation.
          6   //
          7   //   The 'fpscr_val' argument supplies FPSCR control bits. Status information is
          8   //   updated directly in FPSCR where appropriate.
          9
         10   (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2,
         11                                    bits(32) fpscr_val)
         12       return FPProcessNaNs(type1, type2, op1, op2, fpscr_val, FALSE);
         13
         14   (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2,
         15                                    bits(32) fpscr_val, boolean predicated)
         16       assert N IN {16,32,64};
         17       if type1 == FPType_SNaN then
         18            done = TRUE; result = FPProcessNaN(type1, op1, fpscr_val, predicated);
         19       elsif type2 == FPType_SNaN then
         20            done = TRUE; result = FPProcessNaN(type2, op2, fpscr_val, predicated);
         21       elsif type1 == FPType_QNaN then
         22            done = TRUE; result = FPProcessNaN(type1, op1, fpscr_val, predicated);
         23       elsif type2 == FPType_QNaN then
         24            done = TRUE; result = FPProcessNaN(type2, op2, fpscr_val, predicated);
         25       else
         26            done = FALSE; result = Zeros(N); // 'Don't care' result
         27       return (done, result);

E2.1.164 FPProcessNaNs3
          1   //   FPProcessNaNs3()
          2   //   ================
          3   //   The boolean part of the return value says whether a NaN has been found and 4   //   processed. The bits(N) part is only relevant if it has and supplies the
          5   //   result of the operation.
          6   //
          7   //   The 'fpscr_val' argument supplies FPSCR control bits. Status information is
          8   //   updated directly in FPSCR where appropriate.
          9
         10   (boolean, bits(N)) FPProcessNaNs3(FPType type1, FPType type2, FPType type3,
         11                                     bits(N) op1, bits(N) op2, bits(N) op3,
         12                                     bits(32) fpscr_val)
         13       return FPProcessNaNs3(type1, type2, type3, op1, op2, op3, fpscr_val, FALSE);
         14
         15   (boolean, bits(N)) FPProcessNaNs3(FPType type1, FPType type2, FPType type3,
         16                                     bits(N) op1, bits(N) op2, bits(N) op3,
         17                                     bits(32) fpscr_val, boolean predicated)
         18       assert N IN {16,32,64};
         19       if type1 == FPType_SNaN then
         20            done = TRUE; result = FPProcessNaN(type1, op1, fpscr_val, predicated);
         21       elsif type2 == FPType_SNaN then
         22            done = TRUE; result = FPProcessNaN(type2, op2, fpscr_val, predicated);
         23       elsif type3 == FPType_SNaN then
         24            done = TRUE; result = FPProcessNaN(type3, op3, fpscr_val, predicated);
         25       elsif type1 == FPType_QNaN then
         26            done = TRUE; result = FPProcessNaN(type1, op1, fpscr_val, predicated);
         27       elsif type2 == FPType_QNaN then
         28            done = TRUE; result = FPProcessNaN(type2, op2, fpscr_val, predicated);
         29       elsif type3 == FPType_QNaN then
         30            done = TRUE; result = FPProcessNaN(type3, op3, fpscr_val, predicated);
         31       else
         32            done = FALSE; result = Zeros(N); // 'Do not care' result
         33       return (done, result);

E2.1.165 FPRound
          1   //   FPRound()
          2   //   =========
          3   //   Used by data processing and int/fixed <-> FP conversion instructions.
          4   //   For half-precision data it ignores AHP, and observes FZ16.
          5
          6   bits(N) FPRound(real value, integer N, FPSCR_Type fpscr_val)
          7       return FPRound(value, N, fpscr_val, FALSE);
          8
          9   bits(N) FPRound(real value, integer N, FPSCR_Type fpscr_val, boolean predicated)
         10       fpscr_val.AHP = '0';
         11       return FPRoundBase(value, N, fpscr_val, predicated);

E2.1.166 FPRoundBase
          1   //   FPRoundBase()
          2   //   =============
          3   //   The 'fpscr_val' argument supplies FPSCR control bits. Status information is
          4   //   updated directly in FPSCR where appropriate.
          5
          6   bits(N) FPRoundBase(real value, integer N, FPSCR_Type fpscr_val, boolean predicated)
          7       assert N IN {16,32,64};
          8       assert value != 0.0;
          9
         10        // Obtain format parameters - minimum exponent, numbers of exponent and fraction bits.
         11        integer E = if N == 16 then 5 elsif N == 32 then 8 else 11;
         12        minimum_exp = 2 - 2^(E-1);
         13        constant integer F = N - E - 1;
         14
         15        // Split value into sign, unrounded mantissa and exponent.
         16        if value < 0.0 then
         17            sign = '1'; mantissa = -value;
         18       else
         19           sign = '0'; mantissa = value;
         20       exponent = 0;
         21       while mantissa < 1.0 do
         22           mantissa = mantissa * 2.0; exponent = exponent - 1;
         23       while mantissa >= 2.0 do
         24           mantissa = mantissa / 2.0; exponent = exponent + 1;
         25
         26       // Deal with flush-to-zero.
         27       if ((N != 16 && fpscr_val.FZ == '1') || (N == 16 && fpscr_val.FZ16 == '1')) &&
         28             exponent < minimum_exp then
         29            result = FPZero(sign, N);
         30            if !predicated then FPSCR.UFC = '1'; // Flush-to-zero never generates a trapped
         31                                                 // exception
         32       else
         33
         34              // Start creating the exponent value for the result. Start by biasing the actual
         35              // exponent so that the minimum exponent becomes 1, lower values 0 (indicating
         36              // possible underflow).
         37              biased_exp = Max(exponent - minimum_exp + 1, 0);
         38              if biased_exp == 0 then mantissa = mantissa / 2.0^(minimum_exp - exponent);
         39
         40              // Get the unrounded mantissa as an integer, and the "units in last place"
         41              // rounding error.
         42              int_mant = RoundDown(mantissa * 2.0^F); // if biased_exp == 0, < 2.0^F
         43                                                      // otherwise          >= 2.0^F
         44              error = mantissa * 2.0^F - Real(int_mant);
         45
         46              // Underflow occurs if exponent is too small before rounding, and result is inexact
         47              // or the Underflow exception is trapped.
         48              if biased_exp == 0 && error != 0.0 then
         49                  FPProcessException(FPExc_Underflow, fpscr_val, predicated);
         50
         51              // Round result according to rounding mode.
         52              case fpscr_val.RMode of
         53                  when FPSCR_RMode_RN // Round to Nearest (rounding to even if exactly halfway)
         54                      round_up = (error > 0.5 || (error == 0.5 && int_mant[0] == '1'));
         55                      overflow_to_inf = TRUE;
         56                  when FPSCR_RMode_RP // Round towards Plus Infinity
         57                      round_up = (error != 0.0 && sign == '0');
         58                      overflow_to_inf = (sign == '0');
         59                  when FPSCR_RMode_RM // Round towards Minus Infinity
         60                      round_up = (error != 0.0 && sign == '1');
         61                      overflow_to_inf = (sign == '1');
         62                  when FPSCR_RMode_RZ // Round towards Zero
         63                      round_up = FALSE;
         64                      overflow_to_inf = FALSE;
         65              if round_up then
         66                  int_mant = int_mant + 1;
         67                  if int_mant == 2^F then      // Rounded up from denormalized to normalized
         68                      biased_exp = 1;
         69                  if int_mant == 2^(F+1) then // Rounded up to next exponent
         70                      biased_exp = biased_exp + 1; int_mant = int_mant DIV 2;
         71
         72              // Deal with overflow and generate result.
         73              if N != 16 || fpscr_val.AHP == '0' then // Single, double or IEEE half precision
         74                  if biased_exp >= 2^E - 1 then
         75                       result = if overflow_to_inf then FPInfinity(sign,N) else FPMaxNormal(sign,N);
         76                       FPProcessException(FPExc_Overflow, fpscr_val, predicated);
         77                       error = 1.0; // Ensure that an Inexact exception occurs
         78                  else
         79                       result = sign : biased_exp[E-1:0] : int_mant[F-1:0];
         80              else                                     // Alternative half precision
         81                  if biased_exp >= 2^E then
         82                       result = sign : Ones(N-1);
         83                       FPProcessException(FPExc_InvalidOp, fpscr_val, predicated);
         84                       error = 0.0; // Ensure that an Inexact exception does not occur
         85                  else
         86                       result = sign : biased_exp[E-1:0] : int_mant[F-1:0];
         87
         88             // Deal with Inexact exception.
         89             if error != 0.0 then
         90                 FPProcessException(FPExc_Inexact, fpscr_val, predicated);
         91
         92        return result;

E2.1.167 FPRoundCV
          1   //   FPRoundCV()
          2   //   ===========
          3   //   Used for FP <-> FP conversion instructions.
          4   //   For half-precision data processing operations the FZ16 bit
          5   //   is ignored and the AHP bit is observed.
          6
          7   bits(N) FPRoundCV(real value, integer N, FPSCR_Type fpscr_val)
          8       return FPRoundCV(value, N, fpscr_val, FALSE);
          9
         10   bits(N) FPRoundCV(real value, integer N, FPSCR_Type fpscr_val, boolean predicated)
         11       fpscr_val.FZ16 = '0';
         12       return FPRoundBase(value, N, fpscr_val, predicated);

E2.1.168 FPRoundInt
          1   //   FPRoundInt()
          2   //   ============
          3   //   Round floating-point value to nearest integral floating point value
          4   //   using given rounding mode. If exact is TRUE, set inexact flag if result
          5   //   is not numerically equal to given value.
          6
          7   bits(N) FPRoundInt(bits(N) op, bits(2) rmode, boolean away, boolean exact,
          8                      boolean fpscr_controlled)
          9       return FPRoundInt(op, rmode, away, exact, fpscr_controlled, FALSE);
         10
         11   bits(N) FPRoundInt(bits(N) op, bits(2) rmode, boolean away, boolean exact,
         12                      boolean fpscr_controlled, boolean predicated)
         13       assert N IN {16,32,64};
         14       fpscr_val = if fpscr_controlled then FPSCR else StandardFPSCRValue();
         15
         16        // Unpack using FPSCR to determine if subnormals are flushed-to-zero
         17        (fp_type,sign,value) = FPUnpack(op, fpscr_val, predicated);
         18
         19        if fp_type == FPType_SNaN || fp_type == FPType_QNaN then
         20             result = FPProcessNaN(fp_type, op, fpscr_val, predicated);
         21        elsif fp_type == FPType_Infinity then
         22             result = FPInfinity(sign, N);
         23        elsif fp_type == FPType_Zero then
         24             result = FPZero(sign, N);
         25        else
         26             // extract integer component
         27             int_result = RoundDown(value);
         28             error = value - Real(int_result);
         29
         30             // Determine whether supplied rounding mode requires an increment
         31             case rmode of
         32                 when '00' // Round to nearest, ties to even
         33                     round_up = (error > 0.5 || (error == 0.5 && int_result[0] == '1'));
         34                 when '01' // Round towards Plus Infinity
         35                     round_up = (error != 0.0);
         36                 when '10' // Round towards Minus Infinity
         37                     round_up = FALSE;
         38                 when '11' // Round towards Zero
         39                     round_up = (error != 0.0 && int_result < 0);
         40
         41             if away then // Round towards Zero, ties away
         42                 round_up = (error > 0.5 || (error == 0.5 && int_result >= 0));
         43
         44           if round_up then int_result = int_result + 1;
         45
         46           // Convert integer value into an equivalent real value
         47           real_result = Real(int_result);
         48
         49           // Re-encode as a floating-point value, result is always exact
         50           if real_result == 0.0 then
         51               result = FPZero(sign, N);
         52           else
         53               result = FPRound(real_result, N, fpscr_val, predicated);
         54
         55           // Generate inexact exceptions
         56           if error != 0.0 && exact then
         57               FPProcessException(FPExc_Inexact, fpscr_val, predicated);
         58
         59       return result;

E2.1.169 FPSingleToDouble
          1   // FPSingleToDouble()
          2   // ==================
          3
          4   bits(64) FPSingleToDouble(bits(32) operand, boolean fpscr_controlled)
          5       fpscr_val = if fpscr_controlled then FPSCR else StandardFPSCRValue();
          6       (fp_type,sign,value) = FPUnpackCV(operand, fpscr_val);
          7       if fp_type == FPType_SNaN || fp_type == FPType_QNaN then
          8            if fpscr_val.DN == '1' then
          9                result = FPDefaultNaN(64);
         10            else
         11                result = sign : '11111111111 1' : operand[21:0] : Zeros(29);
         12            if fp_type == FPType_SNaN then
         13                FPProcessException(FPExc_InvalidOp, fpscr_val);
         14       elsif fp_type == FPType_Infinity then
         15            result = FPInfinity(sign, 64);
         16       elsif fp_type == FPType_Zero then
         17            result = FPZero(sign, 64);
         18       else
         19            result = FPRoundCV(value, 64, fpscr_val); // Rounding will be exact
         20       return result;

E2.1.170 FPSingleToHalf
          1   // FPSingleToHalf()
          2   // ================
          3
          4   bits(16) FPSingleToHalf(bits(32) operand, boolean fpscr_controlled)
          5       return FPSingleToHalf(operand, fpscr_controlled, FALSE);
          6
          7   bits(16) FPSingleToHalf(bits(32) operand, boolean fpscr_controlled, boolean predicated)
          8       fpscr_val = if fpscr_controlled then FPSCR else StandardFPSCRValue();
          9       (fp_type,sign,value) = FPUnpackCV(operand, fpscr_val, predicated);
         10       if fp_type == FPType_SNaN || fp_type == FPType_QNaN then
         11           if fpscr_val.AHP == '1' then
         12               result = FPZero(sign, 16);
         13           elsif fpscr_val.DN == '1' then
         14               result = FPDefaultNaN(16);
         15           else
         16               result = sign : '11111 1' : operand[21:13];
         17           if fp_type == FPType_SNaN || fpscr_val.AHP == '1' then
         18               FPProcessException(FPExc_InvalidOp, fpscr_val, predicated);
         19       elsif fp_type == FPType_Infinity then
         20           if fpscr_val.AHP == '1' then
         21               result = sign : Ones(15);
         22               FPProcessException(FPExc_InvalidOp, fpscr_val, predicated);
         23           else
         24               result = FPInfinity(sign, 16);
         25       elsif fp_type == FPType_Zero then
         26              result = FPZero(sign, 16);
         27       else
         28           result = FPRoundCV(value, 16, fpscr_val, predicated);
         29       return result;

E2.1.171 FPSqrt
          1   // FPSqrt()
          2   // ========
          3
          4   bits(N) FPSqrt(bits(N) operand)
          5       assert N IN {16,32,64};
          6       (fp_type,sign,value) = FPUnpack(operand, FPSCR);
          7       if fp_type == FPType_SNaN || fp_type == FPType_QNaN then
          8            result = FPProcessNaN(fp_type, operand, FPSCR);
          9       elsif fp_type == FPType_Zero then
         10            result = FPZero(sign, N);
         11       elsif fp_type == FPType_Infinity && sign == '0' then
         12            result = FPInfinity(sign, N);
         13       elsif sign == '1' then
         14            result = FPDefaultNaN(N);
         15            FPProcessException(FPExc_InvalidOp, FPSCR);
         16       else
         17            result = FPRound(Sqrt(value), N, FPSCR);
         18       return result;

E2.1.172 FPSub
          1   // FPSub()
          2   // =======
          3
          4   bits(N) FPSub(bits(N) op1, bits(N) op2, boolean fpscr_controlled)
          5       return FPSub(op1, op2, fpscr_controlled, FALSE);
          6
          7   bits(N) FPSub(bits(N) op1, bits(N) op2, boolean fpscr_controlled, boolean predicated)
          8       assert N IN {16,32,64};
          9       fpscr_val = if fpscr_controlled then FPSCR else StandardFPSCRValue();
         10       (fp_type1,sign1,value1) = FPUnpack(op1, fpscr_val, predicated);
         11       (fp_type2,sign2,value2) = FPUnpack(op2, fpscr_val, predicated);
         12       (done,result) = FPProcessNaNs(fp_type1, fp_type2, op1, op2, fpscr_val, predicated);
         13       if !done then
         14           inf1 = (fp_type1 == FPType_Infinity); inf2 = (fp_type2 == FPType_Infinity);
         15           zero1 = (fp_type1 == FPType_Zero);      zero2 = (fp_type2 == FPType_Zero);
         16           if inf1 && inf2 && sign1 == sign2 then
         17               result = FPDefaultNaN(N);
         18               FPProcessException(FPExc_InvalidOp, fpscr_val, predicated);
         19           elsif (inf1 && sign1 == '0') || (inf2 && sign2 == '1') then
         20               result = FPInfinity('0', N);
         21           elsif (inf1 && sign1 == '1') || (inf2 && sign2 == '0') then
         22               result = FPInfinity('1', N);
         23           elsif zero1 && zero2 && sign1 == NOT(sign2) then
         24               result = FPZero(sign1, N);
         25           else
         26               result_value = value1 - value2;
         27               if result_value == 0.0 then // Sign of exact zero result depends
         28                                             // on rounding mode
         29                    result_sign = if fpscr_val.RMode == FPSCR_RMode_RM then '1' else '0';
         30                    result = FPZero(result_sign, N);
         31               else
         32                    result = FPRound(result_value, N, fpscr_val, predicated);
         33       return result;

E2.1.173 FPToFixed
          1   // FPToFixed()
          2   // ===========
          3
          4   bits(M) FPToFixed(bits(N) operand, integer M, integer fraction_bits, boolean unsigned,
          5                     boolean round_towards_zero, boolean fpscr_controlled)
          6       return FPToFixed(operand, M, fraction_bits, unsigned, round_towards_zero,
          7                        fpscr_controlled, FALSE);
          8
          9   bits(M) FPToFixed(bits(N) operand, integer M, integer fraction_bits, boolean unsigned,
         10                     boolean round_towards_zero, boolean fpscr_controlled,
         11                     boolean predicated)
         12       assert N IN {16,32,64};
         13       fpscr_val = if fpscr_controlled then FPSCR else StandardFPSCRValue();
         14       if round_towards_zero then fpscr_val.RMode = FPSCR_RMode_RZ;
         15       (fp_type,-,value) = FPUnpack(operand, fpscr_val, predicated);
         16
         17       //   For NaNs and infinities, FPUnpack() has produced a value that will round to the
         18       //   required result of the conversion. Also, the value produced for infinities will
         19       //   cause the conversion to overflow and signal an Invalid Operation floating-point
         20       //   exception as required. NaNs must also generate such a floating-point exception.
         21       if   fp_type == FPType_SNaN || fp_type == FPType_QNaN then
         22             FPProcessException(FPExc_InvalidOp, fpscr_val, predicated);
         23
         24       // Scale value by specified number of fraction bits, then start rounding to an integer
         25       // and determine the rounding error.
         26       value = value * 2.0^fraction_bits;
         27       int_result = RoundDown(value);
         28       error = value - Real(int_result);
         29
         30       // Apply the specified rounding mode.
         31       case fpscr_val.RMode of
         32           when FPSCR_RMode_RN // Round to Nearest (rounding to even if exactly halfway)
         33               round_up = (error > 0.5 || (error == 0.5 && int_result[0] == '1'));
         34           when FPSCR_RMode_RP // Round towards Plus Infinity
         35               round_up = (error != 0.0);
         36           when FPSCR_RMode_RM // Round towards Minus Infinity
         37               round_up = FALSE;
         38           when FPSCR_RMode_RZ // Round towards Zero
         39               round_up = (error != 0.0 && int_result < 0);
         40       if round_up then int_result = int_result + 1;
         41
         42       // Bitstring result is the integer result saturated to the destination size, with
         43       // saturation indicating overflow of the conversion (signaled as an Invalid
         44       // Operation floating-point exception).
         45       (result, overflow) = SatQ(int_result, M, unsigned);
         46       if overflow then
         47           FPProcessException(FPExc_InvalidOp, fpscr_val, predicated);
         48       elsif error != 0.0 then
         49           FPProcessException(FPExc_Inexact, fpscr_val, predicated);
         50
         51       return result;

E2.1.174 FPToFixedDirected
          1   // FPToFixedDirected()
          2   // ===================
          3
          4   bits(M) FPToFixedDirected(bits(N) op, integer fbits, boolean unsigned, bits(2) round_mode,
          5                             boolean fpscr_controlled)
          6       return FPToFixedDirected(op, fbits, unsigned, round_mode, fpscr_controlled, FALSE);
          7
          8   bits(M) FPToFixedDirected(bits(N) op, integer fbits, boolean unsigned, bits(2) round_mode,
          9                             boolean fpscr_controlled, boolean predicated)
         10       assert N IN {16,32,64};
         11
         12       fpscr_val = if fpscr_controlled then FPSCR else StandardFPSCRValue();
         13
         14       // Unpack using FPSCR to determine if subnormals are flushed-to-zero
         15       (fp_type,-,value) = FPUnpack(op, fpscr_val, predicated);
         16
         17        // If NaN, set cumulative flag or take exception
         18        if fp_type == FPType_SNaN || fp_type == FPType_QNaN then
         19            FPProcessException(FPExc_InvalidOp, FPSCR, predicated);
         20
         21        // Scale by fractional bits and produce integer rounded towards
         22        // minus-infinity
         23        value = value * 2.0^fbits;
         24        int_result = RoundDown(value);
         25        error = value - Real(int_result);
         26
         27        // Determine whether supplied rounding mode requires an increment
         28        case round_mode of
         29            when '00' // ties away
         30                round_up = (error > 0.5 || (error == 0.5 && int_result >= 0));
         31            when '01' // nearest even
         32                round_up = (error > 0.5 || (error == 0.5 && int_result[0] == '1'));
         33            when '10' // plus infinity
         34                round_up = (error != 0.0);
         35            when '11' // neg infinity
         36                round_up = FALSE;
         37
         38        if round_up then int_result = int_result + 1;
         39
         40        // Generate saturated result and exceptions
         41        (result, overflow) = SatQ(int_result, M, unsigned);
         42
         43        if overflow then
         44            FPProcessException(FPExc_InvalidOp, fpscr_val, predicated);
         45        elsif error != 0.0 then
         46            FPProcessException(FPExc_Inexact, fpscr_val, predicated);
         47        return result;

E2.1.175 FPType
          1   // FPType
          2   // ======
          3
          4   // Type of floating-point value. Floating-point values are categorized into one
          5   // of the following type during unpacking.
          6
          7   enumeration FPType {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN};

E2.1.176 FPUnpack
          1   //   FPUnpack()
          2   //   ==========
          3   //
          4   //   Used by data processing and int/fixed <-> FP conversion instructions.
          5   //   For half-precision data it ignores AHP, and observes FZ16.
          6
          7   (FPType, bit, real) FPUnpack(bits(N) fpval, FPSCR_Type fpscr_val)
          8       return FPUnpack(fpval, fpscr_val, FALSE);
          9
         10   (FPType, bit, real) FPUnpack(bits(N) fpval, FPSCR_Type fpscr_val, boolean predicated)
         11       fpscr_val.AHP = '0';
         12       return FPUnpackBase(fpval, fpscr_val, predicated);

E2.1.177 FPUnpackBase
          1   //   FPUnpackBase()
          2   //   ==============
          3   //
          4   //   Unpack a floating-point number into its type, sign bit and the real number
          5   //   that it represents. The real number result has the correct sign for numbers
          6   //   and infinities, is very large in magnitude for infinities, and is 0.0 for
          7   //   NaNs. (These values are chosen to simplify the description of comparisons
          8   //   and conversions.)
          9   //
         10   //   The 'fpscr_val' argument supplies FPSCR control bits. Status information is
         11   //   updated directly in FPSCR where appropriate.
         12
         13   (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPSCR_Type fpscr_val, boolean predicated)
         14       assert N IN {16,32,64};
         15
         16        if N == 16 then
         17            sign   = fpval[15];
         18            exp16 = fpval[14:10];
         19            frac16 = fpval[9:0];
         20            if IsZero(exp16) then
         21                // Produce zero if value is zero or flush-to-zero is selected
         22                if IsZero(frac16) || fpscr_val.FZ16 == '1' then
         23                     fp_type = FPType_Zero; value = 0.0;
         24                else
         25                     fp_type = FPType_Nonzero; value = 2.0^-14 * (Real(UInt(frac16)) * 2.0^-10);
         26            elsif IsOnes(exp16) && fpscr_val.AHP == '0' then // Infinity or NaN in IEEE format
         27                if IsZero(frac16) then
         28                     fp_type = FPType_Infinity; value = 2.0^1000000;
         29                else
         30                     fp_type = if frac16[9] == '1' then FPType_QNaN else FPType_SNaN;
         31                     value   = 0.0;
         32            else
         33                fp_type = FPType_Nonzero;
         34                value    = 2.0^(UInt(exp16)-15) * (1.0 + Real(UInt(frac16)) * 2.0^-10);
         35
         36        elsif N == 32 then
         37
         38             sign   = fpval[31];
         39             exp32 = fpval[30:23];
         40             frac32 = fpval[22:0];
         41             if IsZero(exp32) then
         42                 // Produce zero if value is zero or flush-to-zero is selected.
         43                 if IsZero(frac32) || fpscr_val.FZ == '1' then
         44                      fp_type = FPType_Zero; value = 0.0;
         45                      if !IsZero(frac32) then // Denormalized input flushed to zero
         46                          FPProcessException(FPExc_InputDenorm, fpscr_val, predicated);
         47                 else
         48                      fp_type = FPType_Nonzero; value = 2.0^-126 * (Real(UInt(frac32)) * 2.0^-23);
         49             elsif IsOnes(exp32) then
         50                 if IsZero(frac32) then
         51                      fp_type = FPType_Infinity; value = 2.0^1000000;
         52                 else
         53                      fp_type = if frac32[22] == '1' then FPType_QNaN else FPType_SNaN;
         54                      value   = 0.0;
         55             else
         56                 fp_type = FPType_Nonzero;
         57                 value    = 2.0^(UInt(exp32)-127) * (1.0 + Real(UInt(frac32)) * 2.0^-23);
         58
         59        else // N == 64
         60
         61             sign   = fpval[63];
         62             exp64 = fpval[62:52];
         63             frac64 = fpval[51:0];
         64             if IsZero(exp64) then
         65                 // Produce zero if value is zero or flush-to-zero is selected.
         66                 if IsZero(frac64) || fpscr_val.FZ == '1' then
         67                      fp_type = FPType_Zero; value = 0.0;
         68                      if !IsZero(frac64) then // Denormalized input flushed to zero
         69                          FPProcessException(FPExc_InputDenorm, fpscr_val, predicated);
         70                 else
         71                      fp_type = FPType_Nonzero;
         72                      value   = 2.0^-1022 * (Real(UInt(frac64)) * 2.0^-52);
         73             elsif IsOnes(exp64) then
         74                 if IsZero(frac64) then
         75                         fp_type = FPType_Infinity;
         76                         value   = 2.0^1000000;
         77                  else
         78                         fp_type = if frac64[51] == '1' then FPType_QNaN else FPType_SNaN;
         79                         value   = 0.0;
         80              else
         81                  fp_type = FPType_Nonzero;
         82                  value   = 2.0^(UInt(exp64)-1023) * (1.0 + Real(UInt(frac64)) * 2.0^-52);
         83
         84        if sign == '1' then value = -value;
         85        return (fp_type, sign, value);

E2.1.178 FPUnpackCV
          1   //   FPUnpackCV()
          2   //   ============
          3   //
          4   //   Used for FP <-> FP conversion instructions.
          5   //   For half-precision data ignores FZ16 and observes AHP.
          6
          7   (FPType, bit, real) FPUnpackCV(bits(N) fpval, FPSCR_Type fpscr_val)
          8       return FPUnpackCV(fpval, fpscr_val, FALSE);
          9
         10   (FPType, bit, real) FPUnpackCV(bits(N) fpval, FPSCR_Type fpscr_val, boolean predicated)
         11       fpscr_val.FZ16 = '0';
         12       return FPUnpackBase(fpval, fpscr_val, predicated);

E2.1.179 FPZero
          1   // FPZero()
          2   // ========
          3
          4   bits(N) FPZero(bit sign, integer N)
          5       assert N IN {16,32,64};
          6       integer E = if N == 16 then 5 elsif N == 32 then 8 else 11;
          7       constant integer F = N - E - 1;
          8       bits(E) exp;
          9       bits(F) frac;
         10       exp = Zeros(E);
         11       frac = Zeros(F);
         12       return sign : exp : frac;

E2.1.180 FunctionReturn
          1   // FunctionReturn()
          2   // ================
          3
          4   ExcInfo FunctionReturn()
          5       exc = DefaultExcInfo();
          6
          7        // Pull the return address and IPSR off the Secure stack
          8        mode     = CurrentMode();
          9        spName   = LookUpSP_with_security_mode(TRUE, mode);
         10        framePtr = _SP(spName);
         11        if !IsAligned(framePtr, 8) then UNPREDICTABLE;
         12        // Only stack locations, not the load order are architected
         13        RETPSR_Type newPSR;
         14        if exc.fault == NoFault then (exc, newPSR) = Stack(framePtr, 4, spName, mode);
         15        if exc.fault == NoFault then (exc, newPC) = Stack(framePtr, 0, spName, mode);
         16
         17        //   Check the IPSR value that has been unstacked is consistent with the current
         18        //   mode, and being originally called from the Secure state.
         19        //   NOTE: It is IMPLEMENTATION DEFINED whether this check is performed before
         20        //         or after the load of the return address above.
         21        if   (exc.fault == NoFault) &&
         22          !(((IPSR.Exception == 0[8:0]) && (newPSR.Exception == 0[8:0])) ||
         23            ((IPSR.Exception == 1[8:0]) && (newPSR.Exception != 0[8:0]))) then
         24           if HaveMainExt() then
         25               UFSR_S.INVPC = '1';
         26           // Create the exception. NOTE: If the Main Extension is not implemented
         27           // then the fault always escalates to a HardFault
         28           exc = CreateException(UsageFault, TRUE, TRUE);
         29       // The IPSR value is set as UNKNOWN if the IPSR value is not supported by the PE
         30       excNum = UInt(newPSR.Exception);
         31       validIPSR = excNum IN {0, 1, NMI, HardFault, SVCall, PendSV, SysTick};
         32       if !validIPSR && HaveMainExt() then
         33           validIPSR = excNum IN {MemManage, BusFault, UsageFault, SecureFault, DebugMonitor};
         34       if !validIPSR && !IsIrqValid(excNum) then
         35           newPSR.Exception = bits(9) UNKNOWN;
         36
         37       // Only consume the function return stack frame and update the XPSR/PC if no
         38       // faults occured.
         39       if exc.fault == NoFault then
         40           // Transition to the Secure state
         41           CurrentState = SecurityState_Secure;
         42           // Update stack pointer. NOTE: Stack pointer limit not checked on function
         43           // return as stack pointer guaranteed to be ascending not descending.
         44           exc = _SP(spName, FALSE, TRUE, framePtr + 8);
         45           assert exc.fault == NoFault;
         46
         47           IPSR.Exception = newPSR.Exception;
         48           CONTROL_S.SFPA = newPSR.SFPA;
         49           // IT/ICI/ECI/LOB data cleared to prevent Non-secure code interfering with
         50           // Secure execution
         51           if HaveMainExt() then
         52               ITSTATE = Zeros(8);
         53           if HaveLOBExt() then
         54               LO_BRANCH_INFO.VALID = '0';
         55           // if EPSR.T == 0, a UsageFault('Invalid State') or a HardFault is taken
         56           // on the next instruction depending on whether the Main Extension is
         57           // is implemented or not.
         58           EPSR.T = newPC[0];
         59           BranchTo(newPC[31:1]:'0');
         60       return exc;

E2.1.181 GenerateCoprocessorException
          1   // GenerateCoprocessorException()
          2   // ==============================
          3
          4   GenerateCoprocessorException()
          5       UFSR.UNDEFINSTR = '1';
          6       excInfo = CreateException(UsageFault);
          7       HandleException(excInfo);

E2.1.182 GenerateDebugEventResponse
          1   // GenerateDebugEventResponse()
          2   // ============================
          3   // Generate a debug event response based on the PE configuration.
          4
          5   GenerateDebugEventResponse(boolean isBKPT)
          6       if CanHaltOnEvent(IsSecure(), FindPriv()) then
          7           DHCSR.C_HALT = '1';
          8           if isBKPT then
          9               DFSR.BKPT = '1';
         10               // Internally generated debug events halt synchronously and terminate
         11               // the current instruction.
         12               Halt();
         13               EndOfInstruction();
         14           else
         15               DFSR.EXTERNAL = '1';
         16
         17       elsif isBKPT then
         18           // The Breakpoint debug event is set unconditionally.
         19           DFSR.BKPT = '1';
         20           // A DebugMonitor exception is generated. This exception can be escalated to
         21           // a HardFault when evaluated in ExceptionDetails().
         22           exceptionSecurity = IsSecure() || DEMCR.SDME == '1';
         23           excInfo           = CreateException(DebugMonitor, TRUE, exceptionSecurity);
         24           HandleException(excInfo);
         25
         26       elsif CanPendMonitorOnEvent(IsSecure(), TRUE, TRUE, FindPriv(), FALSE) then
         27           DFSR.EXTERNAL = '1';
         28           DEMCR.MON_PEND = '1';

E2.1.183 GenerateIntegerZeroDivide
          1   // GenerateIntegerZeroDivide()
          2   // ===========================
          3
          4   GenerateIntegerZeroDivide()
          5       UFSR.DIVBYZERO = '1';
          6       excInfo = CreateException(UsageFault);
          7       HandleException(excInfo);

E2.1.184 GetActiveChains
          1   // GetActiveChains()
          2   // ==================
          3
          4   integer GetActiveChains()
          5       count = 0;
          6       if HaveMve() then
          7           for i = 0 to MAX_OVERLAPPING_INSTRS-1
          8               if _InstInfo[i].Valid then
          9                   count = count + 1;
         10       return count;

E2.1.185 GetCurInstrBeat
          1   // GetCurInstrBeat()
          2   // =================
          3
          4   (integer, bits(4)) GetCurInstrBeat()
          5       assert HaveMve();
          6       // By default assume all lanes are active
          7       elmtMask = Ones(4);
          8
          9       // If VPT active apply the predicate flags in VPR.P0
         10       if VPTActive() then
         11           elmtMask = elmtMask AND Elem[VPR.P0, _BeatID, 4];
         12
         13       // LOB truncation may override the flags on the last iteration of a loop
         14       // LTPSIZE < 4 is a proxy for knowing if we're in a loop and tail predication is active.
         15       ltpsize = if _CurrentInstrExecState.ResetLTPSize then 4 else LTPSIZE;
         16       if ltpsize < 4 && IsLastLowOverheadLoop() then
         17           loopCount = _CurrentInstrExecState.LoopCount;
         18           predSize = ltpsize;
         19           fullMask = ZeroExtend(Ones(UInt(loopCount[4-predSize:0] : Zeros(predSize))), 16);
         20           elmtMask = elmtMask AND Elem[fullMask, _BeatID, 4];
         21       return (_BeatID, elmtMask);

E2.1.186 GetInstrExecState
          1   // GetInstrExecState()
          2   // ===================
          3
          4   INSTR_EXEC_STATE_Type GetInstrExecState(integer next)
          5       // next = 0: returns current (committed) state
          6       // next > 0: returns n-th state from now
          7       assert (next >= 0 && next < MAX_BEATS);
          8       INSTR_EXEC_STATE_Type state;
          9
         10       // 1) Next == 0: current committed state
         11       state.FetchAddr         = _RName[RNamesPC];
         12       state.ITState           = EPSR.IT;
         13       state.L                 = '0';
         14       state.T16IND            = '0';
         15       state.BTI               = '0';
         16       state.LoopCount         = LR;
         17       state.LOBranchInfoValid = LO_BRANCH_INFO.VALID;
         18       state.ResetLTPSize      = FALSE;
         19
         20       // 2) Determine speculative future
         21       for i = 1 to next
         22           // Handle normal PC changes BEFORE LOB handling
         23           if _PCChanged && i == 1 then
         24               state.FetchAddr = _NextInstrAddr;
         25           else
         26               state.FetchAddr = state.FetchAddr + ThisInstrLength(i-1);
         27
         28           // If the IT state has been directly modified return that value as the
         29           // next state, otherwise advance the IT state normally.
         30           if _ITStateChanged && i == 1 then
         31               state.ITState = _NextInstrITState;
         32           else
         33               state.ITState = ITAdvance(state.ITState);
         34
         35           // Check if loop or branch triggers PC change (unless normal PC change)
         36           if (!_PCChanged) && HaveLOBExt() then
         37               state = HandleLO(state);
         38
         39       return state;

E2.1.187 Halt
          1   // Halt()
          2   // ======
          3
          4   Halt()
          5       // Halt
          6       Halted = TRUE;
          7
          8       // Clear lockup state
          9       LockedUp = FALSE;
         10
         11       // Upon entering debug state, S_REGRDY becomes valid hence must be set to '1'.
         12       DHCSR.S_REGRDY = '1';
         13
         14       // Any pending return operation is cleared and can be re-pended on
         15       // exit from Debug State.
         16       _PendingReturnOperation = FALSE;
         17
         18       // Clear all remaining in flight instructions
         19       ClearInFlightInstructions();

E2.1.188 Halted
          1   // Indicates the PE is in Debug State
          2
          3   boolean Halted;

E2.1.189 HaltingDebugAllowed
          1   // HaltingDebugAllowed()
          2   // =====================
          3
          4   boolean HaltingDebugAllowed()
          5       return ExternalInvasiveDebugEnabled() || Halted;

E2.1.190 HandleException
          1   // HandleException()
          2   // =================
          3
          4   HandleException(ExcInfo excInfo)
          5       if excInfo.fault != NoFault then
          6           if excInfo.lockup then
          7               Lockup(excInfo.termInst);
          8           else
          9               // If the fault escalated to a HardFault update the syndrome info
         10               if HaveMainExt() && excInfo.fault == HardFault then
         11                   if excInfo.origFault == DebugMonitor then
         12                       HFSR.DEBUGEVT = '1';
         13                   elsif excInfo.origFault != HardFault then
         14                       HFSR.FORCED   = '1';
         15
         16                // If the exception does not cause a lockup set the exception pending
         17                // and potentially terminate execution of the current instruction
         18                SetPending(excInfo.fault, excInfo.isSecure, TRUE);
         19                if excInfo.termInst then
         20                    EndOfInstruction();

E2.1.191 HandleExceptionTransitions
          1   // HandleExceptionTransitions()
          2   // ============================
          3
          4   boolean HandleExceptionTransitions()
          5       // Check for, and process any exception returns that were requested. This
          6       // must be done after the instruction has completed so any exceptions
          7       // raised during the exception return do not interfere with the execution of
          8       // the instruction that cause the exception return (eg a POP causing an
          9       // excReturn value to be written to the PC must adjust SP even if the
         10       // exception return caused by the POP raises a fault).
         11       excRetFault                = FALSE;
         12       tailChainedException       = FALSE;
         13       EXC_RETURN_Type excReturn = NextInstrAddr();
         14       if _PendingReturnOperation then
         15           _PendingReturnOperation = FALSE;
         16           (excInfo, excReturn, tailChainedException) = ExceptionReturn(excReturn);
         17           // Handle any faults raised during exception return
         18           if excInfo.fault != NoFault then
         19               excRetFault = TRUE;
         20               // Either lockup, or pend the fault if it can be taken
         21               if excInfo.lockup then
         22                   // Check if the fault occurred on exception return, or whether it
         23                   // occurred during a tail chained exception entry. This is
         24                   // because Lockups on exception return have to be handled
         25                   // differently.
         26                   if !excInfo.inExcTaken then
         27                       // If the fault occurred during exception return then the
         28                       // register state is UNKNOWN. This is due to the fact that
         29                       // an unknown amount of the exception stack frame might have
         30                       // been restored.
         31                       for n = 0 to 12
         32                            R[n] = bits(32) UNKNOWN;
         33                       LR    = bits(32) UNKNOWN;
         34                           XPSR = bits(32) UNKNOWN;
         35                           if HaveMveOrFPExt() then
         36                               InvalidateFPRegs(FALSE, TRUE);
         37                           // If lockup is entered as a result of an exception return
         38                           // fault the original exception is deactivated. Therefore
         39                           // the stack pointer must be updated to consume the
         40                           // exception stack frame to keep the stack depth consistent
         41                           // with the number of active exceptions. NOTE: The XPSR SP
         42                           // alignment flag is UNKNOWN, assume is was zero.
         43                           ConsumeExcStackFrame(excReturn, '0');
         44                           // IPSR from stack is UNKNOWN, set IPSR based on mode
         45                           // specified in EXC_RETURN.
         46                           IPSR.Exception = (if excReturn.Mode == '1' then NoFault
         47                                                                      else HardFault)[8:0];
         48                           if HaveMveOrFPExt() then
         49                               CONTROL.FPCA   = NOT(excReturn.FType);
         50                               CONTROL_S.SFPA = bit UNKNOWN;
         51                       Lockup(FALSE);
         52                else
         53                       // Set syndrome if fault escalated to a HardFault
         54                       if HaveMainExt() &&
         55                          (excInfo.fault      == HardFault) &&
         56                          (excInfo.origFault != HardFault) then
         57                           HFSR.FORCED = '1';
         58                       SetPending(excInfo.fault, excInfo.isSecure, TRUE);
         59
         60       // If there is a pending exception with sufficient priority take it now.
         61       // This is done before committing PC and ITSTATE changes caused by the
         62       // previous instruction so that the committed architecture state reflects
         63       // the context the instruction was executed in.
         64       (takeException, exception, excIsSecure) = PendingExceptionDetails();
         65       if takeException then
         66           // If a fault occurred during an exception return then the exception
         67           // stack frame will already be on the stack, as a result entry to the
         68           // next exception is treated as if it were a tail chain.
         69           pePriority = ExecutionPriority();
         70           peException = UInt(IPSR.Exception);
         71           peIsSecure = IsSecure();
         72           if excRetFault then
         73               // If the fault occurred during ExceptionTaken() then LR will have
         74               // been updated with the new exception return value. To excReturn
         75               // consistent with the state of the exception stack frame we need to
         76               // use the updated version in this case. If no updates have occurred
         77               // then the excReturn value from the previous exception return is
         78               // used.
         79               if excInfo.inExcTaken then
         80                   excReturn = LR;
         81               (excInfo, excReturn) = TailChain(exception, excIsSecure, excReturn);
         82           else
         83               (excInfo, excReturn) = ExceptionEntry(exception, excIsSecure);
         84           // Handle any derived faults that have occurred
         85           if excInfo.fault != NoFault then
         86               DerivedLateArrival(pePriority, peException, peIsSecure, excInfo,
         87                                   exception, excIsSecure, excReturn);
         88
         89       return takeException || tailChainedException;

E2.1.192 HandleLO
          1   // HandleLO()
          2   // ===========
          3
          4   INSTR_EXEC_STATE_Type HandleLO(INSTR_EXEC_STATE_Type state)
          5       // The default state for the link and BTI bits is FALSE
          6       state.L   = '0';
          7       state.BTI = '0';
          8
          9       // If valid branch info matches the fetch address update the LOB state and 10       // fetch address accordingly.
         11       if state.LOBranchInfoValid == '1' then
         12           if LO_BRANCH_INFO.END_ADDR == state.FetchAddr[31:1] then
         13               state.L      = LO_BRANCH_INFO.BF AND LO_BRANCH_INFO.LF;
         14               state.T16IND = LO_BRANCH_INFO.T16IND;
         15               state.BTI    = LO_BRANCH_INFO.BTI;
         16               // Conditions for LOB handling in an IT block
         17               if InITBlock(state.ITState) then
         18                   // The BF b_label is allowed to be the last instruction in an IT block.
         19                   // As the BF branch occurs before this instruction is executed, the ITSTATE
         20                   // needs to be updated as if the end of the IT block had been reached.
         21                   if LO_BRANCH_INFO.BF == '1' then
         22                       state.ITState = Zeros(8);
         23                   else
         24                       // If LO_BRANCH_INFO is valid and a low overhead branch is handled,
         25                       // then the behavior is CONSTRAINED UNPREDICTABLE.
         26                       CONSTRAINED_UNPREDICTABLE;
         27               // Branch cache address matched, branch to offset specified
         28               if LO_BRANCH_INFO.BF == '1'                                ||
         29                  (LO_BRANCH_INFO.BF == '0' && LO_BRANCH_INFO.LF == '1') ||
         30                  !IsLastLowOverheadLoop(state) then
         31                   state.FetchAddr = LO_BRANCH_INFO.JUMP_ADDR:'0';
         32               // If the branch is due to a BF instruction invalidate the branch
         33               // info so spurious branches do not occur.
         34               if LO_BRANCH_INFO.BF == '1' then
         35                   // Clear the branch cache.
         36                   state.LOBranchInfoValid = '0';
         37               elsif LO_BRANCH_INFO.LF == '0' then
         38                   // Looping mode: Decrement the loop counter unless this is the
         39                   // last iteration, in which case looping mode is exited.
         40                   if !IsLastLowOverheadLoop(state) then
         41                       state.LoopCount = state.LoopCount - (1 << (4 - LTPSIZE))[31:0];
         42                   else
         43                       // LO_BRANCH_INFO.VALID does not need to be cleared at the end
         44                       // of the loop.
         45                       //
         46                       // Skip over LE at the end of the loop.
         47                       state.FetchAddr = state.FetchAddr + 4;
         48                       // Reset LTPSIZE if it is accessible, which will be the case
         49                       // for all predicated loops as the LETP instruction will
         50                       // have forced the state to be accessible and all operations
         51                       // that can cause the state to be inaccessible require a CSE
         52                       // which will invalidate LO_BRANCH_INFO.
         53                       if ActiveFPState() then
         54                           state.ResetLTPSize = TRUE;
         55       return state;

E2.1.193 HasArchVersion
          1   // HasArchVersion()
          2   // ================
          3
          4   // Return TRUE if the implemented architecture includes the extensions defined in the
          5   // specified architecture version.
          6
          7   boolean HasArchVersion(ArchVersion version)
          8       return version == Armv8p0 || boolean IMPLEMENTATION_DEFINED "Architecture version";

E2.1.194 HaveAlgorithmPAC
          1   // HaveAlgorithmPAC
          2   // ================
          3   // Checks which PAC algorithm is implemented by quereing ID_ISAR5.PACBTI
          4
          5   AlgorithmPAC HaveAlgorithmPAC();

E2.1.195 HaveDebugMonitor
          1   // HaveDebugMonitor()
          2   //===================
          3
          4   boolean HaveDebugMonitor()
          5       return HaveMainExt();

E2.1.196 HaveDSPExt
          1   // HaveDSPExt()
          2   // ===========
          3   // Check whether DSP Extension is implemented.
          4
          5   boolean HaveDSPExt();

E2.1.197 HaveDWT
          1   // HaveDWT()
          2   // =========
          3   // Check whether Data Watchpoint and Trace unit is implemented.
          4
          5   boolean HaveDWT();

E2.1.198 HaveFPB
          1   // HaveFPB()
          2   // =========
          3   // Check whether Flash Patch and Breakpoint unit is implemented.
          4
          5   boolean HaveFPB();

E2.1.199 HaveFPExt
          1   // HaveFPExt()
          2   // ===========
          3   // Check whether Floating Point Extension is implemented.
          4
          5   boolean HaveFPExt();

E2.1.200 HaveHaltingDebug
          1   // HaveHaltingDebug()
          2   // ==================
          3   // Check whether Halting debug implemented.
          4
          5   boolean HaveHaltingDebug();

E2.1.201 HaveITM
          1   // HaveITM()
          2   // =========
          3   // Check whether Instrumentation Trace Macrocell is implemented.
          4
          5   boolean HaveITM();

E2.1.202 HaveLOBExt
          1   // HaveLOBExt()
          2   // ============
          3   // Check whether the Low Overhead Loops and Branch Future Extension is implemented
          4
          5   boolean HaveLOBExt();

E2.1.203 HaveMainExt
          1   // HaveMainExt()
          2   // =============
          3   // Check whether the Main Extension is implemented.
          4
          5   boolean HaveMainExt();

E2.1.204 HaveMve
          1   // HaveMve()
          2   // =========
          3   // Check whether the M-profile Vector Extension is implemented
          4
          5   boolean HaveMve();

E2.1.205 HaveMveOrFPExt
          1   // HaveMveOrFPExt()
          2   // ================
          3
          4   boolean HaveMveOrFPExt()
          5       return HaveFPExt() || HaveMve();

E2.1.206 HavePACBTIExt
          1   // HavePACBTIExt()
          2   // ===============
          3   // Checks whether the PACBTI Extension is implemented
          4
          5   boolean HavePACBTIExt()
          6       return (HaveMainExt() &&
          7               HaveAlgorithmPAC() IN {AlgorithmPAC_QARMA, AlgorithmPAC_IMPDEF});

E2.1.207 HaveSecurityExt
          1   // HaveSecurityExt()
          2   // =================
          3   // Check whether the implementation has the Security Extension.
          4
          5   boolean HaveSecurityExt();

E2.1.208 HaveSysTick
          1   // HaveSysTick()
          2   // =============
          3   // Returns the number of SysTick instances (0, 1 or 2).
          4
          5   integer HaveSysTick();

E2.1.209 HaveUDE
          1   // HaveUDE()
          2   // =========
          3   // Check whether the Unprivileged Debug Extension is implemented.
          4
          5   boolean HaveUDE()

E2.1.210 HaveUnknownMemAccesses
          1   // HaveUnknownMemAccesses()
          2   //=========================
          3   // Check whether UNKNOWN memory accesses are permitted.
          4
          5   boolean HaveUnknownMemAccesses()

E2.1.211 HighestPri
          1   // HighestPri()
          2   // ============
          3   // Priority of Thread mode with no active exceptions.
          4
          5   integer HighestPri()
          6       // The value is PriorityMax + 1 = 256 (configurable priority maximum bit field is 8 bits)
          7       return 256;

E2.1.212 HighestSetBit
          1   // HighestSetBit()
          2   // ===============
          3
          4   integer HighestSetBit(bits(N) x)
          5       for i = N-1 downto 0
          6           if x[i] == '1' then return i;
          7       return -1;

E2.1.213 Hint_Debug
          1   // Hint_Debug
          2   // ==========
          3   // Generate a hint to the debug system.
          4
          5   Hint_Debug(bits(4) option);

E2.1.214 Hint_PreloadData
          1   // Hint_PreloadData
          2   // ================
          3   // Performs a preload data hint
          4
          5   Hint_PreloadData(bits(32) address);

E2.1.215 Hint_PreloadDataForWrite
          1   // Hint_PreloadDataForWrite
          2   // ========================
          3   // Performs a preload data hint for write.
          4
          5   Hint_PreloadDataForWrite(bits(32) address);

E2.1.216 Hint_PreloadInstr
          1   // Hint_PreloadInstr
          2   // =================
          3   // Performs a preload instructions hint
          4
          5   Hint_PreloadInstr(bits(32) address);

E2.1.217 Hint_Yield
          1   // Hint_Yield
          2   // ==========
          3   // Performs a Yield hint
          4
          5   Hint_Yield();

E2.1.218 IDAUCheck
          1   // IDAUCheck
          2   // =========
          3   // Query IDAU(Implementation Defined Attribution Unit) for attribution information
          4
          5   (boolean, boolean, boolean, bits(8), boolean) IDAUCheck(bits(32) address);

E2.1.219 IgnoreFaultsType
          1   // Indicates Ignore Faults Types
          2   // =============================
          3
          4   enumeration IgnoreFaultsType { IgnoreFaults_NONE,
          5                                  IgnoreFaults_STACK,
          6                                  IgnoreFaults_ALL };

E2.1.220 InITBlock
          1   // InITBlock()
          2   // ===========
          3
          4   boolean InITBlock(ITSTATEType itState)
          5       return (itState[3:0] != '0000');
          6
          7   boolean InITBlock()
          8       return InITBlock(ITSTATE);

E2.1.221 InstrCanChain
          1   // InstrCanChain()
          2   // ===============
          3
          4   boolean InstrCanChain(bits(32) instr)
          5       // Check if the instruction is a chainable instruction, and if its a
          6       // chained memory operation.
          7       isChainMem = IsMveLoadStoreInstruction(instr);
          8       canChain   = IsMveBeatWiseInstruction(instr) && !InITBlock();
          9
         10       // Memory operations cannot chain with other memory operations
         11       if canChain && isChainMem then
         12           for i = 0 to MAX_OVERLAPPING_INSTRS-1
         13               if _InstInfo[i].Valid && IsMveLoadStoreInstruction(ThisInstr(i)) then
         14                   canChain = FALSE;
         15
         16       // Scalar dependencies must be tracked.
         17       if canChain then
         18           // Get a list of registers read and written by this instruction
         19           // (these are bitstring where the index of each set bit indicates a used register)
         20           myScalarReads = GetMveScalarReadRegs(instr);
         21           myScalarWrites = GetMveScalarWriteRegs(instr);
         22           // Get a list of all registers read or written by other in-flight instructions
         23           otherScalarReads = 0[15:0];
         24           otherScalarWrites = 0[15:0];
         25           for i = 0 to MAX_OVERLAPPING_INSTRS-1
         26               if _InstInfo[i].Valid then
         27                   otherScalarReads = (otherScalarReads OR 28                                        GetMveScalarReadRegs(_InstInfo[i].Opcode));
         29                   otherScalarWrites = (otherScalarWrites OR 30                                        GetMveScalarWriteRegs(_InstInfo[i].Opcode));
         31           // Determine if there is any overlap between the registers read and written,
         32           // if so chaining is impossible.
         33           if ((myScalarReads AND otherScalarWrites) != 0[15:0]) ||
         34              ((myScalarWrites AND otherScalarReads) != 0[15:0]) then
         35               canChain = FALSE;
         36
         37       // LR chaining restrictions
         38       if (canChain                     &&
         39           _InstInfo[0].Valid           &&
         40           LO_BRANCH_INFO.VALID == '1' &&
         41           LO_BRANCH_INFO.BF == '0') then
         42           // Check if any instruction in the chain writes to LR, and get the index
         43           // of the last instruction in the chain.
         44           lastValidId = 0;
         45           lrWrite      = FALSE;
         46           for i = 0 to MAX_OVERLAPPING_INSTRS-1
         47               if _InstInfo[i].Valid then
         48                    lastValidId = i;
         49                    lrWrite = lrWrite || GetMveScalarWriteRegs(_InstInfo[i].Opcode)[14] == '1';
         50           // Do not chain the next instruction if the end of the loop body has been
         51           // reached and either one of the existing chained instructions writes to
         52           // LR, or the new instruction reads or writes to LR.
         53           instState    = GetInstrExecState(lastValidId);
         54           nextSeqAddr = instState.FetchAddr + _InstInfo[lastValidId].Length[31:0];
         55           if LO_BRANCH_INFO.END_ADDR == nextSeqAddr[31:1] then
         56               canChain = !(lrWrite                                  ||
         57                             GetMveScalarReadRegs(instr)[14] == '1' ||
         58                             GetMveScalarWriteRegs(instr)[14] == '1');
         59
         60       // Two instructions reading/writing FPSCR carry bit should not chain with each other
         61       if canChain && IsMveAccessFPSCR_C(instr) then
         62           for i = 0 to MAX_OVERLAPPING_INSTRS-1
         63               if _InstInfo[i].Valid && IsMveAccessFPSCR_C(_InstInfo[i].Opcode) then
         64                   canChain = FALSE;
         65
         66       // Branch future chaining restrictions
         67       if (canChain                     &&
         68           _InstInfo[0].Valid           &&
         69           LO_BRANCH_INFO.VALID == '1' &&
         70           LO_BRANCH_INFO.BF == '1') then
         71           // Get the index of the last instruction in the chain.
         72           lastValidId = 0;
         73           for i = 0 to MAX_OVERLAPPING_INSTRS-1
         74               if _InstInfo[i].Valid then
         75                    lastValidId = i;
         76           // Do not chain the next instruction if execution has reached a BF branch
         77           // point
         78           instState    = GetInstrExecState(lastValidId);
         79           nextSeqAddr = instState.FetchAddr + _InstInfo[lastValidId].Length[31:0];
         80           canChain     = LO_BRANCH_INFO.END_ADDR != nextSeqAddr[31:1];
         81
         82       // Implementations can choose not to chain an instruction
         83       if canChain then
         84           canChain = boolean IMPLEMENTATION_DEFINED "Chain instruction";
         85
         86       return canChain;

E2.1.222 InstrExecState
          1   // Indicates instruction execution state
          2   // =====================================
          3
          4   type INSTR_EXEC_STATE_Type is (
          5       bits(32)    FetchAddr,
          6       ITSTATEType ITState,
          7       bit         L,
          8       bit         T16IND,
          9       bit         BTI,
         10       bits(32)    LoopCount,
         11       bit         LOBranchInfoValid,
         12       boolean     ResetLTPSize
         13   )
         14   INSTR_EXEC_STATE_Type _CurrentInstrExecState;

E2.1.223 InstructionAdvance
          1   // InstructionAdvance()
          2   // ====================
          3
          4   InstructionAdvance()
          5       // Instruction getting old (or scalar instruction).
          6       // Commit next state back to the registers.
          7       INSTR_EXEC_STATE_Type next = GetInstrExecState(1);
          8       if HaveLOBExt() then
          9           if next.LOBranchInfoValid == '1' then
         10               LR = next.LoopCount;
         11           else
         12               LO_BRANCH_INFO.VALID = '0';
         13           if next.L == '1' then
         14               // Set LR to return to the return address. The offset of the
         15               // return address depends on whether the originating BF
         16               // instruction assumed there would be a T32 or a 16-bit T32
         17               // instruction after the branch point. See BF documentation for
         18               // details.
         19               retAddr = ThisInstrAddr() + ThisInstrLength();
         20               retAddr = retAddr + (if next.T16IND == '1' then 2 else 4);
         21               LR       = retAddr[31:1] : '1';
         22           if BTIEnabled() && next.BTI == '1' then
         23               // When BTI is enabled and LO_BRANCH_INFO.BTI was set by BFX (!= LR) or BFLX
         24               // then the EPSR.B bit is set to one, requiring a BTI clearing instruction at
         25               // the target address of the branch.
         26               EPSR.B = '1';
         27           if HaveMve() && next.ResetLTPSize then
         28               FPSCR.LTPSIZE = 4[2:0];
         29       _RName[RNamesPC] = next.FetchAddr;
         30       if HaveMainExt() then
         31           EPSR.IT = next.ITState;
         32
         33       // Mark an instruction as having retired
         34       DHCSR.S_RETIRE_ST = '1';
         35
         36       // Advance the instruction FIFO
         37       for i = 0 to MAX_OVERLAPPING_INSTRS-1
         38           if i == MAX_OVERLAPPING_INSTRS-1 then
         39               _InstInfo[i].Valid = FALSE;
         40           else
         41               _InstInfo[i] = _InstInfo[i+1];

E2.1.224 InstructionExecute
          1   // InstructionExecute()
          2   // ====================
          3
          4   // If fetchNew is set then fetch and execute new instructions, otherwise only
          5   // continue execution of inflight beats.
          6   boolean InstructionExecute(boolean fetchNew)
          7       try
          8           // Attempt to execute the next instruction. Start by setting up the state.
          9           _InstID                = 0;
         10           _BeatID                = 0;
         11           activeChains           = GetActiveChains();
         12           _CurrentInstrExecState = GetInstrExecState(activeChains);
         13           commitState            = FALSE;
         14           // Fetch the instruction
         15           pc                     = ThisInstrAddr();
         16           (instr, is16bit)       = FetchInstr(pc);
         17           len                    = if is16bit then 2 else 4;
         18           // Capture security and privilege
         19           isSecure = IsSecure();
         20           isPriv   = FindPriv();
         21
         22           // If a chain is being executed then the current instruction can be
         23           // added to the chain if it is chainable. If the instruction is not
         24           // chainable (eg because its a scaler instruction) then it is not
         25           // executed, and the next beat(s) of the flight chained instructions
         26           // are executed. This process is repeated on the next architecture
         27           // tick, and when the chain has completed the non-chainable
         28           // instruction can be executed.
         29           // NOTE: Chainable instructions are not allowed to chain if in an IT
         30           //       block.
         31           chainableInst = IsMveBeatWiseInstruction(instr) && !InITBlock();
         32           if HaveMve() && (chainableInst || activeChains > 0) then
         33               // A new instruction can only be chained if a power of 2 number
         34               // of beats have completed. Also allow an instruction to be
         35               // started if the ECI information indicates that an instruction
         36               // is in progress, but the corresponding slot in the instruction
         37               // queue is empty, which can occur on exception return.
         38               chainableExecPoint = (EPSR.ECI == 0[7:0]) || (EPSR.ECI == 2[7:0]);
         39               if !chainableExecPoint then
         40                   beatStatus = BeatComplete;
         41                   for instId = 0 to MAX_OVERLAPPING_INSTRS-1
         42                       if ((Elem[beatStatus, instId, MAX_BEATS] != Zeros(MAX_BEATS)) &&
         43                           !_InstInfo[instId].Valid) then
         44                           chainableExecPoint = TRUE;
         45               if chainableExecPoint && InstrCanChain(instr) && fetchNew then
         46                   SetThisInstrDetails(instr, len);
         47               commitState = ExecBeats();
         48           elsif fetchNew then
         49               // Scalar instruction, execute instructions normally.
         50               SetThisInstrDetails(instr, len);
         51               InstStateCheck(instr);
         52               DecodeExecute(instr, pc, is16bit, DefaultCond());
         53               // Scalar instructions, and MVE instructions in IT blocks do not
         54               // have beat behavior so commit straight away
         55               commitState = TRUE;
         56
         57           // Check for DWT match
         58           if IsDWTEnabled(isSecure, isPriv) then
         59               DWT_InstructionMatch(pc, isSecure, isPriv);
         60
         61       catch exn
         62           // Do not catch UNPREDICTABLE or internal errors
         63           when IsSEE(exn) || IsUNDEFINED(exn)
         64               // Unallocated instructions in the NOP hint space and instructions
         65               // that fail their condition tests are treated like NOPs.
         66               nopHint16 = instr == '000000000000000010111111xxxx0000';
         67               nopHint32 = (instr == '111100111010111110000000xxxxxxxx') && HaveMainExt();
         68               if ConditionHolds(CurrentCond()) && !(nopHint16 || nopHint32) then
         69                   commitState = FALSE;
         70                   toSecure    = IsSecure();
         71                   // Unallocated instructions in the coprocessor space behave as NOCP
         72                   // if the coprocessor is disabled.
         73                       (isCp, cpNum) = IsCPInstruction(instr);
         74                       if isCp then
         75                           (cpEnabled, cpFaultState) = IsCPEnabled(cpNum);
         76                       if isCp && !cpEnabled then
         77                           // A PE is permitted to decode the coprocessor space and raise
         78                           // UNDEFINSTR UsageFaults for unallocated encodings even if the
         79                           // coprocessor is disabled.
         80                           if boolean IMPLEMENTATION_DEFINED "Decode CP space" then
         81                                UFSR.UNDEFINSTR = '1';
         82                           else
         83                                toSecure         = cpFaultState;
         84                                if toSecure then
         85                                    UFSR_S.NOCP = '1';
         86                                else
         87                                    UFSR_NS.NOCP = '1';
         88                       else
         89                           UFSR.UNDEFINSTR = '1';
         90
         91                       // If Main Extension is not implemented the fault will escalate
         92                       // to a HardFault.
         93                       excInfo = CreateException(UsageFault, TRUE, toSecure);
         94                       // Prevent EndOfInstruction() being called in
         95                       // HandleException() as the instruction has already been
         96                       // terminated so there is no need to throw the exception
         97                       // again.
         98                       excInfo.termInst = FALSE;
         99                       HandleException(excInfo);
        100                else
        101                   // If the instruction condition does not pass then this
        102                   // behaves as a NOP, as such PC must be advanced. Since
        103                   // vector instructions are not chained (thus only one
        104                   // instruction is in flight) when inside an IT
        105                   // block, they are also committed here.
        106                   commitState = TRUE;
        107           when IsExceptionTaken(exn)
        108               // If an exception is thrown then it was before commitState was
        109               // set to true, so no additional actions are required in this
        110               // catch block.
        111
        112       return commitState;

E2.1.225 InstructionsInFlight
          1   // InstructionsInFlight()
          2   // ======================
          3
          4   boolean InstructionsInFlight()
          5       // If there is more than one active chain and it is not just a single active
          6       // scalar instruction then there are instructions in flight
          7       return GetActiveChains() != 0 && (GetActiveChains() != 1 ||
          8                                         IsMveBeatWiseInstruction(_InstInfo[0].Opcode));

E2.1.226 InstructionSynchronizationBarrier
          1   // InstructionSynchronizationBarrier()
          2   // ===================================
          3   // Perform an instruction synchronization barrier operation
          4
          5   InstructionSynchronizationBarrier(bits(4) option);

E2.1.227 InstStateCheck
          1   // InstStateCheck()
          2   // ================
          3
          4   InstStateCheck(bits(32) instr)
          5       // Check for IT,ICI,ECI bits that are not permitted for the current
          6       // instruction. NOTE EPSR.ICI and EPSR.ECI overlap with EPSR.IT.
          7       validICI = (EPSR.ICI[7:6] == Zeros(2) && EPSR.ICI[1:0] == Zeros(2));
          8       validECI = UInt(EPSR.ECI) < 6 && EPSR.ECI[3:0] != '0011';
          9       valid    = ( InITBlock()                                          ||
         10                    EPSR.IT == Zeros(8)                                  ||
         11                    (validICI && (IsLoadStoreClearMultInstruction(instr) ||
         12                                  IsBKPTInstruction(instr)))             ||
         13                    (validECI && (IsMveBeatWiseInstruction(instr)        ||
         14                                  IsLEInstruction(instr)                 ||
         15                                  IsBKPTInstruction(instr))) );
         16       if !valid then
         17           UFSR.INVSTATE = '1';
         18           excInfo = CreateException(UsageFault);
         19           HandleException(excInfo);

E2.1.228 Int
          1   // Int()
          2   // =====
          3
          4   integer Int(bits(N) x, boolean unsigned)
          5       result = if unsigned then UInt(x) else SInt(x);
          6       return result;

E2.1.229 IntegerZeroDivideTrappingEnabled
          1   // IntegerZeroDivideTrappingEnabled()
          2   // ==================================
          3
          4   boolean IntegerZeroDivideTrappingEnabled()
          5       // DIV_0_TRP bit in CCR is RAZ/WI if Main Extension is not implemented
          6       return CCR.DIV_0_TRP == '1';

E2.1.230 InvalidateFPRegs
          1   // InvalidateFPRegs()
          2   // ==================
          3
          4   InvalidateFPRegs(boolean shouldClear, boolean doCallee)
          5       clearValue = if shouldClear then Zeros(32) else bits(32) UNKNOWN;
          6
          7       for i = 0 to 15
          8           S[i]                     = clearValue;
          9           if doCallee then S[i+16] = clearValue;
         10       FPSCR = clearValue;
         11       VPR   = clearValue;

E2.1.231 InVPTBlock
          1   // InVPTBlock()
          2   // ===========
          3
          4   boolean InVPTBlock()
          5       if _BeatID IN {0, 1} then
          6            return VPR.MASK01 != '0000';
          7       else
          8            return VPR.MASK23 != '0000';

E2.1.232 IsAccessible
          1   // IsAccessible()
          2   // ==============
          3
          4   (bit, bit, bits(8), boolean) IsAccessible(bits(32) address, boolean forceunpriv,
          5                                             boolean isSecure)
          6       bit write;
          7       bit read;
          8
          9       // Work out which privilege level the current mode in the Non-secure state
         10       // is subject to
         11       if forceunpriv then
         12            isPrivileged = FALSE;
         13       else
         14            isPrivileged = CurrentModeIsPrivileged(isSecure);
         15       (-, perms) = MPUCheck(address, AccType_NORMAL, isPrivileged, isSecure);
         16       if !perms.apValid then
         17            write = '0';
         18            read = '0';
         19       else
         20            case perms.ap of
         21                when '00' (write, read) = if isPrivileged then ('1','1') else ('0','0');
         22                when '01' (write, read) = ('1','1') ;
         23                when '10' (write, read) = if isPrivileged then ('0','1') else ('0','0');
         24                when '11' (write, read) = ('0','1');
         25       return (write, read, perms.region, perms.regionValid);

E2.1.233 IsActiveForState
          1   // IsActiveForState()
          2   // ==================
          3
          4   boolean IsActiveForState(integer exception, boolean isSecure)
          5       if !HaveSecurityExt() then
          6            isSecure = FALSE;
          7       // If the exception is configurable then check which domain it
          8       // currently targets. If it is not configurable then the active flags can be
          9       // used directly.
         10       if IsExceptionTargetConfigurable(exception) then
         11            // The active bit for exceptions that are not banked between the security
         12            // states are modelled as two bits to be compatible with the other exceptions
         13            // that have a bit for each security state.
         14            assert ExceptionActive[exception][0] == ExceptionActive[exception][1];
         15            active = ((ExceptionActive[exception][0] == '1') &&
         16                      (ExceptionTargetsSecure(exception, isSecure) == isSecure));
         17       else
         18            idx    = if isSecure then 0 else 1;
         19            active = ExceptionActive[exception][idx] == '1';
         20       return active;

E2.1.234 IsAligned
          1   // IsAligned()
          2   // ===========
          3
          4   boolean IsAligned(bits(32) address, integer size)
          5       assert size IN {1,2,4,8};
          6       mask = (size-1)[31:0];                  // integer to bit string conversion
          7       return IsZero(address AND mask);

E2.1.235 IsBKPTInstruction
          1   // IsBKPTInstruction()
          2   // ===================
          3   // Checks whether the instruction is a breakpoint
          4
          5   boolean IsBKPTInstruction(bits(32) instr)
          6       return instr == '0000 0000 0000 0000 1011 1110 xxxxxxxx';

E2.1.236 IsCPEnabled
          1   // IsCPEnabled()
          2   // ================
          3
          4   (boolean, boolean) IsCPEnabled(integer cp, boolean privileged, boolean secure)
          5       // Check Coprocessor Access Control Register for permission to use coprocessor
          6       boolean enabled;
          7       boolean forceToSecure = FALSE;
          8
          9       cpacr = if secure then CPACR_S else CPACR_NS;
         10       case cpacr[(cp*2)+1:cp*2] of
         11           when '00'
         12               enabled = FALSE;
         13           when '01'
         14               enabled = privileged;
         15           when '10'
         16               UNPREDICTABLE;
         17           when '11' // access permitted by CPACR
         18               enabled = TRUE;
         19
         20       if enabled && HaveSecurityExt() then
         21           // Check if access is forbidden by NSACR
         22           if !secure && NSACR[cp] == '0' then
         23               enabled       = FALSE;
         24               forceToSecure = TRUE;
         25
         26       // Check if the coprocessor state unknown flag.
         27       if enabled && CPPWR_S[cp*2] == '1' then
         28           enabled = FALSE;
         29           // Check SUS bit to determine the target state of any fault
         30           forceToSecure = CPPWR_S[(cp*2)+1] == '1';
         31
         32       return (enabled, secure || forceToSecure);
         33
         34   (boolean, boolean) IsCPEnabled(integer cp)
         35       return IsCPEnabled(cp, CurrentModeIsPrivileged(), IsSecure());

E2.1.237 IsCPInstruction
          1   // IsCPInstruction()
          2   // =================
          3
          4   (boolean, integer) IsCPInstruction(bits(32) instr)
          5       isCp = instr IN { '111x1110xxxxxxxxxxxxxxxxxxxxxxxx',
          6                          '111x110xxxxxxxxxxxxxxxxxxxxxxxxx' };
          7       cpNum = if isCp then UInt(instr[11:8]) else integer UNKNOWN;
          8       // CP 11 controlled by CP10 enables.
          9       // As of v8.1 CP8, 9, 14 and 15 are also controlled by CP10 enables.
         10       if ( cpNum IN {11} ||
         11            (cpNum IN {8, 9, 14, 15} && HasArchVersion(Armv8p1)) ) then
         12           cpNum = 10;
         13       // From v8.1 the encoding space outside the CDP space used by MVE instructions
         14       // is also classed as coprocessor space and is associated with CP10.
         15       if instr IN { '111x1111xxxxxxxxxxxxxxxxxxxxxxxx'} && HasArchVersion(Armv8p1) then
         16           isCp = TRUE;
         17           cpNum = 10;
         18       return (isCp, cpNum);

E2.1.238 IsDebugState
          1   // IsDebugState
          2   // =============
          3
          4   boolean IsDebugState()
          5       return Halted;

E2.1.239 IsDWTConfigUnpredictable
          1   //   IsDWTConfigUnpredictable()
          2   //   =========================
          3   //   Checks for some of the UNPREDICTABLE cases for various combination of MATCH and 4   //   ACTION for each comparator.
          5
          6   boolean IsDWTConfigUnpredictable(integer N)
          7
          8        no_trace = (!HaveMainExt() || DWT_CTRL.NOTRCPKT == '1' || !HaveITM());
          9
         10        // First pass check of MATCH field - coarse checks
         11        case DWT_FUNCTION[N].MATCH of
         12            when '0000'                            // Disabled
         13                return FALSE;
         14            when '0001'                            // Cycle counter match
         15                if (!HaveMainExt()                ||
         16                    DWT_CTRL.NOCYCCNT      == '1' ||
         17                    DWT_FUNCTION[N].ID[0] == '0') then
         18                    return TRUE;
         19            when '001x'                            // Instruction address
         20                if (DWT_FUNCTION[N].ID[1]      == '0' ||
         21                    DWT_FUNCTION[N].DATAVSIZE != '01' ||
         22                    DWT_COMP[N][0]             == '1') then
         23                    return TRUE;
         24            when '01xx'                            // Data address
         25                mask = (1 << UInt(DWT_FUNCTION[N].DATAVSIZE)) -1;
         26                if (DWT_FUNCTION[N].ID[3] == '0' ||
         27                   ((DWT_COMP[N][3:0] AND mask[3:0]) != '0000')) then
         28                    return TRUE;
         29            when '1100', '1101', '1110'            // Data address with value
         30                if no_trace then return TRUE;
         31                mask = (1 << UInt(DWT_FUNCTION[N].DATAVSIZE)) -1;
         32                if (DWT_FUNCTION[N].ID[3] == '0' ||
         33                   ((DWT_COMP[N][3:0] AND mask[3:0]) != '0000')) then
         34                    return TRUE;
         35            when '10xx'                            // Data value
         36                Vsize = 2^UInt(DWT_FUNCTION[N].DATAVSIZE);
         37                if (!HaveMainExt() || DWT_FUNCTION[N].ID[2] == '0'            ||
         38                    (Vsize != 4 && DWT_COMP[N][31:16] != DWT_COMP[N][15:0]) ||
         39                    (Vsize == 1 && DWT_COMP[N][15:8] != DWT_COMP[N][7:0])) then
         40                    return TRUE;
         41                if (HasArchVersion(Armv8p1)                                      &&
         42                    (!IsZero(DWT_VMASK[N] AND DWT_COMP[N])                       ||
         43                      (Vsize != 4 && DWT_VMASK[N][31:16] != DWT_VMASK[N][15:0]) ||
         44                      (Vsize == 1 && DWT_VMASK[N][15:8] != DWT_VMASK[N][7:0]))) then
         45                    return TRUE;
         46            otherwise
         47                return TRUE;
         48
         49        // Second pass MATCH check - linked and limit comparators
         50        case DWT_FUNCTION[N].MATCH of
         51            when '0011'                            // Instruction address limit
         52                if N == 0 then return TRUE;
         53                elsif (DWT_FUNCTION[N].ID[4] == '0'                                            ||
         54                        DWT_FUNCTION[N-1].MATCH IN {'0001','0011','01xx','1xxx'}               ||
         55                        UInt(DWT_COMP[N]) <= UInt(DWT_COMP[N-1])) then
         56                        return TRUE;
         57                if DWT_FUNCTION[N-1].MATCH == '0000' then return FALSE;
         58            when '0111'                            // Data address limit
         59                if N == 0 then return TRUE;
         60                elsif (DWT_FUNCTION[N].ID[4] == '0'                                            ||
         61                        DWT_FUNCTION[N-1].MATCH IN {'0001','001x','0111','10xx'}               ||
         62                       DWT_FUNCTION[N].DATAVSIZE != '00'                        ||
         63                       DWT_FUNCTION[N-1].DATAVSIZE != '00'                      ||
         64                       UInt(DWT_COMP[N]) <= UInt(DWT_COMP[N-1])) then
         65                       return TRUE;
         66               if DWT_FUNCTION[N-1].MATCH == '0000' then return FALSE;
         67           when '1011'                            // Linked data value
         68               if N == 0 then return TRUE;
         69               elsif (DWT_FUNCTION[N].ID[4] == '0'                              ||
         70                       DWT_FUNCTION[N-1].MATCH IN {'0001','001x','0111','10xx'} ||
         71                       DWT_FUNCTION[N].DATAVSIZE != DWT_FUNCTION[N-1].DATAVSIZE) then
         72                       return TRUE;
         73               if DWT_FUNCTION[N-1].MATCH == '0000' then return FALSE;
         74           otherwise
         75               // No limitations in second pass
         76
         77       // Check DATAVSIZE is permitted
         78       if DWT_FUNCTION[N].DATAVSIZE == '11' then return TRUE;
         79
         80       // Check the ACTION is allowed for the MATCH type
         81       case DWT_FUNCTION[N].ACTION of
         82           when '00'                              // CMPMATCH trigger only
         83               if DWT_FUNCTION[N].MATCH IN {'1100', '1101', '1110'} then
         84                   return TRUE;
         85           when '01'                              // Debug event
         86               if DWT_FUNCTION[N].MATCH IN {'0011', '0111', '1100', '1101', '1110'} then
         87                   return TRUE;
         88           when '10'                              // Data Trace Match or Data Value packet
         89               if no_trace || DWT_FUNCTION[N].MATCH IN {'0011', '0111'} then
         90                   return TRUE;
         91           when '11'                              // Other Data Trace packet
         92               if N == 0 then return TRUE;
         93               if (no_trace || DWT_FUNCTION[N].MATCH IN {'0010', '1000', '1001', '1010'} ||
         94                   (DWT_FUNCTION[N].MATCH == '0011' && DWT_FUNCTION[N-1].ACTION != '00') ||
         95                   (DWT_FUNCTION[N].MATCH == '0111' && DWT_FUNCTION[N-1].MATCH == '01xx' &&
         96                     DWT_FUNCTION[N-1].ACTION IN {'01', '10'})                             ||
         97                   (DWT_FUNCTION[N].MATCH == '0111' && DWT_FUNCTION[N-1].MATCH == '11xx' &&
         98                     DWT_FUNCTION[N-1].ACTION IN {'00', '01'})) then
         99                   return TRUE;
        100
        101       return FALSE;                                        // Passes checks

E2.1.240 IsDWTEnabled
          1   // IsDWTEnabled()
          2   // ==============
          3   // Check whether DWT is enabled.
          4
          5   boolean IsDWTEnabled(boolean isSecure, boolean isPriv)
          6       return ( HaveDWT() && DEMCR.TRCENA == '1' &&
          7                ((!isSecure && NoninvasiveDebugAllowed(isPriv)) ||
          8                  SecureNoninvasiveDebugAllowed(isPriv)) );

E2.1.241 IsExceptionTargetConfigurable
          1   // IsExceptionTargetConfigurable()
          2   // ===============================
          3
          4   boolean IsExceptionTargetConfigurable(integer e)
          5       if HaveSecurityExt() then
          6           case e of
          7               when NMI
          8                   configurable = TRUE;
          9               when BusFault
         10                   configurable = TRUE;
         11               when DebugMonitor
         12                   configurable = TRUE;
         13               when SysTick
         14                     // If there is only 1 SysTick instance then the target domain is
         15                     // configurable.
         16                     configurable = HaveSysTick() == 1;
         17                 otherwise
         18                     // Exceptions numbers lower than 16 that are not listed in this
         19                     // function are not configurable in this context.
         20                     configurable = e >= 16;
         21        else
         22            configurable = FALSE;
         23        return configurable;

E2.1.242 IsExclusiveGlobal
          1   //   IsExclusiveGlobal
          2   //   =================
          3   //   Checks if PE has marked in a global record an address range as "exclusive access
          4   //   requested" that covers at least the size bytes from address
          5
          6   boolean IsExclusiveGlobal(bits(32) address, integer processorid, integer size);

E2.1.243 IsExclusiveLocal
          1   //   IsExclusiveLocal
          2   //   ================
          3   //   Checks if PE has marked in a local record an address range as "exclusive access
          4   //   requested" that covers at least the size bytes from address
          5
          6   boolean IsExclusiveLocal(bits(32) address, integer processorid, integer size);

E2.1.244 IsFirstBeat
          1   // IsFirstBeat()
          2   // ============
          3
          4   boolean IsFirstBeat()
          5       return _BeatID == 0;

E2.1.245 IsIrqValid
          1   //   IsIrqValid()
          2   //   ============
          3   //   Check whether given exception number denotes a valid external interrupt
          4   //   implemented by PE.
          5
          6   boolean IsIrqValid(integer e);

E2.1.246 IsLastBeat
          1   // IsLastBeat()
          2   // ============
          3
          4   boolean IsLastBeat()
          5       return _BeatID >= (MAX_BEATS - 1);

E2.1.247 IsLastLowOverheadLoop
          1   // IsLastLowOverheadLoop()
          2   // =======================
          3
          4   boolean IsLastLowOverheadLoop()
          5       return IsLastLowOverheadLoop(_CurrentInstrExecState);
          6
          7   boolean IsLastLowOverheadLoop(INSTR_EXEC_STATE_Type state)
          8       // This does not check whether a loop is currently active.
          9       // If the PE were in a loop, would this be the last one?
         10       return UInt(state.LoopCount) <= (1 << (4 - LTPSIZE));

E2.1.248 IsLEInstruction
          1   // IsLEInstruction()
          2   // =================
          3   // Checks whether the instruction is a loop end instruction
          4
          5   boolean IsLEInstruction(bits(32) instr)
          6       isLE = instr IN {'1111000000xx11111100xxxxxxxxxxx1'};
          7       return isLE;

E2.1.249 IsLoadStoreClearMultInstruction
          1   // IsLoadStoreClearMultInstruction()
          2   // =================================
          3   // Checks whether the instruction is a clear multiple or a load / store multiple
          4
          5   boolean IsLoadStoreClearMultInstruction(bits(32) instr)
          6       isLSCM = instr IN {'00000000000000001100xxxxxxxxxxxx',                   //   LDM_T1,STM_T1
          7                           '00000000000000001011x10xxxxxxxxx',                  //   LDM_T3,STM_T2, and aliases
          8                           '1110100xx0xxxxxxxxxxxxxxxxxxxxxx',                  //   Load/store/clear mul Scalar
          9                           '1110110xxxxxxxxxxxxx101xxxxxxxxx'};                 //   Load/store/clear mul FP
         10       // False positives due to the masks used in isLSCM
         11       notLSCM = instr IN {'1110100000xxxxxxxxxxxxxxxxxxxxxx',                  //   UNALLOCATED
         12                           '1110100110xxxxxxxxxxxxxxxxxxxxxx',                  //   UNALLOCATED
         13                           '11101100010xxxxxxxxx101x00x1xxxx',                  //   UNALLOCATED
         14                           '11101100010xxxxxxxxx101xxxx0xxxx',                  //   UNALLOCATED
         15                           '11101100000xxxxxxxxx101xxxxxxxxx',                  //   UNALLOCATED
         16                           '111011011x1xxxxxxxxx101xxxxxxxxx'};                 //   VMOV
         17       return (isLSCM && !notLSCM);

E2.1.250 IsOnes
          1   // IsOnes()
          2   // ========
          3
          4   boolean IsOnes(bits(N) x)
          5       return x == Ones(N);

E2.1.251 IsPPB
          1   // IsPPB()
          2   // =======
          3
          4   boolean IsPPB(bits(32) address)
          5       return address[31:20] == 0xE00[11:0];

E2.1.252 IsReqExcPriNeg
          1   // IsReqExcPriNeg()
          2   // ================
          3
          4   boolean IsReqExcPriNeg(boolean secure)
          5       // This function checks if the requested execution priority is negative for
          6       // the specified security domain. That is, NMI or HardFault is active, or 7       // FAULTMASK is set. It does not take account of AIRCR.PRIS so returns TRUE
          8       // if FAULTMASK_NS is set even if PRIS is set to restrict Non-secure priorities
          9       // to the range 0x80-0x7E
         10       neg = IsActiveForState(NMI, secure) || IsActiveForState(HardFault, secure);
         11       if HaveMainExt() then
         12           faultmask = if secure then FAULTMASK_S else FAULTMASK_NS;
         13           if faultmask.FM == '1' then
         14               neg = TRUE;
         15       return neg;
         16
         17
         18   boolean IsReqExcPriNeg(boolean secure, AccType acctype)
         19       // If the access is due to lazy FP state preservation the FPCCR flag
         20       // indicating whether a HardFault could be taken is used to determine if the
         21       // priority should be considered to be negative rather than the current
         22       // execution priority.
         23       if acctype == AccType_LAZYFP then
         24            neg = FPCCR_S.HFRDY == '0';
         25       else
         26            neg = IsReqExcPriNeg(secure);
         27       return neg;

E2.1.253 IsReturn
          1   // IsReturn()
          2   // ==========
          3
          4   AddrType IsReturn(bits(32) address)
          5       addrtype = AddrType_NORMAL;
          6
          7       if (HaveSecurityExt() && address=='1111 1110 1111 1111 1111 1111 1111 111x') then
          8           addrtype = AddrType_FNC_RETURN;
          9
         10       elsif CurrentMode() == PEMode_Handler && address[31:24] == '11111111' then
         11           addrtype = AddrType_EXC_RETURN;
         12       return addrtype;

E2.1.254 IsSCS
          1   // IsSCS()
          2   // =======
          3
          4   boolean IsSCS(bits(32) address)
          5       return ( (address[31:12] == 0xE000E[19:0]) ||
          6                (address[31:12] == 0xE002E[19:0]) );

E2.1.255 IsSecure
          1   // IsSecure()
          2   // ==========
          3
          4   boolean IsSecure()
          5       return HaveSecurityExt() && CurrentState == SecurityState_Secure;

E2.1.256 IsZero
          1   // IsZero()
          2   // ========
          3
          4   boolean IsZero(bits(N) x)
          5       return x == Zeros(N);

E2.1.257 IsZeroBit
          1   // IsZeroBit()
          2   // ===========
          3
          4   bit IsZeroBit(bits(N) x)
          5       return if IsZero(x) then '1' else '0';

E2.1.258 ITAdvance
          1   // ITAdvance()
          2   // ===========
          3
          4   ITSTATEType ITAdvance(ITSTATEType itState)
          5       // If the mask field (in other words the bottom 4 bits) are zero then the ITSTATE bits
          6       // hold ECI information and therefore the normal state advancement should
          7       // not take place.
          8       if itState[3:0] == '1000' then
          9           itState = '00000000';
         10       elsif itState[3:0] != '0000' then
         11           itState[4:0] = LSL(itState[4:0], 1);
         12       return itState;

E2.1.259 ITSTATE
          1   // ITSTATE
          2   // =======
          3
          4   ITSTATEType ITSTATE
          5       return ThisInstrITState();
          6
          7   ITSTATE = ITSTATEType value
          8       // Writes to ITSTATE do not take effect immediately, instead they change the
          9       // value returned by NextInstrITState().
         10       _NextInstrITState = value;
         11       _ITStateChanged   = TRUE;

E2.1.260 ITSTATEType
          1   // If-Then execution state bits for the T32 IT instruction.
          2
          3   type ITSTATEType = bits(8);

E2.1.261 LastInITBlock
          1   // LastInITBlock()
          2   // ===============
          3
          4   boolean LastInITBlock()
          5       return (ITSTATE[3:0] == '1000');

E2.1.262 LoadWritePC
          1   // LoadWritePC()
          2   // =============
          3
          4   LoadWritePC(bits(32) address, integer baseReg, bits(32) baseRegVal, boolean baseRegUpdate,
          5               boolean spLimCheck, boolean setBti)
          6
          7       if baseRegUpdate then
          8           oldBaseVal = R[baseReg];
          9           if spLimCheck then
         10               RSPCheck[baseReg] = baseRegVal;
         11           else
         12               R[baseReg]        = baseRegVal;
         13
         14       // Attempt to update the PC, which may result in a fault
         15       excInfo = BranchReturn(address, FALSE, setBti);
         16
         17       if baseRegUpdate && excInfo.fault != NoFault then
         18           // Restore the previous base reg value, SP limit checking is not performed
         19           if baseReg == 13 then
         20               exc = _SP(LookUpRName(baseReg), FALSE, TRUE, oldBaseVal);
         21               assert exc.fault == NoFault;
         22           else
         23               R[baseReg] = oldBaseVal;
         24
         25       HandleException(excInfo);
         26
         27   LoadWritePC(bits(32) address, integer baseReg, bits(32) baseRegVal, boolean baseRegUpdate,
         28               boolean spLimCheck)
         29       LoadWritePC(address, baseReg, baseRegVal, baseRegUpdate, spLimCheck, FALSE);

E2.1.263 LockedUp
          1   // Indicates the PE is locked up
          2
          3   boolean LockedUp;

E2.1.264 Lockup
          1   // Lockup()
          2   // ========
          3
          4   Lockup(boolean termInst)
          5       LockedUp = TRUE;
          6       // Branch to the lockup address.
          7       BranchTo(0xEFFFFFFE[31:0], TRUE, FALSE);
          8       // Invalidate the instruction buffer and set the length of the current
          9       // instruction to zero so NextInstrAddr() reports the correct lockup
         10       // address.
         11       ClearInFlightInstructions();
         12       // If requested, terminate execution of the pseudo code for this
         13       // instruction.
         14       if termInst then
         15           EndOfInstruction();

E2.1.265 LookUpRName
          1   // LookUpRName()
          2   // =============
          3
          4   RNames LookUpRName(integer n)
          5       case n of
          6           when 0 result = RNames0;
          7           when 1 result = RNames1;
          8           when 2 result = RNames2;
          9           when 3 result = RNames3;
         10           when 4 result = RNames4;
         11           when 5 result = RNames5;
         12           when 6 result = RNames6;
         13           when 7 result = RNames7;
         14           when 8 result = RNames8;
         15           when 9 result = RNames9;
         16           when 10 result = RNames10;
         17           when 11 result = RNames11;
         18           when 12 result = RNames12;
         19           when 13 result = LookUpSP();
         20           when 14 result = RNamesLR;
         21           when 15 result = RNamesPC;
         22           otherwise assert(FALSE);
         23       return result;

E2.1.266 LookUpSP
          1   // LookUpSP()
          2   // ==========
          3
          4   RNames LookUpSP()
          5       return LookUpSP_with_security_mode(IsSecure(), CurrentMode());

E2.1.267 LookUpSP_with_security_mode
          1   // LookUpSP_with_security_mode()
          2   // =============================
          3
          4   RNames LookUpSP_with_security_mode(boolean isSecure, PEMode mode)
          5       RNames sp;
          6       bit spSel;
          7
          8       // Get the SPSEL bit corresponding to the Security state requested
          9       if isSecure then
         10            spSel = CONTROL_S.SPSEL;
         11       else
         12            spSel = CONTROL_NS.SPSEL;
         13
         14       // Determine which stack pointer should be used
         15       if spSel == '1' && mode == PEMode_Thread then
         16            if isSecure then
         17                sp = RNamesSP_Process_Secure;
         18            else
         19                sp = RNamesSP_Process_NonSecure;
         20       else
         21            if isSecure then
         22                sp = RNamesSP_Main_Secure;
         23            else
         24                sp = RNamesSP_Main_NonSecure;
         25       return sp;

E2.1.268 LookUpSPLim
          1   // LookUpSPLim()
          2   // =============
          3
          4   bits(32) LookUpSPLim(RNames spreg)
          5       case spreg of
          6           when RNamesSP_Main_Secure    limit = MSPLIM_S.LIMIT:'000';
          7           when RNamesSP_Process_Secure limit = PSPLIM_S.LIMIT:'000';
          8           when RNamesSP_Main_NonSecure
          9               limit = if HaveMainExt() then MSPLIM_NS.LIMIT:'000' else Zeros(32);
         10           when RNamesSP_Process_NonSecure
         11               limit = if HaveMainExt() then PSPLIM_NS.LIMIT:'000' else Zeros(32);
         12           otherwise
         13               assert (FALSE);
         14
         15       return limit;

E2.1.269 LowestSetBit
          1   // LowestSetBit()
          2   // ==============
          3
          4   integer LowestSetBit(bits(N) x)
          5       for i = 0 to N-1
          6           if x[i] == '1' then return i;
          7       return N;

E2.1.270 LR
          1   // LR
          2   // ==
          3
          4   // Non-assignment form
          5   bits(32) LR
          6       return RName[RNamesLR];
          7
          8   // Assignment form
          9
         10   LR = bits(32) value
         11       RName[RNamesLR] = value;

E2.1.271 LSL
          1   // LSL()
          2   // =====
          3
          4   bits(N) LSL(bits(N) x, integer shift)
          5       assert shift >= 0;
          6       if shift == 0 then
          7            result = x;
          8       else
          9            (result, -) = LSL_C(x, shift);
         10       return result;

E2.1.272 LSL_C
          1   // LSL_C()
          2   // =======
          3
          4   (bits(N), bit) LSL_C(bits(N) x, integer shift)
          5       assert shift > 0;
          6       extended_x = x : Zeros(shift);
          7       result = extended_x[N-1:0];
          8       carry_out = extended_x[N];
          9       return (result, carry_out);
         10
         11   (bits(N), bits(M)) LSL_C(bits(N) x, bits(M) carry_in, integer shift)
         12       assert shift > 0 && shift <= M;
         13       cin        = LSL(carry_in, M - shift);
         14       extended_x = LSL(Zeros(M) : x : cin, shift);
         15       result     = extended_x[N+ M-1:M ];
         16       carry_out = extended_x[N+2*M-1:N+M];
         17       return (result, carry_out);

E2.1.273 LSR
          1   // LSR()
          2   // =====
          3
          4   bits(N) LSR(bits(N) x, integer shift)
          5       assert shift >= 0;
          6       if shift == 0 then
          7            result = x;
          8       else
          9            (result, -) = LSR_C(x, shift);
         10       return result;

E2.1.274 LSR_C
          1   // LSR_C()
          2   // =======
          3
          4   (bits(N), bit) LSR_C(bits(N) x, integer shift)
          5       assert shift > 0;
          6       extended_x = ZeroExtend(x, shift+N);
          7       result = extended_x[shift+N-1:shift];
          8       carry_out = extended_x[shift-1];
          9       return (result, carry_out);

E2.1.275 LTPSIZE
          1   // LTPSIZE - non-assignment form
          2   // ===============================
          3
          4   integer LTPSIZE
          5       if HaveMve() && ActiveFPState() then
          6            size = UInt(FPSCR.LTPSIZE);
          7       else
          8            // Full vector length, so no loop tail predication
          9            size = 4;
         10       return size;

E2.1.276 MAIRDecode
          1   // MAIRDecode()
          2   // ============
          3
          4   MemoryAttributes MAIRDecode(bits(8) attrfield, bits(2) sh)
          5       // Converts the MAIR attributes to orthogonal attribute and 6       // hint fields.
          7       MemoryAttributes memattrs;
          8       // Decoding MAIR0/MAIR1 Registers
          9       if attrfield[7:4] == '0000' then
         10            unpackinner = FALSE;
         11            memattrs.memtype = MemType_Device;
         12            memattrs.shareable = TRUE;
         13            memattrs.outershareable = TRUE;
         14            memattrs.innerattrs = bits(2) UNKNOWN;
         15            memattrs.outerattrs = bits(2) UNKNOWN;
         16            memattrs.innerhints = bits(2) UNKNOWN;
         17            memattrs.outerhints = bits(2) UNKNOWN;
         18            memattrs.innertransient = boolean UNKNOWN;
         19            memattrs.outertransient = boolean UNKNOWN;
         20            case attrfield[3:0] of
         21                when '0000' memattrs.device = DeviceType_nGnRnE;
         22                when '0100' memattrs.device = DeviceType_nGnRE;
         23                when '1000' memattrs.device = DeviceType_nGRE;
         24                when '1100' memattrs.device = DeviceType_GRE;
         25                otherwise UNPREDICTABLE;
         26       else
         27            unpackinner = TRUE;
         28            memattrs.memtype = MemType_Normal;
         29            memattrs.device = DeviceType UNKNOWN;
         30            memattrs.outerhints = attrfield[5:4];
         31            memattrs.shareable = sh[1] == '1';
         32            memattrs.outershareable = sh == '10';
         33            if sh == '01' then UNPREDICTABLE;
         34
         35           if attrfield[7:6] =='00' then
         36               memattrs.outerattrs = '10';
         37               memattrs.outertransient = TRUE;
         38           elsif attrfield[7:6] =='01' then
         39               if attrfield[5:4] == '00' then
         40                        memattrs.outerattrs = '00';
         41                        memattrs.outertransient = FALSE;
         42                 else
         43                        memattrs.outerattrs = '11';
         44                        memattrs.outertransient = TRUE;
         45            else
         46                memattrs.outerattrs = attrfield[7:6];
         47                memattrs.outertransient = FALSE;
         48        if unpackinner then
         49            if attrfield[3:0] == '0000' then UNPREDICTABLE;
         50            else
         51                if attrfield[3:2] =='00' then
         52                    memattrs.innerattrs    = '10';
         53                    memattrs.innerhints    = attrfield[1:0];
         54                    memattrs.innertransient = TRUE;
         55                elsif attrfield[3:2] =='01' then
         56                    memattrs.innerhints    = attrfield[1:0];
         57                    if attrfield[1:0] == '00' then
         58                         memattrs.innerattrs = '00';
         59                         memattrs.innertransient = FALSE;
         60                    else
         61                         memattrs.innerattrs = '11';
         62                         memattrs.innertransient = TRUE;
         63                elsif attrfield[3:2] =='10' then
         64                    memattrs.innerhints    = attrfield[1:0];
         65                    memattrs.innerattrs    = '10';
         66                    memattrs.innertransient = FALSE;
         67                elsif attrfield[3:2] =='11' then
         68                    memattrs.innerhints    = attrfield[1:0];
         69                    memattrs.innerattrs    = '11';
         70                    memattrs.innertransient = FALSE;
         71                else UNPREDICTABLE;
         72        return memattrs;

E2.1.277 MarkExclusiveGlobal
          1   //   MarkExclusiveGlobal
          2   //   ===================
          3   //   Records in a global record that PE has requested "exclusive access" covering
          4   //   at least size bytes from the address
          5
          6   MarkExclusiveGlobal(bits(32) address, integer processorid, integer size);

E2.1.278 MarkExclusiveLocal
          1   //   MarkExclusiveLocal
          2   //   ==================
          3   //   Records in a local record that PE has requested "exclusive access" covering
          4   //   at least size bytes from the address.
          5
          6   MarkExclusiveLocal(bits(32) address, integer processorid, integer size);

E2.1.279 Max
          1   // Max()
          2   // =====
          3
          4   integer Max(integer a, integer b)
          5       return if a >= b then a else b;
          6
          7   real Max(real a, real b)
          8       return if a >= b then a else b;

E2.1.280 MaxExceptionNum
          1   // MaxExceptionNum()
          2   // =================
          3   // Returns the maximum exception number supported
          4
          5   integer MaxExceptionNum()
          6       if HaveMainExt() then
          7            return 511;
          8       else
          9            return 47;

E2.1.281 MemA
          1   // MemA[]
          2   // ======
          3
          4   bits(8*size) MemA[bits(32) address, integer size]
          5       return MemA_with_priv[address, size, FindMemPriv(), TRUE];
          6
          7   MemA[bits(32) address, integer size] = bits(8*size) value
          8       MemA_with_priv[address, size, FindMemPriv(), TRUE] = value;
          9       return;

E2.1.282 MemA_MVE
          1   // MemA_MVE[]
          2   // ==========
          3
          4   // Non-assignment form
          5
          6   bits(8*size) MemA_MVE[bits(32) address, integer size]
          7       (excInfo, value) = MemA_with_priv_security(address, size, AccType_MVE,
          8                                                  FindMemPriv(), IsSecure(), TRUE);
          9       HandleException(excInfo);
         10       return value;
         11
         12
         13   // Assignment form
         14
         15   MemA_MVE[bits(32) address, integer size] = bits(8*size) value
         16       excInfo = MemA_with_priv_security(address, size, AccType_MVE, FindMemPriv(),
         17                                         IsSecure(), TRUE, value);
         18       HandleException(excInfo);

E2.1.283 MemA_with_priv
          1   // MemA_with_priv[]
          2   // ================
          3
          4   // Non-assignment form
          5
          6   bits(8*size) MemA_with_priv[bits(32) address, integer size, Privilege privileged,
          7                               boolean aligned]
          8       (excInfo, value) = MemA_with_priv_security(address, size, AccType_NORMAL,
          9                                                  privileged, IsSecure(), aligned);
         10       HandleException(excInfo);
         11       return value;
         12
         13   // Assignment form
         14
         15   MemA_with_priv[bits(32) address, integer size, Privilege privileged,
         16                  boolean aligned] = bits(8*size) value
         17       excInfo = MemA_with_priv_security(address, size, AccType_NORMAL, privileged,
         18                                         IsSecure(), aligned, value);
         19       HandleException(excInfo);

E2.1.284 MemA_with_priv_security
          1   // MemA_with_priv_security()
          2   // =========================
          3
          4   // Non-assignment form
          5
          6   (ExcInfo, bits(8*size)) MemA_with_priv_security(bits(32) address, integer size,
          7                                                   AccType acctype, Privilege privileged,
          8                                                   boolean secure, boolean aligned)
          9       // Check alignment
         10       excInfo = DefaultExcInfo();
         11       if !IsAligned(address, size) then
         12           if HaveMainExt() then
         13               if secure then
         14                    UFSR_S.UNALIGNED = '1';
         15               else
         16                    UFSR_NS.UNALIGNED = '1';
         17           // Create the exception. NOTE: If Main Extension is not implemented the fault
         18           // always escalates to a HardFault
         19           excInfo = CreateException(UsageFault, TRUE, secure);
         20
         21       // Check permissions and get attributes
         22       if excInfo.fault == NoFault then
         23           (excInfo, memaddrdesc) = ValidateAddress(address,                      acctype,
         24                                                    privileged == Privilege_Priv, secure,
         25                                                    FALSE,                        aligned);
         26
         27       if excInfo.fault == NoFault then
         28           // Memory array access, and sort out endianness
         29           (error, value) = _Mem(memaddrdesc, size);
         30
         31           if privileged == Privilege_ForcedUnpriv then
         32               dwtPriv = CurrentModeIsPrivileged(secure);
         33           else
         34               dwtPriv = privileged == Privilege_Priv;
         35
         36           // Check if a synchronous BusFault occurred. NOTE: asynchronous BusFaults are handled
         37           // in RaiseAsyncBusFault()
         38           if error then
         39               value = bits(8*size) UNKNOWN;
         40               if HaveMainExt() then
         41                   case acctype of
         42                       when AccType_VECTABLE
         43                           HFSR.VECTTBL = '1';
         44                           excInfo = CreateException(HardFault, TRUE, AIRCR.BFHFNMINS == '0');
         45                       when AccType_STACK
         46                           BFSR.UNSTKERR = '1';
         47                           excInfo = CreateException(BusFault, FALSE, secure);
         48                       when AccType_NORMAL, AccType_MVE, AccType_ORDERED
         49                           BFAR.ADDRESS   = address;
         50                           BFSR.BFARVALID = '1';
         51                           BFSR.PRECISERR = '1';
         52                           // Generate BusFault exception if it cannot be ignored.
         53                           if !IsReqExcPriNeg(secure) || (CCR.BFHFNMIGN == '0') then
         54                               excInfo = CreateException(BusFault, FALSE, secure);
         55                       otherwise
         56                           // Some access types do not call this function
         57                           assert(FALSE);
         58
         59           // Check for Watchpoint Match
         60           elsif (IsDWTEnabled(secure, dwtPriv) &&
         61                 (acctype != AccType_VECTABLE       ||
         62                 !boolean IMPLEMENTATION_DEFINED "Ignore Vector table fetch")) then
         63               // Instructions with the access type unprivileged access the DWT with the current
         64               // privilege mode, for other accesses the access type specifies the privilege.
         65               bits(32) dvalue = ZeroExtend(value);
         66               DWT_DataMatch(address, size, dvalue, TRUE, !secure, dwtPriv);
         67
         68           if BigEndian(address, size) then
         69               value = BigEndianReverse(value, size);
         70
         71       return (excInfo, value);
         72
         73   // Assignment form
         74
         75   ExcInfo MemA_with_priv_security(bits(32) address, integer size, AccType acctype,
         76                                    Privilege privileged, boolean secure, boolean aligned,
         77                                    bits(8*size) value)
         78       // Check alignment
         79       excInfo = DefaultExcInfo();
         80       if !IsAligned(address, size) then
         81           if HaveMainExt() then
         82               if secure then
         83                    UFSR_S.UNALIGNED = '1';
         84               else
         85                    UFSR_NS.UNALIGNED = '1';
         86           // Create the exception. NOTE: If Main Extension is not implemented the fault
         87           // always escalates to a HardFault
         88           excInfo = CreateException(UsageFault, TRUE, secure);
         89
         90       // Check permissions and get attributes
         91       if excInfo.fault == NoFault then
         92           (excInfo, memaddrdesc) = ValidateAddress(address,                      acctype,
         93                                                    privileged == Privilege_Priv, secure,
         94                                                    TRUE,                         aligned);
         95
         96       if excInfo.fault == NoFault then
         97           // Effect on exclusives
         98           if memaddrdesc.memattrs.shareable then
         99               ClearExclusiveByAddress(memaddrdesc.paddress,
        100                                       ProcessorID(), size);                    // see Note
        101
        102           // Sort out endianness, then memory array access
        103           if BigEndian(address, size) then
        104               value = BigEndianReverse(value, size);
        105
        106           // Check for Watchpoint Match
        107           if privileged == Privilege_ForcedUnpriv then
        108               dwtPriv = CurrentModeIsPrivileged(secure);
        109           else
        110               dwtPriv = privileged == Privilege_Priv;
        111           if IsDWTEnabled(secure, dwtPriv) then
        112               // Instructions with the access type unprivileged access the DWT with the current
        113               // privilege mode, for other accesses the access type specifies the privilege.
        114               bits(32) dvalue = ZeroExtend(value);
        115               DWT_DataMatch(address, size, dvalue, FALSE, !secure, dwtPriv);
        116
        117           if _Mem(memaddrdesc, size, value) then
        118               // Synchronous BusFault occurred. NOTE: Asynchronous BusFaults are handled
        119               // in RaiseAsyncBusFault()
        120               if HaveMainExt() then
        121                   case acctype of
        122                       when AccType_STACK
        123                           BFSR.STKERR     = '1';
        124                           excInfo         = CreateException(BusFault, FALSE, secure);
        125                       when AccType_LAZYFP
        126                           BFSR.LSPERR     = '1';
        127                           excInfo         = CreateException(BusFault, FALSE, secure);
        128                       when AccType_NORMAL, AccType_MVE, AccType_ORDERED
        129                           BFAR.ADDRESS    = address;
        130                           BFSR.BFARVALID = '1';
        131                           BFSR.PRECISERR = '1';
        132                           // Generate BusFault exception if it cannot be ignored.
        133                           if !IsReqExcPriNeg(secure) || (CCR.BFHFNMIGN == '0') then
        134                               excInfo = CreateException(BusFault, FALSE, secure);
        135                       otherwise
        136                           // Some access types do not call this function
        137                               assert(FALSE);
        138       return excInfo;

E2.1.285 MemD_with_priv_security
          1   // MemD_with_priv_security()
          2   // =========================
          3
          4   // Non-assignment form
          5   (boolean, bits(8*size)) MemD_with_priv_security(AddressDescriptor attr, integer size)
          6       // Debugger accesses always specify their required privilege/security levels,
          7       // but can be demoted.
          8       (secure, privileged, error) = DAPCheck(attr.paddress, attr.accattrs.ispriv,
          9                                              !attr.memattrs.NS, attr.accattrs.iswrite);
         10
         11       if !error then
         12           (excInfo, memaddrdesc) = ValidateAddress(attr.paddress, AccType_DBG,
         13                                                    privileged, secure,
         14                                                    attr.accattrs.iswrite,
         15                                                    IsAligned(attr.paddress, size));
         16
         17           if (secure && DHCSR.S_SUIDE == '0') || (!secure && DHCSR.S_NSUIDE == '0') then
         18               // Inherit memory attributes from IMPDEF debugger interface if not
         19               // accessed via UDE. The debugger-specified security attributes (NS-Req) is
         20               // replaced by the NS-Attr obtained from the SAU/IDAU.
         21               memNS                        = memaddrdesc.memattrs.NS;
         22               memaddrdesc.memattrs         = attr.memattrs;
         23               memaddrdesc.accattrs.acctype = attr.accattrs.acctype;
         24               memaddrdesc.memattrs.NS      = memNS;
         25
         26           error = (excInfo.fault != NoFault);
         27       if !error then
         28           (error, value) = _Mem(memaddrdesc, size);
         29       if error then
         30           value = bits(8*size) UNKNOWN;
         31
         32       // No exception is generated here since the debugger should not be able to cause
         33       // exceptions in the PE. Instead, the caller should check against NoFault and return
         34       // that information to the debugger.
         35       return (error, value);
         36
         37
         38   // Assignment form
         39   boolean MemD_with_priv_security(AddressDescriptor attr, integer size, bits(8*size) value)
         40       // Debugger accesses always specify their required privilege/security levels,
         41       // but can be demoted.
         42       (secure, privileged, error) = DAPCheck(attr.paddress,
         43                                              attr.accattrs.ispriv,
         44                                              !attr.memattrs.NS,
         45                                              attr.accattrs.iswrite);
         46
         47       if !error then
         48           (excInfo, memaddrdesc) = ValidateAddress(attr.paddress,
         49                                                    AccType_DBG,
         50                                                    privileged,
         51                                                    secure,
         52                                                    attr.accattrs.iswrite,
         53                                                    IsAligned(attr.paddress, size));
         54
         55           if (secure && DHCSR.S_SUIDE == '0') || (!secure && DHCSR.S_NSUIDE == '0') then
         56               // Inherit memory attributes from IMPDEF debugger interface if not
         57               // accessed through the UDE. The debugger-specified security attributes
         58               // (NS-Req) is replaced by the NS-Attr obtained from the SAU/IDAU.
         59               memNS                        = memaddrdesc.memattrs.NS;
         60               memaddrdesc.memattrs         = attr.memattrs;
         61               memaddrdesc.accattrs.acctype = attr.accattrs.acctype;
         62               memaddrdesc.memattrs.NS      = memNS;
         63
         64           error = (excInfo.fault != NoFault);
         65       if !error then
         66           error = _Mem(memaddrdesc, size, value);
         67
         68       // No exception is generated here since the debugger should not be able to cause
         69       // exceptions in the PE. Instead, the caller should check against NoFault and return
         70       // that information to the debugger.
         71       return error;

E2.1.286 MemI
          1   // MemI()
          2   // ======
          3
          4   bits(16) MemI[bits(32) address]
          5       // Check permissions and get attributes
          6       // NOTE: The privilege flag passed to ValidateAddress may be overriden if
          7       //       the security of the memory is different from the current security
          8       //       state, for example when performing a Non-secure to Secure function call.
          9       (excInfo, memaddrdesc) = ValidateAddress(address, AccType_IFETCH, FindPriv(),
         10                                                IsSecure(), FALSE, TRUE);
         11       if excInfo.fault == NoFault then
         12           (error, value) = _Mem(memaddrdesc, 2);
         13           if error then
         14               value = bits(16) UNKNOWN;
         15               BFSR.IBUSERR = '1';
         16               // Create the exception. NOTE: If Main Extension is not implemented the fault
         17               // always escalates to a HardFault
         18               excInfo = CreateException(BusFault);
         19       HandleException(excInfo);
         20       if IsDWTEnabled(IsSecure(), FindPriv()) then
         21           DWT_InstructionMatch(address, IsSecure(), FindPriv());
         22       return value;

E2.1.287 MemO
          1   // MemO[] - non-assignment form
          2   // ============================
          3
          4   bits(8*size) MemO[bits(32) address, integer size]
          5       (excInfo, value) = MemA_with_priv_security(address, size, AccType_ORDERED,
          6                                                  FindMemPriv(), IsSecure(), TRUE);
          7       HandleException(excInfo);
          8       return value;
          9
         10
         11   // MemO[] - assignment form
         12   // ========================
         13
         14   MemO[bits(32) address, integer size] = bits(8*size) value
         15       excInfo = MemA_with_priv_security(address, size, AccType_ORDERED, FindMemPriv(),
         16                                         IsSecure(), TRUE, value);
         17       HandleException(excInfo);

E2.1.288 MemoryAttributes
          1   // v8-M Memory Attributes
          2   type MemoryAttributes is (
          3       MemType memtype,
          4       DeviceType device,            //   For Device memory
          5       bits(2) innerattrs,           //   The possible encodings for        each attributes field are:
          6       bits(2) outerattrs,           //   '00' = Non-cacheable; '01'        = RESERVED
          7                                     //   '10' = Write-Through; '11'        = Write-Back
          8       bits(2) innerhints,           //   The possible encodings for        the hints are as follows
          9       bits(2) outerhints,           //   '00' = No-Allocate; '01' =        Write-Allocate
         10                                  // '10' = Read-Allocate; '11' = Read-Allocate and Write-Allocate
         11        boolean   NS,             // TRUE if Non-secure, else FALSE
         12        boolean   innertransient,
         13        boolean   outertransient,
         14        boolean   shareable,
         15        boolean   outershareable
         16   )

E2.1.289 MemType
          1   // Types of memory
          2
          3   enumeration MemType {MemType_Normal, MemType_Device};

E2.1.290 MemU
          1   // MemU[]
          2   // ======
          3
          4   // Non-assignment form, used for memory reads
          5   // ==========================================
          6
          7   bits(8*size) MemU[bits(32) address, integer size]
          8       if HaveMainExt() then
          9            return MemU_with_priv[address, size, FindMemPriv()];
         10       else
         11            return MemA[address, size];
         12
         13
         14   // Assignment form, used for memory writes
         15   // =======================================
         16
         17   MemU[bits(32) address, integer size] = bits(8*size) value
         18       if HaveMainExt() then
         19            MemU_with_priv[address, size, FindMemPriv()] = value;
         20       else
         21            MemA[address, size] = value;
         22       return;

E2.1.291 MemU_unpriv
          1   // MemU_unpriv[]
          2   // =============
          3
          4   // Non-assignment form
          5
          6   bits(8*size) MemU_unpriv[bits(32) address, integer size]
          7       return MemU_with_priv[address, size, Privilege_ForcedUnpriv];
          8
          9   // Assignment form
         10
         11   MemU_unpriv[bits(32) address, integer size] = bits(8*size) value
         12       MemU_with_priv[address, size, Privilege_ForcedUnpriv] = value;
         13       return;

E2.1.292 MemU_with_priv
          1   //   MemU_with_priv[]
          2   //   ================
          3   //   Due to single-copy atomicity constraints, the aligned accesses are distinguished from
          4   //   the unaligned accesses:
          5   //   * Aligned accesses are performed at their size.
          6   //   * Unaligned accesses are expressed as a set of bytes.
          7
          8   // Non-assignment form
          9
         10   bits(8*size) MemU_with_priv[bits(32) address, integer size, Privilege privileged]
         11
         12       bits(8*size) value;
         13       // Do aligned access, take alignment fault, or do sequence of bytes
         14       if address == Align(address, size) then
         15           value = MemA_with_priv[address, size, privileged, TRUE];
         16       elsif CCR.UNALIGN_TRP == '1' then
         17           UFSR.UNALIGNED = '1';
         18           excInfo = CreateException(UsageFault);
         19           HandleException(excInfo);
         20       else // if unaligned access
         21           for i = 0 to size-1
         22               value[8*i+7:8*i] = MemA_with_priv[address+i, 1, privileged, FALSE];
         23           if BigEndian(address, size) then
         24               value = BigEndianReverse(value, size);
         25
         26       return value;
         27
         28   // Assignment form
         29
         30   MemU_with_priv[bits(32) address, integer size, Privilege privileged] = bits(8*size) value
         31
         32       // Do aligned access, take alignment fault, or do sequence of bytes
         33       if address == Align(address, size) then
         34           MemA_with_priv[address, size, privileged, TRUE] = value;
         35       elsif CCR.UNALIGN_TRP == '1' then
         36           UFSR.UNALIGNED = '1';
         37           excInfo = CreateException(UsageFault);
         38           HandleException(excInfo);
         39       else // if unaligned access
         40           if BigEndian(address, size) then
         41               value = BigEndianReverse(value, size);
         42           for i = 0 to size-1
         43               MemA_with_priv[address+i, 1, privileged, FALSE] = value[8*i+7:8*i];
         44
         45       return;

E2.1.293 MergeExcInfo
          1   // MergeExcInfo()
          2   // ==============
          3
          4   ExcInfo MergeExcInfo(ExcInfo a, ExcInfo b)
          5       // The ExcInfo structure is used to determine which exception should be
          6       // taken, and how it should be handled (mainly in the case of derived
          7       // exceptions).
          8       if     (b.fault == NoFault) || (a.isTerminal && !b.isTerminal) then
          9            exc = a;
         10       elsif (a.fault == NoFault) || (b.isTerminal && !a.isTerminal) then
         11            exc = b;
         12       elsif (a.fault == b.fault) && (a.isSecure == b.isSecure) then
         13            exc = a;
         14       else
         15            // Propagate the fault with the highest priority (lowest numerical
         16            // value).
         17            aPri = ExceptionPriority(a.fault, a.isSecure, FALSE);
         18            bPri = ExceptionPriority(b.fault, b.isSecure, FALSE);
         19
         20           // Compare the exception priority values. Exception with the highest priority, which
         21           // is the lowest numerical value, is taken and the other exception may be pended.
         22           if aPri < bPri then
         23               exc = a;
         24               pend = b;
         25           elsif bPri < aPri then
         26               exc = b;
         27               pend = a;
         28              // If both priority values are equal, the exception numbers are compared.
         29              // The exception with the lowest exception number is taken and the other
         30              // exception may be pended.
         31              elsif a.fault < b.fault then
         32                  exc = a;
         33                  pend = b;
         34              elsif b.fault < a.fault then
         35                  exc = b;
         36                  pend = a;
         37              // If the two exception number are equal, the Secure exception is taken and the
         38              // Non-secure exception may be pended.
         39              elsif a.isSecure && !b.isSecure then
         40                  exc = a;
         41                  pend = b;
         42              // In any other case exception (b) is taken and exception (a) is pended.
         43              else
         44                  exc = b;
         45                  pend = a;
         46
         47              //
                         It is IMPLEMENTATION_DEFINED whether all exceptions generated are visible or not.
         48              //
                         If visible, the highest priority exception will become active and lower priority
         49              //
                         exceptions will get pended.
         50              boolean IMPLEMENTATION_DEFINED "Overridden exceptions pended" then
                         if
         51               SetPending(pend.fault, pend.isSecure, TRUE);
         52       return exc;

E2.1.294 Min
          1   // Min()
          2   // =====
          3
          4   integer Min(integer a, integer b)
          5       return if a <= b then a else b;
          6
          7   real Min(real a, real b)
          8       return if a <= b then a else b;

E2.1.295 MPUCheck
          1   // MPUCheck()
          2   // ==========
          3
          4   (MemoryAttributes, Permissions) MPUCheck(bits(32) address, AccType acctype,
          5       boolean ispriv, boolean secure)
          6
          7       assert(HaveSecurityExt() || !secure);
          8       MemoryAttributes attributes;
          9       Permissions       perms;
         10       attributes = DefaultMemoryAttributes(address);
         11       perms       = DefaultPermissions(address);
         12       // assume no valid MPU region and not using system address map
         13       hit         = FALSE;
         14       mpuCtrl     = if secure then MPU_CTRL_S else MPU_CTRL_NS;
         15
         16       // Determine what MPU permissions should apply based on access type and MPU
         17       // configuration
         18       if acctype == AccType_VECTABLE || IsPPB(address) then
         19           hit = TRUE;      // use system addess map for PPB and vector table lookups
         20       elsif acctype == AccType_DBG && secure && DHCSR.S_SUIDE == '0' then
         21           hit = TRUE;      // use the debugger-provided memory attributes
         22       elsif acctype == AccType_DBG && !secure && DHCSR.S_NSUIDE == '0' then
         23           hit = TRUE;      // use the debugger-provided memory attributes
         24       elsif mpuCtrl.ENABLE == '0' then
         25           if mpuCtrl.HFNMIENA == '1' then UNPREDICTABLE;
         26           else hit = TRUE; // always use system address map if MPU disabled
         27       elsif mpuCtrl.HFNMIENA == '0' && IsReqExcPriNeg(secure, acctype) then
         28           hit = TRUE;      // optionally use default for HardFault, NMI and FAULTMASK.
         29       else     // MPU is enabled so check each individual region
         30              if (mpuCtrl.PRIVDEFENA == '1') && ispriv then
         31                  hit = TRUE; // optional default as background for Privileged accesses
         32
         33              regionMatched = FALSE;
         34              mpuType        = if secure then MPU_TYPE_S else MPU_TYPE_NS;
         35              for r = 0 to (UInt(mpuType.DREGION) - 1)
         36                  if secure then
         37                       rbar = __MPU_RBAR_S[r];
         38                       rlar = __MPU_RLAR_S[r];
         39                  else
         40                       rbar = __MPU_RBAR_NS[r];
         41                       rlar = __MPU_RLAR_NS[r];
         42
         43                  // MPU region enabled so perform checks
         44                  if rlar.EN == '1' then
         45                      if ((UInt(address) >= UInt(rbar.BASE : '00000')) &&
         46                          (UInt(address) <= UInt(rlar.LIMIT : '11111'))) then
         47                          // flag error if multiple regions match
         48                          if regionMatched then
         49                               perms.regionValid = FALSE;
         50                               perms.region      = Zeros(8);
         51                               hit               = FALSE;
         52                          else
         53                               regionMatched     = TRUE;
         54                               perms.ap          = rbar.AP;
         55                               if (rbar.XN == '1') || (ispriv && (rlar.PXN == '1')) then
         56                                   perms.xn = '1';
         57                               else
         58                                   perms.xn = '0';
         59                               perms.region      = r[7:0];
         60                               perms.regionValid = TRUE;
         61                               hit               = TRUE;
         62                               sh                = rbar.SH;
         63
         64                            // parsing MAIR0/1 Register fields
         65                            index         = UInt(rlar.AttrIndx);
         66                            mair          = (if secure then MPU_MAIR1_S : MPU_MAIR0_S else
         67                                                            MPU_MAIR1_NS : MPU_MAIR0_NS);
         68                            attrfield     = mair[8*index+7:8*index];
         69                            // decoding MAIR0/1 field and populating memory attributes
         70                            attributes    = MAIRDecode(attrfield, sh);
         71
         72       // MVE accesses to device memory are relaxed to GRE
         73       if acctype == AccType_MVE && attributes.memtype == MemType_Device then
         74           attributes.device = DeviceType_GRE;
         75       if address[31:29] == '111' then // enforce System space execute never
         76           perms.xn = '1';
         77       if !hit then // Access not allowed if there is no MPU match and use
         78                     // of the default address map is disabled.
         79           perms.apValid = FALSE;
         80       return (attributes, perms);

E2.1.296 NextInstrAddr
          1   // NextInstrAddr()
          2   // ===============
          3
          4   bits(32) NextInstrAddr()
          5       return GetInstrExecState(1).FetchAddr;

E2.1.297 NextInstrITState
          1   // NextInstrITState()
          2   // ==================
          3
          4   ITSTATEType NextInstrITState()
          5       if HaveMainExt() then
          6            nextState = GetInstrExecState(1).ITState;
          7       else
          8            nextState = Zeros(8);
          9       return nextState;

E2.1.298 NoninvasiveDebugAllowed
          1   // NoninvasiveDebugAllowed()
          2   // =========================
          3
          4   boolean NoninvasiveDebugAllowed(boolean isPriv)
          5       if ExternalNoninvasiveDebugEnabled() then
          6            return TRUE;
          7       elsif (!isPriv && UnprivHaltingDebugEnabled(FALSE)) then
          8            return TRUE;
          9       elsif HaltingDebugAllowed() then
         10            return TRUE;
         11       else
         12            return FALSE;
         13
         14
         15   boolean NoninvasiveDebugAllowed()
         16       return NoninvasiveDebugAllowed(CurrentModeIsPrivileged());

E2.1.299 Ones
          1   // Ones()
          2   // ======
          3
          4   bits(N) Ones(integer N)
          5       return Replicate('1',N);
          6
          7   bits(N) Ones()
          8       return Ones(N);

E2.1.300 PACCellInvShuffle
          1   // PACCellInvShuffle()
          2   // ===================
          3
          4   bits(64) PACCellInvShuffle(bits(64) inData)
          5       bits(64) outData;
          6       outData[3:0] = inData[15:12];
          7       outData[7:4] = inData[27:24];
          8       outData[11:8] = inData[51:48];
          9       outData[15:12] = inData[39:36];
         10       outData[19:16] = inData[59:56];
         11       outData[23:20] = inData[47:44];
         12       outData[27:24] = inData[7:4];
         13       outData[31:28] = inData[19:16];
         14       outData[35:32] = inData[35:32];
         15       outData[39:36] = inData[55:52];
         16       outData[43:40] = inData[31:28];
         17       outData[47:44] = inData[11:8];
         18       outData[51:48] = inData[23:20];
         19       outData[55:52] = inData[3:0];
         20       outData[59:56] = inData[43:40];
         21       outData[63:60] = inData[63:60];
         22       return outData;

E2.1.301 PACCellShuffle
          1   // PACCellShuffle()
          2   // ================
          3
          4   bits(64) PACCellShuffle(bits(64) inData)
          5       bits(64) outData;
          6       outData[3:0] = inData[55:52];
          7       outData[7:4] = inData[27:24];
          8       outData[11:8] = inData[47:44];
          9       outData[15:12] = inData[3:0];
         10       outData[19:16] = inData[31:28];
         11       outData[23:20] = inData[51:48];
         12       outData[27:24] = inData[7:4];
         13       outData[31:28] = inData[43:40];
         14       outData[35:32] = inData[35:32];
         15       outData[39:36] = inData[15:12];
         16       outData[43:40] = inData[59:56];
         17       outData[47:44] = inData[23:20];
         18       outData[51:48] = inData[11:8];
         19       outData[55:52] = inData[39:36];
         20       outData[59:56] = inData[19:16];
         21       outData[63:60] = inData[63:60];
         22       return outData;

E2.1.302 PACEnabled
          1   // PACEnabled()
          2   // ============
          3   // Check whether PAC is enabled.
          4
          5   boolean PACEnabled()
          6       enabled = FALSE;
          7       // The PACBTI Extension must be implemented in order to use PAC functionality.
          8       if HavePACBTIExt() then
          9           if CurrentModeIsPrivileged() then
         10               pacEn = CONTROL.PAC_EN; // Current Security state privileged PAC enabled
         11           else
         12               pacEn = CONTROL.UPAC_EN; // Current Security state unprivileged PAC enabled
         13
         14           if pacEn == '1' then enabled = TRUE;
         15
         16       return enabled;

E2.1.303 PACInvSub
          1   // PACInvSub()
          2   // ===========
          3
          4   bits(64) PACInvSub(bits(64) Tinput)
          5       // This is a 4-bit substitution from the PRINCE-family cipher
          6
          7       bits(64) Toutput;
          8       for i = 0 to 15
          9           case Tinput[4*i+3:4*i] of
         10               when '0000' Toutput[4*i+3:4*i]             =   '0101';
         11               when '0001' Toutput[4*i+3:4*i]             =   '1110';
         12               when '0010' Toutput[4*i+3:4*i]             =   '1101';
         13               when '0011' Toutput[4*i+3:4*i]             =   '1000';
         14               when '0100' Toutput[4*i+3:4*i]             =   '1010';
         15               when '0101' Toutput[4*i+3:4*i]             =   '1011';
         16               when '0110' Toutput[4*i+3:4*i]             =   '0001';
         17               when '0111' Toutput[4*i+3:4*i]             =   '1001';
         18               when '1000' Toutput[4*i+3:4*i]             =   '0010';
         19               when '1001' Toutput[4*i+3:4*i]             =   '0110';
         20               when '1010' Toutput[4*i+3:4*i]             =   '1111';
         21               when '1011' Toutput[4*i+3:4*i]             =   '0000';
         22               when '1100' Toutput[4*i+3:4*i]             =   '0100';
         23               when '1101' Toutput[4*i+3:4*i]             =   '1100';
         24               when '1110'        Toutput[4*i+3:4*i] = '0111';
         25               when '1111'        Toutput[4*i+3:4*i] = '0011';
         26       return Toutput;

E2.1.304 PACKey
          1   // PACKey[]
          2   // ========
          3
          4   // Non-assignment forms
          5
          6   bits(128) PACKey[boolean isSecure, boolean isPriv]
          7       if isSecure then
          8            key = if isPriv then PAC_KEY_P_S else PAC_KEY_U_S;
          9       else
         10            key = if isPriv then PAC_KEY_P_NS else PAC_KEY_U_NS;
         11       return key;
         12
         13   bits(32) PACKeyReg[bits(3) index, boolean isSecure]
         14       // Access PAC_KEY_U if index[2] is 0, otherwise PAC_KEY_P
         15       return Elem[PACKey[isSecure, index[2] == '0'], UInt(index[1:0]), 32];
         16
         17
         18   // Assignment forms
         19
         20   PACKey[boolean isSecure,       boolean isPriv] = bits(128) value
         21       if isSecure then
         22            if isPriv then
         23                PAC_KEY_P_S       = value;
         24            else
         25                PAC_KEY_U_S       = value;
         26       else
         27            if isPriv then
         28                PAC_KEY_P_NS      = value;
         29            else
         30                PAC_KEY_U_NS      = value;
         31
         32   PACKeyReg[bits(3) index, boolean isSecure] = bits(32) value
         33       // Access PAC_KEY_U if index[2] is 0, otherwise PAC_KEY_P
         34       Elem[PACKey[isSecure, index[2] == '0'], UInt(index[1:0]), 32] = value;

E2.1.305 PACKeys
          1   bits(128)   PAC_KEY_P_S;
          2   bits(128)   PAC_KEY_P_NS;
          3   bits(128)   PAC_KEY_U_S;
          4   bits(128)   PAC_KEY_U_NS;

E2.1.306 PACMult
          1   // PACMult()
          2   // =========
          3
          4   bits(64) PACMult(bits(64) Sinput)
          5       bits(4) t0;
          6       bits(4) t1;
          7       bits(4) t2;
          8       bits(4) t3;
          9       bits(64) Soutput;
         10
         11       for i = 0 to 3
         12           t0[3:0] = (RotCell(Sinput[4*(i+8)+3:4*(i+8)], 1) EOR
         13                      RotCell(Sinput[4*(i+4)+3:4*(i+4)], 2));
         14           t0[3:0] = t0[3:0] EOR RotCell(Sinput[4*(i)+3:4*(i)], 1);
         15           t1[3:0] = (RotCell(Sinput[4*(i+12)+3:4*(i+12)], 1) EOR
         16                       RotCell(Sinput[4*(i+4)+3:4*(i+4)], 1));
         17           t1[3:0] = t1[3:0] EOR RotCell(Sinput[4*(i)+3:4*(i)], 2);
         18           t2[3:0] = (RotCell(Sinput[4*(i+12)+3:4*(i+12)], 2) EOR
         19                       RotCell(Sinput[4*(i+8)+3:4*(i+8)], 1));
         20           t2[3:0] = t2[3:0] EOR RotCell(Sinput[4*(i)+3:4*(i)], 1);
         21           t3[3:0] = (RotCell(Sinput[4*(i+12)+3:4*(i+12)], 1) EOR
         22                       RotCell(Sinput[4*(i+8)+3:4*(i+8)], 2));
         23           t3[3:0] = t3[3:0] EOR RotCell(Sinput[4*(i+4)+3:4*(i+4)], 1);
         24           Soutput[4*i+3:4*i] = t3[3:0];
         25           Soutput[4*(i+4)+3:4*(i+4)] = t2[3:0];
         26           Soutput[4*(i+8)+3:4*(i+8)] = t1[3:0];
         27           Soutput[4*(i+12)+3:4*(i+12)] = t0[3:0];
         28       return Soutput;

E2.1.307 PACSub
          1   // PACSub()
          2   // ========
          3
          4   bits(64) PACSub(bits(64) Tinput)
          5       // This is a 4-bit substitution from the PRINCE-family cipher
          6       bits(64) Toutput;
          7       for i = 0 to 15
          8           case Tinput[4*i+3:4*i] of
          9               when '0000' Toutput[4*i+3:4*i] = '1011';
         10               when '0001' Toutput[4*i+3:4*i] = '0110';
         11               when '0010' Toutput[4*i+3:4*i] = '1000';
         12               when '0011' Toutput[4*i+3:4*i] = '1111';
         13               when '0100' Toutput[4*i+3:4*i] = '1100';
         14               when '0101' Toutput[4*i+3:4*i] = '0000';
         15               when '0110' Toutput[4*i+3:4*i] = '1001';
         16               when '0111' Toutput[4*i+3:4*i] = '1110';
         17               when '1000' Toutput[4*i+3:4*i] = '0011';
         18               when '1001' Toutput[4*i+3:4*i] = '0111';
         19               when '1010' Toutput[4*i+3:4*i] = '0100';
         20               when '1011' Toutput[4*i+3:4*i] = '0101';
         21               when '1100' Toutput[4*i+3:4*i] = '1101';
         22               when '1101' Toutput[4*i+3:4*i] = '0010';
         23               when '1110' Toutput[4*i+3:4*i] = '0001';
         24               when '1111' Toutput[4*i+3:4*i] = '1010';
         25       return Toutput;

E2.1.308 PC
          1   // PC - non-assignment form
          2   // ========================
          3   bits(32) PC
          4       return RName[RNamesPC];

E2.1.309 PEMode
          1   // The PE execution modes.
          2
          3   enumeration PEMode {PEMode_Thread, PEMode_Handler};

E2.1.310 PendingDebugHalt
          1   // PendingDebugHalt()
          2   // ==================
          3
          4   boolean PendingDebugHalt()
          5       return CanHaltOnEvent(IsSecure(), FindPriv()) && DHCSR.C_HALT == '1';

E2.1.311 PendingDebugMonitor
          1   // PendingDebugMonitor()
          2   // =====================
          3
          4   boolean PendingDebugMonitor()
          5       // If the current execution priority is below DebugMonitor and generating a DebugMonitor
          6       // exception is allowed, and MON_PEND is set, then return TRUE. Otherwise return FALSE.
          7       if DEMCR.MON_PEND == '0' then
          8            return FALSE;
          9       elsif !CanPendMonitorOnEvent(IsSecure(), TRUE, FALSE, FindPriv(), FALSE) then
         10            return FALSE;
         11       else
         12            return TRUE;

E2.1.312 PendingExceptionDetails
          1   //   PendingExceptionDetails
          2   //   =======================
          3   //   Determines whether to take a pending exception or not. This is done based
          4   //   on current execution priority and the priority of pending exceptions that
          5   //   are not masked by DHCSR.C_MASKINTS.
          6   //   Returns whether any pending exception is to be taken, and, if so, the
          7   //   exception number for the highest priority unmasked exception, and 8   //   whether this exception is Secure.
          9
         10   (boolean, integer, boolean) PendingExceptionDetails();

E2.1.313 PendReturnOperation
          1   // PendReturnOperation()
          2   // =====================
          3
          4   PendReturnOperation(bits(32) returnValue)
          5       _NextInstrAddr          = returnValue;
          6       _PCChanged              = TRUE;
          7       _PendingReturnOperation = TRUE;
          8       return;

E2.1.314 Permissions
          1   // Access permissions descriptor
          2
          3   type Permissions is (
          4       boolean apValid,          //   TRUE when ap is valid, else FALSE
          5       bits(2) ap,               //   Access Permission bits, if valid
          6       bit     xn,               //   Execute Never bit
          7       boolean regionValid,      //   TRUE if the region number is valid, else FALSE
          8       bits(8) region            //   The MPU region number, if valid
          9   )

E2.1.315 PMU_CounterIncrement
          1   // PMU_CounterIncrement()
          2   // ======================
          3   // Increments PMU counters associated with the specified event as needed.
          4
          5   constant integer CYCLE_COUNTER_ID = 31;
          6
          7   PMU_CounterIncrement(PmuEventType eventId, integer counterId)
          8       // If the counter is disabled it does not need incrementing. Early-exit.
          9       if PMU_CTRL.E == '0' || DEMCR.TRCENA == '0' then
         10           return;
         11
         12       // Frozen, counters do not increment
         13       if IsDebugState() || (!IsZero(PMU_OVSSET) && PMU_CTRL.FZO == '1') then
         14           return;
         15
         16       pmuAllowedState = (((!IsSecure() && NoninvasiveDebugAllowed(FindPriv())) ||
         17                             SecureNoninvasiveDebugAllowed(FindPriv())) ||
         18                             eventId == PmuEventType_SW_INCR);
         19
         20       // If the PMU_CTRL.DP bit is not set, the dedicated cycle counter is
         21       // enabled in Secure state.
         22       if (counterId == CYCLE_COUNTER_ID && eventId == PmuEventType_CPU_CYCLES) then
         23           if (!IsSecure() || PMU_CTRL.DP == '0') then
         24               pmuAllowedState = TRUE;
         25           else
         26               pmuAllowedState = FALSE;
         27
         28       // Prohibited, counters do not increment
         29       if !pmuAllowedState then
         30           return;
         31
         32       // The cycle counter will increment whenever it is enabled and there is a
         33       // CPU_CYCLE event.
         34       if counterId == CYCLE_COUNTER_ID then
         35           if PMU_CNTENSET.C == '1' && eventId == PmuEventType_CPU_CYCLES then
         36               newValue = UInt(PMU_CCNTR) + 1;
         37               PMU_CCNTR = newValue[31:0];
         38               - = PMU_HandleOverflow(counterId, newValue, 32);
         39
         40       // Other counters will increment if they are enabled,
         41       // are configured to respond to that event
         42       elsif (PMU_CNTENSET.Pn[counterId] == '1' &&
         43              PMU_EVTYPER[counterId] == PmuEvent(eventId)) then
         44           newValue = UInt(PMU_EVCNTR[counterId]) + 1;
         45           PMU_EVCNTR[counterId].Counter = newValue[15:0];
         46           if PMU_HandleOverflow(counterId, newValue, 16) then
         47               // If this is an EVEN counter, look at possible chaining
         48               if counterId[0] == '0'                   &&
         49                  PMU_CNTENSET.Pn[counterId + 1] == '1' &&
         50                  PMU_EVTYPER[counterId + 1] == PmuEvent(PmuEventType_CHAIN) then
         51                   // Configured as chaining counter, increment
         52                   newValueChain = UInt(PMU_EVCNTR[counterId + 1]) + 1;
         53                   PMU_EVCNTR[counterId + 1].Counter = newValueChain[15:0];
         54                   - = PMU_HandleOverflow(counterId + 1, newValueChain, 16);
         55
         56   PMU_CounterIncrement(PmuEventType eventId)
         57       // If all counters are globally disabled,
         58       // they do not need incrementing. Early-exit.
         59       if PMU_CTRL.E == '0' || DEMCR.TRCENA == '0' then
         60           return;
         61       for i = 0 to UInt(PMU_TYPE.N) - 1
         62           PMU_CounterIncrement(eventId, i);
         63       PMU_CounterIncrement(eventId, CYCLE_COUNTER_ID);

E2.1.316 PMU_HandleOverflow
          1   // PMU_HandleOverflow()
          2   // ======================
          3   // Handles the overflow of a specified counter.
          4
          5   boolean PMU_HandleOverflow(integer counterId, integer newValue, integer overflowBit)
          6       // Handle trace-on-overflow if the lower 8-bits of any of the first 8 counters
          7       // overflows. This only occurs if trace-on-overflow is enabled.
          8       // If multiple trace packets are waiting to be issued, their contents can be
          9       // merged into a single packet.
         10       if counterId < 8 && PMU_CTRL.TRO == '1' && newValue[8] != (newValue - 1)[8] then
         11           PMU_EmitTrace(counterId);
         12
         13       // Has the counter actually overflowed?
         14       if newValue[overflowBit] == '1' then
         15           PMU_OVSSET[counterId] = '1';
         16           // If enabled, generate a debug event with 'PMU' syndrome
         17           if PMU_INTENSET[counterId] == '1' then
         18               isSecure = FALSE;
         19               isPriv   = CurrentModeIsPrivileged(isSecure);
         20               if DHCSR.C_PMOV == '1' && CanHaltOnEvent(isSecure, isPriv) then
         21                   DHCSR.C_HALT   = '1';
         22                   DFSR.PMU       = '1';
         23               elsif CanPendMonitorOnEvent(isSecure, FALSE, TRUE, isPriv, TRUE) then
         24                   DEMCR.MON_PEND = '1';
         25                   DFSR.PMU       = '1';
         26           return TRUE;
         27       return FALSE;

E2.1.317 PmuEvent
          1   // PmuEvent
          2   // =========
          3
          4   // This PmuEvent function defines a mapping between a human-readable
          5   // PMU Event and the corresponding integer event ID.
          6
          7   bits(32) PmuEvent(PmuEventType value)
          8       integer eventId;
          9       case value of
         10           when PmuEventType_SW_INCR                                                eventId     =   0x0;
         11           when PmuEventType_L1I_CACHE_REFILL                                       eventId     =   0x1;
         12           when PmuEventType_L1D_CACHE_REFILL                                       eventId     =   0x3;
         13           when PmuEventType_L1D_CACHE                                              eventId     =   0x4;
         14           when PmuEventType_LD_RETIRED                                             eventId     =   0x6;
         15           when PmuEventType_ST_RETIRED                                             eventId     =   0x7;
         16           when PmuEventType_INST_RETIRED                                           eventId     =   0x8;
         17           when PmuEventType_EXC_TAKEN                                              eventId     =   0x9;
         18           when PmuEventType_EXC_RETURN                                             eventId     =   0xa;
         19           when PmuEventType_PC_WRITE_RETIRED                                       eventId     =   0xc;
         20           when PmuEventType_BR_IMMED_RETIRED                                       eventId     =   0xd;
         21           when PmuEventType_BR_RETURN_RETIRED                                      eventId     =   0xe;
         22           when PmuEventType_UNALIGNED_LDST_RETIRED                                 eventId     =   0xf;
         23           when PmuEventType_BR_MIS_PRED                                            eventId     =   0x10;
         24           when PmuEventType_CPU_CYCLES                                             eventId     =   0x11;
         25           when PmuEventType_BR_PRED                                                eventId     =   0x12;
         26           when PmuEventType_MEM_ACCESS                                             eventId     =   0x13;
         27           when PmuEventType_L1I_CACHE                                              eventId     =   0x14;
         28           when PmuEventType_L1D_CACHE_WB                                           eventId     =   0x15;
         29           when PmuEventType_L2D_CACHE                                              eventId     =   0x16;
         30           when PmuEventType_L2D_CACHE_REFILL                                       eventId     =   0x17;
         31           when PmuEventType_L2D_CACHE_WB                                           eventId     =   0x18;
         32           when PmuEventType_BUS_ACCESS                                             eventId     =   0x19;
         33           when PmuEventType_MEMORY_ERROR                                           eventId     =   0x1a;
         34           when PmuEventType_INST_SPEC                                              eventId     =   0x1b;
         35           when PmuEventType_BUS_CYCLES                                             eventId     =   0x1d;
         36           when PmuEventType_CHAIN                                                  eventId     =   0x1e;
         37           when PmuEventType_L1D_CACHE_ALLOCATE                                     eventId     =   0x1f;
         38           when PmuEventType_L2D_CACHE_ALLOCATE                                     eventId     =   0x20;
         39           when PmuEventType_BR_RETIRED                                             eventId     =   0x21;
         40           when PmuEventType_BR_MIS_PRED_RETIRED                                    eventId     =   0x22;
         41           when PmuEventType_STALL_FRONTEND                                         eventId     =   0x23;
         42           when PmuEventType_STALL_BACKEND                                          eventId     =   0x24;
         43           when PmuEventType_L2I_CACHE                                              eventId     =   0x27;
         44           when PmuEventType_L2I_CACHE_REFILL                                       eventId     =   0x28;
         45           when PmuEventType_L3D_CACHE_ALLOCATE                                     eventId     =   0x29;
         46           when PmuEventType_L3D_CACHE_REFILL                                       eventId     =   0x2a;
         47           when PmuEventType_L3D_CACHE                                              eventId     =   0x2b;
         48           when PmuEventType_L3D_CACHE_WB                                           eventId     =   0x2c;
         49           when PmuEventType_LL_CACHE_RD                                            eventId     =   0x36;
         50           when PmuEventType_LL_CACHE_MISS_RD                                       eventId     =   0x37;
         51           when   PmuEventType_L1D_CACHE_MISS_RD                                    eventId     =   0x39;
         52           when   PmuEventType_OP_RETIRED                                           eventId     =   0x3a;
         53           when   PmuEventType_OP_SPEC                                              eventId     =   0x3b;
         54           when   PmuEventType_STALL                                                eventId     =   0x3c;
         55           when   PmuEventType_STALL_SLOT_BACKEND                                   eventId     =   0x3d;
         56           when   PmuEventType_STALL_SLOT_FRONTEND                                  eventId     =   0x3e;
         57           when   PmuEventType_STALL_SLOT                                           eventId     =   0x3f;
         58           when   PmuEventType_L1D_CACHE_RD                                         eventId     =   0x40;
         59           when   PmuEventType_LE_RETIRED                                           eventId     =   0x100;
         60           when   PmuEventType_LE_SPEC                                              eventId     =   0x101;
         61           when   PmuEventType_BF_RETIRED                                           eventId     =   0x104;
         62           when   PmuEventType_BF_SPEC                                              eventId     =   0x105;
         63           when   PmuEventType_LE_CANCEL                                            eventId     =   0x108;
         64           when   PmuEventType_BF_CANCEL                                            eventId     =   0x109;
         65           when   PmuEventType_SE_CALL_S                                            eventId     =   0x114;
         66           when   PmuEventType_SE_CALL_NS                                           eventId     =   0x115;
         67           when   PmuEventType_DWT_CMPMATCH0                                        eventId     =   0x118;
         68           when   PmuEventType_DWT_CMPMATCH1                                        eventId     =   0x119;
         69           when   PmuEventType_DWT_CMPMATCH2                                        eventId     =   0x11a;
         70           when   PmuEventType_DWT_CMPMATCH3                                        eventId     =   0x11b;
         71           when   PmuEventType_DWT_CMPMATCH4                                        eventId     =   0x11c;
         72           when   PmuEventType_DWT_CMPMATCH5                                        eventId     =   0x11d;
         73           when   PmuEventType_DWT_CMPMATCH6                                        eventId     =   0x11e;
         74           when   PmuEventType_DWT_CMPMATCH7                                        eventId     =   0x11f;
         75           when   PmuEventType_MVE_INST_RETIRED                                     eventId     =   0x200;
         76           when   PmuEventType_MVE_INST_SPEC                                        eventId     =   0x201;
         77           when   PmuEventType_MVE_FP_RETIRED                                       eventId     =   0x204;
         78           when   PmuEventType_MVE_FP_SPEC                                          eventId     =   0x205;
         79           when   PmuEventType_MVE_FP_HP_RETIRED                                    eventId     =   0x208;
         80           when   PmuEventType_MVE_FP_HP_SPEC                                       eventId     =   0x209;
         81           when   PmuEventType_MVE_FP_SP_RETIRED                                    eventId     =   0x20c;
         82           when   PmuEventType_MVE_FP_SP_SPEC                                       eventId     =   0x20d;
         83           when   PmuEventType_MVE_FP_MAC_RETIRED                                   eventId     =   0x214;
         84           when   PmuEventType_MVE_FP_MAC_SPEC                                      eventId     =   0x215;
         85           when   PmuEventType_MVE_INT_RETIRED                                      eventId     =   0x224;
         86           when   PmuEventType_MVE_INT_SPEC                                         eventId     =   0x225;
         87           when   PmuEventType_MVE_INT_MAC_RETIRED                                  eventId     =   0x228;
         88           when   PmuEventType_MVE_INT_MAC_SPEC                                     eventId     =   0x229;
         89           when   PmuEventType_MVE_LDST_RETIRED                                     eventId     =   0x238;
         90           when   PmuEventType_MVE_LDST_SPEC                                        eventId     =   0x239;
         91           when   PmuEventType_MVE_LD_RETIRED                                       eventId     =   0x23c;
         92           when   PmuEventType_MVE_LD_SPEC                                          eventId     =   0x23d;
         93           when   PmuEventType_MVE_ST_RETIRED                                       eventId     =   0x240;
         94           when   PmuEventType_MVE_ST_SPEC                                          eventId     =   0x241;
         95           when   PmuEventType_MVE_LDST_CONTIG_RETIRED                              eventId     =   0x244;
         96           when   PmuEventType_MVE_LDST_CONTIG_SPEC                                 eventId     =   0x245;
         97           when   PmuEventType_MVE_LD_CONTIG_RETIRED                                eventId     =   0x248;
         98           when   PmuEventType_MVE_LD_CONTIG_SPEC                                   eventId     =   0x249;
         99           when   PmuEventType_MVE_ST_CONTIG_RETIRED                                eventId     =   0x24c;
        100           when   PmuEventType_MVE_ST_CONTIG_SPEC                                   eventId     =   0x24d;
        101           when   PmuEventType_MVE_LDST_NONCONTIG_RETIRED                           eventId     =   0x250;
        102           when   PmuEventType_MVE_LDST_NONCONTIG_SPEC                              eventId     =   0x251;
        103           when   PmuEventType_MVE_LD_NONCONTIG_RETIRED                             eventId     =   0x254;
        104           when   PmuEventType_MVE_LD_NONCONTIG_SPEC                                eventId     =   0x255;
        105           when   PmuEventType_MVE_ST_NONCONTIG_RETIRED                             eventId     =   0x258;
        106           when   PmuEventType_MVE_ST_NONCONTIG_SPEC                                eventId     =   0x259;
        107           when   PmuEventType_MVE_LDST_MULTI_RETIRED                               eventId     =   0x25c;
        108           when   PmuEventType_MVE_LDST_MULTI_SPEC                                  eventId     =   0x25d;
        109           when   PmuEventType_MVE_LD_MULTI_RETIRED                                 eventId     =   0x260;
        110           when   PmuEventType_MVE_LD_MULTI_SPEC                                    eventId     =   0x261;
        111           when   PmuEventType_MVE_ST_MULTI_RETIRED                                 eventId     =   0x264;
        112           when   PmuEventType_MVE_ST_MULTI_SPEC                                    eventId     =   0x265;
        113           when   PmuEventType_MVE_LDST_UNALIGNED_RETIRED                           eventId     =   0x28c;
        114           when   PmuEventType_MVE_LDST_UNALIGNED_SPEC                              eventId     =   0x28d;
        115           when   PmuEventType_MVE_LD_UNALIGNED_RETIRED                             eventId     =   0x290;
        116           when   PmuEventType_MVE_LD_UNALIGNED_SPEC                                eventId     =   0x291;
        117           when   PmuEventType_MVE_ST_UNALIGNED_RETIRED                             eventId     =   0x294;
        118           when   PmuEventType_MVE_ST_UNALIGNED_SPEC                                eventId     =   0x295;
        119           when   PmuEventType_MVE_LDST_UNALIGNED_NONCONTIG_RETIRED                 eventId     =   0x298;
        120           when   PmuEventType_MVE_LDST_UNALIGNED_NONCONTIG_SPEC                    eventId     =   0x299;
        121           when   PmuEventType_MVE_VREDUCE_RETIRED                                  eventId     =   0x2a0;
        122           when   PmuEventType_MVE_VREDUCE_SPEC                                     eventId     =   0x2a1;
        123           when   PmuEventType_MVE_VREDUCE_FP_RETIRED                               eventId     =   0x2a4;
        124           when   PmuEventType_MVE_VREDUCE_FP_SPEC                                  eventId     =   0x2a5;
        125           when   PmuEventType_MVE_VREDUCE_INT_RETIRED                              eventId     =   0x2a8;
        126           when   PmuEventType_MVE_VREDUCE_INT_SPEC                                 eventId     =   0x2a9;
        127           when   PmuEventType_MVE_PRED                                             eventId     =   0x2b8;
        128           when   PmuEventType_MVE_STALL                                            eventId     =   0x2cc;
        129           when   PmuEventType_MVE_STALL_RESOURCE                                   eventId     =   0x2cd;
        130           when   PmuEventType_MVE_STALL_RESOURCE_MEM                               eventId     =   0x2ce;
        131           when   PmuEventType_MVE_STALL_RESOURCE_FP                                eventId     =   0x2cf;
        132           when   PmuEventType_MVE_STALL_RESOURCE_INT                               eventId     =   0x2d0;
        133           when   PmuEventType_MVE_STALL_BREAK                                      eventId     =   0x2d3;
        134           when   PmuEventType_MVE_STALL_DEPENDENCY                                 eventId     =   0x2d4;
        135           when   PmuEventType_ITCM_ACCESS                                          eventId     =   0x4007;
        136           when   PmuEventType_DTCM_ACCESS                                          eventId     =   0x4008;
        137           when   PmuEventType_TRCEXTOUT0                                           eventId     =   0x4010;
        138           when   PmuEventType_TRCEXTOUT1                                           eventId     =   0x4011;
        139           when   PmuEventType_TRCEXTOUT2                                           eventId     =   0x4012;
        140           when   PmuEventType_TRCEXTOUT3                                           eventId     =   0x4013;
        141           when   PmuEventType_CTI_TRIGOUT4                                         eventId     =   0x4018;
        142           when   PmuEventType_CTI_TRIGOUT5                                         eventId     =   0x4019;
        143           when   PmuEventType_CTI_TRIGOUT6                                         eventId     =   0x401a;
        144           when   PmuEventType_CTI_TRIGOUT7                                         eventId     =   0x401b;
        145
        146           // Events above 0xFFFF are reserved for
        147           // IMPLEMENTATION DEFINED events
        148           otherwise
        149               eventId = -1;
        150       return eventId[31:0];
        151
        152   PmuEventType PmuEvent(bits(32) value)
        153       PmuEventType eventId;
        154       case UInt(value) of
        155           when 0x0   eventId = PmuEventType_SW_INCR;
        156           when 0x1   eventId = PmuEventType_L1I_CACHE_REFILL;
        157           when 0x3   eventId = PmuEventType_L1D_CACHE_REFILL;
        158           when 0x4   eventId = PmuEventType_L1D_CACHE;
        159           when 0x6   eventId = PmuEventType_LD_RETIRED;
        160           when 0x7   eventId = PmuEventType_ST_RETIRED;
        161           when 0x8   eventId = PmuEventType_INST_RETIRED;
        162           when 0x9   eventId = PmuEventType_EXC_TAKEN;
        163           when 0xa   eventId = PmuEventType_EXC_RETURN;
        164           when 0xc   eventId = PmuEventType_PC_WRITE_RETIRED;
        165           when 0xd   eventId = PmuEventType_BR_IMMED_RETIRED;
        166           when 0xe   eventId = PmuEventType_BR_RETURN_RETIRED;
        167           when 0xf   eventId = PmuEventType_UNALIGNED_LDST_RETIRED;
        168           when 0x10 eventId = PmuEventType_BR_MIS_PRED;
        169           when 0x11 eventId = PmuEventType_CPU_CYCLES;
        170           when 0x12 eventId = PmuEventType_BR_PRED;
        171           when 0x13 eventId = PmuEventType_MEM_ACCESS;
        172           when 0x14 eventId = PmuEventType_L1I_CACHE;
        173           when 0x15 eventId = PmuEventType_L1D_CACHE_WB;
        174           when 0x16 eventId = PmuEventType_L2D_CACHE;
        175           when 0x17 eventId = PmuEventType_L2D_CACHE_REFILL;
        176           when 0x18 eventId = PmuEventType_L2D_CACHE_WB;
        177           when 0x19 eventId = PmuEventType_BUS_ACCESS;
        178           when 0x1a eventId = PmuEventType_MEMORY_ERROR;
        179           when 0x1b eventId = PmuEventType_INST_SPEC;
        180           when 0x1d eventId = PmuEventType_BUS_CYCLES;
        181           when 0x1e eventId = PmuEventType_CHAIN;
        182           when 0x1f eventId = PmuEventType_L1D_CACHE_ALLOCATE;
        183           when 0x20 eventId = PmuEventType_L2D_CACHE_ALLOCATE;
        184           when 0x21 eventId = PmuEventType_BR_RETIRED;
        185           when 0x22 eventId = PmuEventType_BR_MIS_PRED_RETIRED;
        186           when 0x23 eventId = PmuEventType_STALL_FRONTEND;
        187           when 0x24 eventId = PmuEventType_STALL_BACKEND;
        188           when 0x27 eventId = PmuEventType_L2I_CACHE;
        189           when   0x28    eventId     =   PmuEventType_L2I_CACHE_REFILL;
        190           when   0x29    eventId     =   PmuEventType_L3D_CACHE_ALLOCATE;
        191           when   0x2a    eventId     =   PmuEventType_L3D_CACHE_REFILL;
        192           when   0x2b    eventId     =   PmuEventType_L3D_CACHE;
        193           when   0x2c    eventId     =   PmuEventType_L3D_CACHE_WB;
        194           when   0x36    eventId     =   PmuEventType_LL_CACHE_RD;
        195           when   0x37    eventId     =   PmuEventType_LL_CACHE_MISS_RD;
        196           when   0x39    eventId     =   PmuEventType_L1D_CACHE_MISS_RD;
        197           when   0x3a    eventId     =   PmuEventType_OP_RETIRED;
        198           when   0x3b    eventId     =   PmuEventType_OP_SPEC;
        199           when   0x3c    eventId     =   PmuEventType_STALL;
        200           when   0x3d    eventId     =   PmuEventType_STALL_SLOT_BACKEND;
        201           when   0x3e    eventId     =   PmuEventType_STALL_SLOT_FRONTEND;
        202           when   0x3f    eventId     =   PmuEventType_STALL_SLOT;
        203           when   0x40    eventId     =   PmuEventType_L1D_CACHE_RD;
        204           when   0x100   eventId     =   PmuEventType_LE_RETIRED;
        205           when   0x101   eventId     =   PmuEventType_LE_SPEC;
        206           when   0x104   eventId     =   PmuEventType_BF_RETIRED;
        207           when   0x105   eventId     =   PmuEventType_BF_SPEC;
        208           when   0x108   eventId     =   PmuEventType_LE_CANCEL;
        209           when   0x109   eventId     =   PmuEventType_BF_CANCEL;
        210           when   0x114   eventId     =   PmuEventType_SE_CALL_S;
        211           when   0x115   eventId     =   PmuEventType_SE_CALL_NS;
        212           when   0x118   eventId     =   PmuEventType_DWT_CMPMATCH0;
        213           when   0x119   eventId     =   PmuEventType_DWT_CMPMATCH1;
        214           when   0x11a   eventId     =   PmuEventType_DWT_CMPMATCH2;
        215           when   0x11b   eventId     =   PmuEventType_DWT_CMPMATCH3;
        216           when   0x11c   eventId     =   PmuEventType_DWT_CMPMATCH4;
        217           when   0x11d   eventId     =   PmuEventType_DWT_CMPMATCH5;
        218           when   0x11e   eventId     =   PmuEventType_DWT_CMPMATCH6;
        219           when   0x11f   eventId     =   PmuEventType_DWT_CMPMATCH7;
        220           when   0x200   eventId     =   PmuEventType_MVE_INST_RETIRED;
        221           when   0x201   eventId     =   PmuEventType_MVE_INST_SPEC;
        222           when   0x204   eventId     =   PmuEventType_MVE_FP_RETIRED;
        223           when   0x205   eventId     =   PmuEventType_MVE_FP_SPEC;
        224           when   0x208   eventId     =   PmuEventType_MVE_FP_HP_RETIRED;
        225           when   0x209   eventId     =   PmuEventType_MVE_FP_HP_SPEC;
        226           when   0x20c   eventId     =   PmuEventType_MVE_FP_SP_RETIRED;
        227           when   0x20d   eventId     =   PmuEventType_MVE_FP_SP_SPEC;
        228           when   0x214   eventId     =   PmuEventType_MVE_FP_MAC_RETIRED;
        229           when   0x215   eventId     =   PmuEventType_MVE_FP_MAC_SPEC;
        230           when   0x224   eventId     =   PmuEventType_MVE_INT_RETIRED;
        231           when   0x225   eventId     =   PmuEventType_MVE_INT_SPEC;
        232           when   0x228   eventId     =   PmuEventType_MVE_INT_MAC_RETIRED;
        233           when   0x229   eventId     =   PmuEventType_MVE_INT_MAC_SPEC;
        234           when   0x238   eventId     =   PmuEventType_MVE_LDST_RETIRED;
        235           when   0x239   eventId     =   PmuEventType_MVE_LDST_SPEC;
        236           when   0x23c   eventId     =   PmuEventType_MVE_LD_RETIRED;
        237           when   0x23d   eventId     =   PmuEventType_MVE_LD_SPEC;
        238           when   0x240   eventId     =   PmuEventType_MVE_ST_RETIRED;
        239           when   0x241   eventId     =   PmuEventType_MVE_ST_SPEC;
        240           when   0x244   eventId     =   PmuEventType_MVE_LDST_CONTIG_RETIRED;
        241           when   0x245   eventId     =   PmuEventType_MVE_LDST_CONTIG_SPEC;
        242           when   0x248   eventId     =   PmuEventType_MVE_LD_CONTIG_RETIRED;
        243           when   0x249   eventId     =   PmuEventType_MVE_LD_CONTIG_SPEC;
        244           when   0x24c   eventId     =   PmuEventType_MVE_ST_CONTIG_RETIRED;
        245           when   0x24d   eventId     =   PmuEventType_MVE_ST_CONTIG_SPEC;
        246           when   0x250   eventId     =   PmuEventType_MVE_LDST_NONCONTIG_RETIRED;
        247           when   0x251   eventId     =   PmuEventType_MVE_LDST_NONCONTIG_SPEC;
        248           when   0x254   eventId     =   PmuEventType_MVE_LD_NONCONTIG_RETIRED;
        249           when   0x255   eventId     =   PmuEventType_MVE_LD_NONCONTIG_SPEC;
        250           when   0x258   eventId     =   PmuEventType_MVE_ST_NONCONTIG_RETIRED;
        251           when   0x259   eventId     =   PmuEventType_MVE_ST_NONCONTIG_SPEC;
        252           when   0x25c   eventId     =   PmuEventType_MVE_LDST_MULTI_RETIRED;
        253           when   0x25d   eventId     =   PmuEventType_MVE_LDST_MULTI_SPEC;
        254           when   0x260   eventId     =   PmuEventType_MVE_LD_MULTI_RETIRED;
        255           when   0x261   eventId     =   PmuEventType_MVE_LD_MULTI_SPEC;
        256           when   0x264   eventId     =   PmuEventType_MVE_ST_MULTI_RETIRED;
        257           when   0x265   eventId     =   PmuEventType_MVE_ST_MULTI_SPEC;
        258           when   0x28c eventId       =   PmuEventType_MVE_LDST_UNALIGNED_RETIRED;
        259           when   0x28d eventId       =   PmuEventType_MVE_LDST_UNALIGNED_SPEC;
        260           when   0x290 eventId       =   PmuEventType_MVE_LD_UNALIGNED_RETIRED;
        261           when   0x291 eventId       =   PmuEventType_MVE_LD_UNALIGNED_SPEC;
        262           when   0x294 eventId       =   PmuEventType_MVE_ST_UNALIGNED_RETIRED;
        263           when   0x295 eventId       =   PmuEventType_MVE_ST_UNALIGNED_SPEC;
        264           when   0x298 eventId       =   PmuEventType_MVE_LDST_UNALIGNED_NONCONTIG_RETIRED;
        265           when   0x299 eventId       =   PmuEventType_MVE_LDST_UNALIGNED_NONCONTIG_SPEC;
        266           when   0x2a0 eventId       =   PmuEventType_MVE_VREDUCE_RETIRED;
        267           when   0x2a1 eventId       =   PmuEventType_MVE_VREDUCE_SPEC;
        268           when   0x2a4 eventId       =   PmuEventType_MVE_VREDUCE_FP_RETIRED;
        269           when   0x2a5 eventId       =   PmuEventType_MVE_VREDUCE_FP_SPEC;
        270           when   0x2a8 eventId       =   PmuEventType_MVE_VREDUCE_INT_RETIRED;
        271           when   0x2a9 eventId       =   PmuEventType_MVE_VREDUCE_INT_SPEC;
        272           when   0x2b8 eventId       =   PmuEventType_MVE_PRED;
        273           when   0x2cc eventId       =   PmuEventType_MVE_STALL;
        274           when   0x2cd eventId       =   PmuEventType_MVE_STALL_RESOURCE;
        275           when   0x2ce eventId       =   PmuEventType_MVE_STALL_RESOURCE_MEM;
        276           when   0x2cf eventId       =   PmuEventType_MVE_STALL_RESOURCE_FP;
        277           when   0x2d0 eventId       =   PmuEventType_MVE_STALL_RESOURCE_INT;
        278           when   0x2d3 eventId       =   PmuEventType_MVE_STALL_BREAK;
        279           when   0x2d4 eventId       =   PmuEventType_MVE_STALL_DEPENDENCY;
        280           when   0x4007 eventId      =   PmuEventType_ITCM_ACCESS;
        281           when   0x4008 eventId      =   PmuEventType_DTCM_ACCESS;
        282           when   0x4010 eventId      =   PmuEventType_TRCEXTOUT0;
        283           when   0x4011 eventId      =   PmuEventType_TRCEXTOUT1;
        284           when   0x4012 eventId      =   PmuEventType_TRCEXTOUT2;
        285           when   0x4013 eventId      =   PmuEventType_TRCEXTOUT3;
        286           when   0x4018 eventId      =   PmuEventType_CTI_TRIGOUT4;
        287           when   0x4019 eventId      =   PmuEventType_CTI_TRIGOUT5;
        288           when   0x401a eventId      =   PmuEventType_CTI_TRIGOUT6;
        289           when   0x401b eventId      =   PmuEventType_CTI_TRIGOUT7;
        290
        291           // Events above 0xFFFF are reserved for
        292           // IMPLEMENTATION DEFINED events
        293           otherwise
        294               eventId = PmuEventType_NONE;
        295       return eventId;

E2.1.318 PmuEventType
          1   // Enumeration of the supported PMU Events
          2   enumeration PmuEventType {
          3       PmuEventType_NONE,
          4       PmuEventType_SW_INCR,
          5       PmuEventType_L1I_CACHE_REFILL,
          6       PmuEventType_L1D_CACHE_REFILL,
          7       PmuEventType_L1D_CACHE,
          8       PmuEventType_LD_RETIRED,
          9       PmuEventType_ST_RETIRED,
         10       PmuEventType_INST_RETIRED,
         11       PmuEventType_EXC_TAKEN,
         12       PmuEventType_EXC_RETURN,
         13       PmuEventType_PC_WRITE_RETIRED,
         14       PmuEventType_BR_IMMED_RETIRED,
         15       PmuEventType_BR_RETURN_RETIRED,
         16       PmuEventType_UNALIGNED_LDST_RETIRED,
         17       PmuEventType_BR_MIS_PRED,
         18       PmuEventType_CPU_CYCLES,
         19       PmuEventType_BR_PRED,
         20       PmuEventType_MEM_ACCESS,
         21       PmuEventType_L1I_CACHE,
         22       PmuEventType_L1D_CACHE_WB,
         23       PmuEventType_L2D_CACHE,
         24       PmuEventType_L2D_CACHE_REFILL,
         25       PmuEventType_L2D_CACHE_WB,
         26       PmuEventType_BUS_ACCESS,
         27       PmuEventType_MEMORY_ERROR,
         28       PmuEventType_INST_SPEC,
         29       PmuEventType_BUS_CYCLES,
         30       PmuEventType_CHAIN,
         31       PmuEventType_L1D_CACHE_ALLOCATE,
         32       PmuEventType_L2D_CACHE_ALLOCATE,
         33       PmuEventType_BR_RETIRED,
         34       PmuEventType_BR_MIS_PRED_RETIRED,
         35       PmuEventType_STALL_FRONTEND,
         36       PmuEventType_STALL_BACKEND,
         37       PmuEventType_L2I_CACHE,
         38       PmuEventType_L2I_CACHE_REFILL,
         39       PmuEventType_L3D_CACHE_ALLOCATE,
         40       PmuEventType_L3D_CACHE_REFILL,
         41       PmuEventType_L3D_CACHE,
         42       PmuEventType_L3D_CACHE_WB,
         43       PmuEventType_LL_CACHE_RD,
         44       PmuEventType_LL_CACHE_MISS_RD,
         45       PmuEventType_L1D_CACHE_MISS_RD,
         46       PmuEventType_OP_RETIRED,
         47       PmuEventType_OP_SPEC,
         48       PmuEventType_STALL,
         49       PmuEventType_STALL_SLOT_BACKEND,
         50       PmuEventType_STALL_SLOT_FRONTEND,
         51       PmuEventType_STALL_SLOT,
         52       PmuEventType_L1D_CACHE_RD,
         53       PmuEventType_LE_RETIRED,
         54       PmuEventType_LE_SPEC,
         55       PmuEventType_BF_RETIRED,
         56       PmuEventType_BF_SPEC,
         57       PmuEventType_LE_CANCEL,
         58       PmuEventType_BF_CANCEL,
         59       PmuEventType_SE_CALL_S,
         60       PmuEventType_SE_CALL_NS,
         61       PmuEventType_DWT_CMPMATCH0,
         62       PmuEventType_DWT_CMPMATCH1,
         63       PmuEventType_DWT_CMPMATCH2,
         64       PmuEventType_DWT_CMPMATCH3,
         65       PmuEventType_DWT_CMPMATCH4,
         66       PmuEventType_DWT_CMPMATCH5,
         67       PmuEventType_DWT_CMPMATCH6,
         68       PmuEventType_DWT_CMPMATCH7,
         69       PmuEventType_MVE_INST_RETIRED,
         70       PmuEventType_MVE_INST_SPEC,
         71       PmuEventType_MVE_FP_RETIRED,
         72       PmuEventType_MVE_FP_SPEC,
         73       PmuEventType_MVE_FP_HP_RETIRED,
         74       PmuEventType_MVE_FP_HP_SPEC,
         75       PmuEventType_MVE_FP_SP_RETIRED,
         76       PmuEventType_MVE_FP_SP_SPEC,
         77       PmuEventType_MVE_FP_MAC_RETIRED,
         78       PmuEventType_MVE_FP_MAC_SPEC,
         79       PmuEventType_MVE_INT_RETIRED,
         80       PmuEventType_MVE_INT_SPEC,
         81       PmuEventType_MVE_INT_MAC_RETIRED,
         82       PmuEventType_MVE_INT_MAC_SPEC,
         83       PmuEventType_MVE_LDST_RETIRED,
         84       PmuEventType_MVE_LDST_SPEC,
         85       PmuEventType_MVE_LD_RETIRED,
         86       PmuEventType_MVE_LD_SPEC,
         87       PmuEventType_MVE_ST_RETIRED,
         88       PmuEventType_MVE_ST_SPEC,
         89       PmuEventType_MVE_LDST_CONTIG_RETIRED,
         90       PmuEventType_MVE_LDST_CONTIG_SPEC,
         91       PmuEventType_MVE_LD_CONTIG_RETIRED,
         92       PmuEventType_MVE_LD_CONTIG_SPEC,
         93       PmuEventType_MVE_ST_CONTIG_RETIRED,
         94       PmuEventType_MVE_ST_CONTIG_SPEC,
         95       PmuEventType_MVE_LDST_NONCONTIG_RETIRED,
         96       PmuEventType_MVE_LDST_NONCONTIG_SPEC,
         97        PmuEventType_MVE_LD_NONCONTIG_RETIRED,
         98        PmuEventType_MVE_LD_NONCONTIG_SPEC,
         99        PmuEventType_MVE_ST_NONCONTIG_RETIRED,
        100        PmuEventType_MVE_ST_NONCONTIG_SPEC,
        101        PmuEventType_MVE_LDST_MULTI_RETIRED,
        102        PmuEventType_MVE_LDST_MULTI_SPEC,
        103        PmuEventType_MVE_LD_MULTI_RETIRED,
        104        PmuEventType_MVE_LD_MULTI_SPEC,
        105        PmuEventType_MVE_ST_MULTI_RETIRED,
        106        PmuEventType_MVE_ST_MULTI_SPEC,
        107        PmuEventType_MVE_LDST_UNALIGNED_RETIRED,
        108        PmuEventType_MVE_LDST_UNALIGNED_SPEC,
        109        PmuEventType_MVE_LD_UNALIGNED_RETIRED,
        110        PmuEventType_MVE_LD_UNALIGNED_SPEC,
        111        PmuEventType_MVE_ST_UNALIGNED_RETIRED,
        112        PmuEventType_MVE_ST_UNALIGNED_SPEC,
        113        PmuEventType_MVE_LDST_UNALIGNED_NONCONTIG_RETIRED,
        114        PmuEventType_MVE_LDST_UNALIGNED_NONCONTIG_SPEC,
        115        PmuEventType_MVE_VREDUCE_RETIRED,
        116        PmuEventType_MVE_VREDUCE_SPEC,
        117        PmuEventType_MVE_VREDUCE_FP_RETIRED,
        118        PmuEventType_MVE_VREDUCE_FP_SPEC,
        119        PmuEventType_MVE_VREDUCE_INT_RETIRED,
        120        PmuEventType_MVE_VREDUCE_INT_SPEC,
        121        PmuEventType_MVE_PRED,
        122        PmuEventType_MVE_STALL,
        123        PmuEventType_MVE_STALL_RESOURCE,
        124        PmuEventType_MVE_STALL_RESOURCE_MEM,
        125        PmuEventType_MVE_STALL_RESOURCE_FP,
        126        PmuEventType_MVE_STALL_RESOURCE_INT,
        127        PmuEventType_MVE_STALL_BREAK,
        128        PmuEventType_MVE_STALL_DEPENDENCY,
        129        PmuEventType_ITCM_ACCESS,
        130        PmuEventType_DTCM_ACCESS,
        131        PmuEventType_TRCEXTOUT0,
        132        PmuEventType_TRCEXTOUT1,
        133        PmuEventType_TRCEXTOUT2,
        134        PmuEventType_TRCEXTOUT3,
        135        PmuEventType_CTI_TRIGOUT4,
        136        PmuEventType_CTI_TRIGOUT5,
        137        PmuEventType_CTI_TRIGOUT6,
        138        PmuEventType_CTI_TRIGOUT7
        139        // Other implementation-specific events may be defined here
        140   };

E2.1.319 PolynomialMult
          1   // PolynomialMult()
          2   // ================
          3
          4   bits(M+N) PolynomialMult(bits(M) op1, bits(N) op2)
          5       result = Zeros(M+N);
          6       extended_op2 = Zeros(M) : op2;
          7       for i=0 to M-1
          8           if op1[i] == '1' then
          9               result = result EOR LSL(extended_op2, i);
         10       return result;

E2.1.320 PopStack
          1   // PopStack()
          2   // ==========
          3
          4   ExcInfo PopStack(EXC_RETURN_Type excReturn)
          5       constant integer intCallerFrameSize = 0x20;
          6       constant integer intCalleeFrameSize = 0x28;
          7       constant integer fpCallerFrameSize = 0x48;
          8
          9       // NOTE: All stack accesses are performed as Unprivileged accesses if
         10       // returning to Thread mode and CONTROL.nPRIV is 1 for the destination
         11       // Security state.
         12       mode     = if excReturn.Mode == '1' then PEMode_Thread else PEMode_Handler;
         13       toSecure = HaveSecurityExt() && excReturn.S == '1';
         14       spName   = LookUpSP_with_security_mode(toSecure, mode);
         15       frameptr = _SP(spName);
         16       if !IsAligned(frameptr, 8) then UNPREDICTABLE;
         17
         18       // only stack locations, not the load order, are architected
         19
         20       // Pop the callee saved registers, when returning from a Non-secure exception
         21       // or a Secure one that followed a Non-secure one and therefore still has
         22       // the callee register state on the stack.
         23       exc = DefaultExcInfo();
         24       if toSecure && (excReturn.ES == '0' ||
         25                       excReturn.DCRS == '0') then
         26           // Check the integrity signature, and if so is it correct
         27           expectedSig = 0xFEFA125B[31:0];
         28           if HaveMveOrFPExt() then
         29               expectedSig[0] = excReturn.FType;
         30           (exc, integritySig) = Stack(frameptr, 0x0, spName, mode);
         31           if exc.fault == NoFault && integritySig != expectedSig then
         32               if HaveMainExt() then
         33                   SFSR.INVIS = '1';
         34               // Create the exception. NOTE: If Main Extension is not implemented the fault
         35               // always escalates to a HardFault
         36               return CreateException(SecureFault);
         37
         38           if exc.fault == NoFault then (exc, R[4] )              =   Stack(frameptr,      0x8,    spName,   mode);
         39           if exc.fault == NoFault then (exc, R[5] )              =   Stack(frameptr,      0xC,    spName,   mode);
         40           if exc.fault == NoFault then (exc, R[6] )              =   Stack(frameptr,      0x10,   spName,   mode);
         41           if exc.fault == NoFault then (exc, R[7] )              =   Stack(frameptr,      0x14,   spName,   mode);
         42           if exc.fault == NoFault then (exc, R[8] )              =   Stack(frameptr,      0x18,   spName,   mode);
         43           if exc.fault == NoFault then (exc, R[9] )              =   Stack(frameptr,      0x1C,   spName,   mode);
         44           if exc.fault == NoFault then (exc, R[10])              =   Stack(frameptr,      0x20,   spName,   mode);
         45           if exc.fault == NoFault then (exc, R[11])              =   Stack(frameptr,      0x24,   spName,   mode);
         46           frameptr = frameptr + intCalleeFrameSize;
         47
         48       // Unstack the caller saved regs, possibly including the FP                  regs
         49       RETPSR_Type psr;
         50       if exc.fault == NoFault then (exc, R[0] ) = Stack(frameptr,                  0x0,       spName,   mode);
         51       if exc.fault == NoFault then (exc, R[1] ) = Stack(frameptr,                  0x4,       spName,   mode);
         52       if exc.fault == NoFault then (exc, R[2] ) = Stack(frameptr,                  0x8,       spName,   mode);
         53       if exc.fault == NoFault then (exc, R[3] ) = Stack(frameptr,                  0xC,       spName,   mode);
         54       if exc.fault == NoFault then (exc, R[12]) = Stack(frameptr,                  0x10,      spName,   mode);
         55       if exc.fault == NoFault then (exc, LR   ) = Stack(frameptr,                  0x14,      spName,   mode);
         56       if exc.fault == NoFault then (exc, pc   ) = Stack(frameptr,                  0x18,      spName,   mode);
         57       if exc.fault == NoFault then (exc, psr ) = Stack(frameptr,                   0x1C,      spName,   mode);
         58       frameOffset = intCallerFrameSize;
         59       BranchTo(pc, TRUE, psr.B == '1');
         60
         61       // Check the XPSR value that has been unstacked is consistent with the mode
         62       // being returned to
         63       excNum = UInt(psr.Exception);
         64       if (exc.fault == NoFault) &&
         65          ((mode == PEMode_Handler) == (excNum == 0)) then
         66           if HaveMainExt() then
         67               UFSR.INVPC = '1';
         68           // Create the exception. NOTE: If Main Extension is not implemented the fault
         69           // always escalates to a HardFault
         70           return CreateException(UsageFault);
         71
         72       // The IPSR value is set as UNKNOWN if the unstacked IPSR value is not
         73       // supported by the PE
         74       validIPSR = excNum IN {0, 1, NMI, HardFault, SVCall, PendSV, SysTick};
         75       if !validIPSR && HaveMainExt() then
         76           validIPSR = excNum IN {MemManage, BusFault, UsageFault, SecureFault, DebugMonitor};
         77
         78       // Check also whether excNum is an external interupt supported by PE
         79       if !validIPSR && !IsIrqValid(excNum) then
         80           psr.Exception = bits(9) UNKNOWN;
         81
         82       if HaveMveOrFPExt() then
         83           if excReturn.FType == '0' then
         84               // Raise a fault and skip Floating-point operations if requested to expose
         85               // Secure Floating-point state to the Non-secure code.
         86               if !toSecure && FPCCR_S.LSPACT == '1' then
         87                    SFSR.LSERR = '1';
         88                    newExc     = CreateException(SecureFault);
         89                    // It is IMPLEMENTATION DEFINED whether a MemManage fault is dropped if
         90                    // a SecureFault is generated subsequently. If the MemManage fault is
         91                    // not dropped the exceptions will be taken based on exception
         92                    // priority as described in MergeExcInfo()
         93                    if boolean IMPLEMENTATION_DEFINED "Drop previously generated exceptions" then
         94                        exc = newExc;
         95                    else
         96                        exc = MergeExcInfo(exc, newExc);
         97               else
         98                    lspact = if toSecure then FPCCR_S.LSPACT else FPCCR_NS.LSPACT;
         99                    if lspact == '1' then // state in FP is still valid
        100                        if exc.fault == NoFault then
        101                            if toSecure then
        102                                FPCCR_S.LSPACT = '0';
        103                            else
        104                                FPCCR_NS.LSPACT = '0';
        105                    else
        106                        if exc.fault == NoFault then
        107                            nPriv = if toSecure then CONTROL_S.nPRIV else CONTROL_NS.nPRIV;
        108                            isPriv = mode == PEMode_Handler || nPriv == '0';
        109                            exc    = CheckCPEnabled(10, isPriv, toSecure);
        110
        111                            //   If an implementation abandons the unstacking of the Floating-point
        112                            //   Extension registers and to tail chain into a fault or late arriving
        113                            //   interrupt it must clear any Floating-point registers that
        114                            //   would have been unstacked.
        115                            //   NOTE: The requirment to clear the registers only applies
        116                            //   to implementations that include the Security Extensions.
        117                            //   The Floating-point Extension registers that would have been
        118                            //   unstacked become UNKNOWN in implementations that do not include the
        119                            //   Security Extensions.
        120                            if   exc.fault == NoFault then
        121                                  for i = 0 to 15
        122                                      if exc.fault == NoFault then
        123                                          (exc, S[i]) = Stack(frameptr, frameOffset + (4*i),
        124                                                               spName, mode);
        125                                  if exc.fault == NoFault then
        126                                      (exc, FPSCR) = Stack(frameptr, frameOffset + 0x40, spName, mode);
        127                                  if HaveMve() && exc.fault == NoFault then
        128                                      (exc, VPR)   = Stack(frameptr, frameOffset + 0x44, spName, mode);
        129                                  frameOffset = frameOffset + fpCallerFrameSize;
        130
        131                                  pushFPCalleeRegs = toSecure && FPCCR_S.TS == '1';
        132                                  if pushFPCalleeRegs then
        133                                      for i = 0 to 15
        134                                          if exc.fault == NoFault then
        135                                              (exc, S[i+16]) = Stack(frameptr, frameOffset + (4*i),
        136                                                                     spName, mode);
        137
        138                                  if exc.fault != NoFault then
        139                                      InvalidateFPRegs(HaveSecurityExt(), pushFPCalleeRegs);
        140
        141           CONTROL.FPCA = NOT(excReturn.FType);
        142
        143       // If there was not a fault then move the stack pointer to consume the
        144       // exception stack frame. NOTE: If a exception return fault occurs and 145       // results in a lockup the stack pointer is updated. This special case is
        146       // handled at the point lockup is entered and not here.
        147       if exc.fault == NoFault then
        148           ConsumeExcStackFrame(excReturn, psr.SPREALIGN);
        149
        150       if HaveDSPExt() then
        151           APSR.GE        = psr.GE;
        152       if IsSecure() then
        153           CONTROL_S.SFPA = psr.SFPA;
        154       IPSR.Exception = psr.Exception;                              // Load valid IPSR bits from memory
        155       EPSR.T         = psr.T;                                      // Load valid EPSR bits from memory
        156       if HaveMainExt() then
        157           APSR[31:27]       = psr[31:27];                          // Load valid APSR bits from memory
        158           SetITSTATEAndCommit(psr.IT);                             // Load valid ITSTATE from memory
        159                                                                    // (also handles ICI and ECI)
        160       else
        161           APSR[31:28]             = psr[31:28];                    // Load valid APSR bits from memory
        162       return exc;

E2.1.321 PreserveFPState
          1   // PreserveFPState()
          2   // =================
          3
          4   PreserveFPState()
          5       // Check if there is any lazy FP state to be preserved.
          6       isSecure = FPCCR_S.S == '1';
          7       lspact   = if isSecure then FPCCR_S.LSPACT else FPCCR_NS.LSPACT;
          8
          9       if lspact == '1' then
         10           // Preserve FP state using address, privilege and relative
         11           // priorities recorded during original stacking. Derived
         12           // exceptions are handled by TakePreserveFPException().
         13
         14              // The checks usually performed for stacking using ValidateAddress()
         15              // are performed, with the value of ExecutionPriority()
         16              // overridden by -1 if FPCCR.HFRDY == '0'.
         17
         18              if isSecure then
         19                  ispriv    = FPCCR_S.USER      == '0';
         20                  splimviol = FPCCR_S.SPLIMVIOL == '1';
         21                  fpcar     = FPCAR_S;
         22              else
         23                  ispriv    = FPCCR_NS.USER      == '0';
         24                  splimviol = FPCCR_NS.SPLIMVIOL == '1';
         25                  fpcar     = FPCAR_NS;
         26              Privilege memPriv = FindMemPriv(ispriv);
         27
         28              // Check if the background context had access to the FPU
         29              excInfo = CheckCPEnabled(10, ispriv, isSecure);
         30
         31              // Only perform the memory accesses if the stack limit hasn't been violated
         32              bfExcInfo = DefaultExcInfo();
         33              if !splimviol && excInfo.fault == NoFault then
         34                  // RAS or BusFault errors rasied before Lazy FP stacking are barriered if IESB
         35                  // is enabled. Errors that are Synchronized at this point belong to the current
         36                  // context (the context that executed the instruction that triggered the lazy
         37                  // stacking), are handled normally and not byTakePreserveFPException.
         38                  if AIRCR.IESB == '1' then
         39                      HandleException(SynchronizeBusFault());
         40
         41                 // Whether these stores are interruptible is IMPLEMENTATION DEFINED.
         42                 // Only the stack locations, not the store order, are architected.
         43                 for i = 0 to 15
         44                     if excInfo.fault == NoFault then
         45                         addr    = fpcar + (4*i);
         46                         excInfo = MemA_with_priv_security(addr, 4, AccType_LAZYFP, memPriv,
         47                                                           isSecure, TRUE, S[i]);
         48
         49                 if excInfo.fault == NoFault then
         50                     addr    = fpcar + 0x40;
         51                     excInfo = MemA_with_priv_security(addr, 4, AccType_LAZYFP, memPriv,
         52                                                       isSecure, TRUE, FPSCR);
         53                 if HaveMve() && excInfo.fault == NoFault then
         54                     addr    = fpcar + 0x44;
         55                     excInfo = MemA_with_priv_security(addr, 4, AccType_LAZYFP, memPriv,
         56                                                       isSecure, TRUE, VPR);
         57
         58                 if isSecure && FPCCR_S.TS == '1' then
         59                     for i = 0 to 15
         60                         if excInfo.fault == NoFault then
         61                             addr    = fpcar + (4*i) + 0x48;
         62                             excInfo = MemA_with_priv_security(addr, 4, AccType_LAZYFP, memPriv,
         63                                                               TRUE, TRUE, S[i+16]);
         64
         65                 // If IESB is enabled, barrier RAS / BusFault errors raised during Lazy FP
         66                 // stacking to the original context. If errors do occur, BFSR.LSPERR is set.
         67                 if AIRCR.IESB == '1' then
         68                     bfExcInfo = SynchronizeBusFault(AccType_LAZYFP);
         69
         70            // Handle any faults that have occured
         71            termInst = FALSE;
         72            if excInfo.fault != NoFault then
         73                termInst = termInst || TakePreserveFPException(excInfo);
         74            if bfExcInfo.fault != NoFault then
         75                termInst = termInst || TakePreserveFPException(bfExcInfo);
         76
         77            // If exception with sufficient priority to pre-empt current instruction execution is
         78            // raised during FP state preserve, then termInst will be true and execution of the
         79            // current instruction should be terminated by calling EndOfInstruction(). If the
         80            // exception results in a lockup state, termInst will also be true.
         81            if termInst then
         82                EndOfInstruction();
         83            else
         84                // If the FP state is being treated as Secure then the registers are zeroed
         85                InvalidateFPRegs(isSecure && FPCCR_S.TS == '1', isSecure && FPCCR_S.TS == '1');
         86
         87       // In case of NoFault or, on successful return              from TakePreserveFPException(),
         88       // the current instruction execution continues              and FPCCR.LSPACT will be cleared.
         89       // If the stores are interrupted, the register              content and LSPACT remain unchanged.
         90       if (HasArchVersion(Armv8p1) &&
         91            boolean IMPLEMENTATION_DEFINED "Clear both             LSPACTs") then
         92            FPCCR_S.LSPACT = '0';
         93            FPCCR_NS.LSPACT = '0';
         94       else
         95            if isSecure then
         96                FPCCR_S.LSPACT = '0';
         97            else
         98                FPCCR_NS.LSPACT = '0';

E2.1.322 Privilege
          1   // Memory privilege type
          2
          3   enumeration Privilege {
          4       Privilege_Priv,         // Privileged memory request
          5       Privilege_ForcedUnpriv, // Deprivileged memory request
          6       Privilege_Unpriv        // Unprivileged memory request
          7   };

E2.1.323 ProcessorID
          1   // ProcessorID
          2   // ===========
          3   // Returns an integer that uniquely identifies the executing PE in the system.
          4
          5   integer ProcessorID();

E2.1.324 PushCalleeStack
          1   // PushCalleeStack()
          2   // =================
          3
          4   ExcInfo PushCalleeStack(boolean doTailChain, EXC_RETURN_Type excReturn)
          5       // Allocate space of the correct stack. NOTE: If the PE is tail chaining the PE should
          6       // check excReturn instead of CONTROL.SPSEL to determine which stack to use,
          7       // as SPSEL can report the wrong stack in tail chaining cases
          8       if doTailChain then
          9            if excReturn.Mode == '0' then
         10                mode    = PEMode_Handler;
         11                spName = RNamesSP_Main_Secure;
         12            else
         13                mode    = PEMode_Thread;
         14                if excReturn.SPSEL == '1' then
         15                     spName = RNamesSP_Process_Secure;
         16                else
         17                     spName = RNamesSP_Main_Secure;
         18       else
         19            spName = LookUpSP();
         20            mode   = CurrentMode();
         21
         22       // Calculate the address of the base of the callee frame
         23       bits(32) frameptr = _SP(spName) - 0x28;
         24
         25       /* only the stack locations, not the store order, are architected */
         26       // Write out integrity signature
         27       if HaveMveOrFPExt() then
         28            integritySig = 0xFEFA125A[31:1] : excReturn.FType;
         29       else
         30            integritySig = 0xFEFA125B[31:0];
         31       exc = Stack(frameptr, 0x0, spName, mode, integritySig);
         32       // Stack callee registers
         33       if exc.fault == NoFault then exc = Stack(frameptr, 0x8, spName, mode,                   R[4]);
         34       if exc.fault == NoFault then exc = Stack(frameptr, 0xC, spName, mode,                   R[5]);
         35       if exc.fault == NoFault then exc = Stack(frameptr, 0x10, spName, mode,                  R[6]);
         36       if exc.fault == NoFault then exc = Stack(frameptr, 0x14, spName, mode,                  R[7]);
         37       if exc.fault == NoFault then exc = Stack(frameptr, 0x18, spName, mode,                  R[8]);
         38       if exc.fault == NoFault then exc = Stack(frameptr, 0x1C, spName, mode,                  R[9]);
         39       if exc.fault == NoFault then exc = Stack(frameptr, 0x20, spName, mode,                  R[10]);
         40       if exc.fault == NoFault then exc = Stack(frameptr, 0x24, spName, mode,                  R[11]);
         41
         42       // Update the stack pointer
         43       spExc = _SP(spName, TRUE, FALSE, frameptr);
         44       return MergeExcInfo(exc, spExc);

E2.1.325 PushStack
          1   // PushStack()
          2   // ===========
          3
          4   (ExcInfo, EXC_RETURN_Type) PushStack()
          5       constant integer intFrameSize      = 0x20;
          6       constant integer fpCallerFrameSize = 0x48;
          7       constant integer fpCalleeFrameSize = 0x40;
          8
          9       boolean pushFPCallerFrame = HaveMveOrFPExt() && CONTROL.FPCA == '1';
         10       boolean pushFPCalleeFrame = pushFPCallerFrame && IsSecure() && FPCCR_S.TS == '1';
         11
         12       integer framesize = intFrameSize;
         13       // In the case where a NOCP usage fault is generated, FP stack space is not allocated
         14       if IsSecure() || NSACR.CP10 == '1' then
         15           if pushFPCallerFrame then framesize = framesize + fpCallerFrameSize;
         16           if pushFPCalleeFrame then framesize = framesize + fpCalleeFrameSize;
         17
         18       /* allocate space on the correct stack */
         19       bits(1) frameptralign;
         20       frameptralign = SP[2];
         21       frameptr      = (SP - framesize) AND NOT(ZeroExtend('100',32));
         22       spName        = LookUpSP();
         23
         24       // Prepare architecture state for stacking
         25       RETPSR_Type retpsr = XPSR[31:0];
         26       retpsr.SPREALIGN   = frameptralign;
         27       retpsr.SFPA        = if IsSecure() then CONTROL_S.SFPA else '0';
         28       mode               = CurrentMode();
         29
         30       /* only the stack locations, not the store order, are architected */
         31       exc                              = Stack(frameptr, 0x0, spName, mode,                   R[0]);
         32       if exc.fault == NoFault then exc = Stack(frameptr, 0x4, spName, mode,                   R[1]);
         33       if exc.fault == NoFault then exc = Stack(frameptr, 0x8, spName, mode,                   R[2]);
         34       if exc.fault == NoFault then exc = Stack(frameptr, 0xC, spName, mode,                   R[3]);
         35       if exc.fault == NoFault then exc = Stack(frameptr, 0x10, spName, mode,                  R[12]);
         36       if exc.fault == NoFault then exc = Stack(frameptr, 0x14, spName, mode,                  LR);
         37       // Push the address of the next instruction, this is the raw PC value,                  without
         38       // the +4 that is observed when reading PC from within instructions
         39       if exc.fault == NoFault then exc = Stack(frameptr, 0x18, spName, mode,                  _RName[RNamesPC]);
         40       if exc.fault == NoFault then exc = Stack(frameptr, 0x1C, spName, mode,                  retpsr);
         41       frameOffset = intFrameSize;
         42
         43       if pushFPCallerFrame then
         44           newExc = DefaultExcInfo();
         45           // LSPACT should not be active at the same time as CONTROL.FPCA. This
         46           // is a possible attack scenario so raise a SecureFault.
         47           lspact = if FPCCR_S.S == '1' then FPCCR_S.LSPACT else FPCCR_NS.LSPACT;
         48           if HaveSecurityExt() && lspact == '1' then
         49               SFSR.LSERR = '1';
         50               newExc     = CreateException(SecureFault);
         51           elsif !IsSecure() && NSACR.CP10 == '0' then
         52               UFSR_S.NOCP = '1';
         53               newExc      = CreateException(UsageFault, TRUE, TRUE);
         54           elsif FPCCR.LSPEN == '0' then
         55               if exc.fault == NoFault then
         56                   exc = CheckCPEnabled(10);
         57
         58                if exc.fault == NoFault then
         59                    for i = 0 to 15
         60                        if exc.fault == NoFault then
         61                            exc = Stack(frameptr, frameOffset + (4*i), spName, mode, S[i]);
         62                    if exc.fault == NoFault then
         63                        exc = Stack(frameptr, frameOffset + 0x40, spName, mode, FPSCR);
         64                    if HaveMve() && exc.fault == NoFault then
         65                        exc = Stack(frameptr, frameOffset + 0x44, spName, mode, VPR);
         66                    frameOffset = frameOffset + fpCallerFrameSize;
         67
         68                     if pushFPCalleeFrame then
         69                         for i = 0 to 15
         70                             if exc.fault == NoFault then
         71                                 exc = Stack(frameptr, frameOffset+(4*i), spName, mode, S[i+16]);
         72
         73               (cpEnabled, -) = IsCPEnabled(10);
         74               if cpEnabled then
         75                   InvalidateFPRegs(pushFPCalleeFrame, pushFPCalleeFrame);
         76           else
         77               UpdateFPCCR(frameptr + frameOffset, TRUE);
         78
         79           if newExc.fault != NoFault then
         80               // It is IMPLEMENTATION_DEFINED whether to drop the earlier MemFault
         81               // if the Secure fault or NOCP fault is also generated subsequently.
         82               // If MemFault is not dropped, it will be merged with Secure/NOCP fault
         83               // based on exception priority as per MergeExcInfo().
         84               if boolean IMPLEMENTATION_DEFINED "Drop previously generated exceptions" then
         85                   exc = newExc;
         86                else
         87                       exc = MergeExcInfo(exc, newExc);
         88
         89       // Set the stack pointer to be at the bottom of the new stack frame
         90       spExc = _SP(spName, TRUE, FALSE, frameptr);
         91       exc   = MergeExcInfo(exc, spExc);
         92
         93       // Some excReturn bits (for example ES, SPSEL) are set                 by ExceptionTaken
         94       EXC_RETURN_Type partialExcReturn = 0xFFFFFFF8[31:0];
         95       partialExcReturn.S     = if IsSecure()            then                 '1'               else '0';
         96       partialExcReturn.FType = if HaveMveOrFPExt()      then                 NOT(CONTROL.FPCA) else '1';
         97       partialExcReturn.Mode = if mode == PEMode_Thread then                  '1'               else '0';
         98       return (exc, partialExcReturn);

E2.1.326 Q
          1   // Q[] - non-assignment forms
          2   // ==========================
          3
          4   bits(32) Q[integer idx, integer beat]
          5       assert idx >= 0 && idx <= 7;
          6       assert beat >= 0 && beat <= 3;
          7       return S[(idx * 4) + beat];
          8
          9
         10   // Q[] - assignment forms
         11   // ======================
         12
         13   Q[integer idx, integer beat] = bits(32) value
         14       assert idx >= 0 && idx <= 7;
         15       assert beat >= 0 && beat <= 3;
         16       S[(idx * 4) + beat] = value;

E2.1.327 R
          1   // R[]
          2   // ===
          3
          4   // Non-assignment form
          5
          6   bits(32) R[integer n]
          7       return RName[LookUpRName(n)];
          8
          9   // Assignment form
         10
         11   R[integer n] = bits(32) value
         12       assert n != 15;
         13       RName[LookUpRName(n)] = value;
         14       return;

E2.1.328 RaiseAsyncBusFault
          1   // RaiseAsyncBusFault()
          2   // ====================
          3
          4   RaiseAsyncBusFault()
          5       if HaveMainExt() then
          6           BFSR.IMPRECISERR = '1';
          7
          8       // To ensure errors are containable asnychronous BusFaults escalate as if they were
          9       // synchronous if implicit error synchronization barriers are enabled.
         10       handleSynchronously = AIRCR.IESB == '1';
         11       excInfo             = CreateException(BusFault, FALSE, IsSecure(), handleSynchronously);
         12       HandleException(excInfo);

E2.1.329 RawExecutionPriority
          1   // RawExecutionPriority()
          2   // ======================
          3   // Determine the current execution priority without the effect of priority boosting
          4
          5   integer RawExecutionPriority()
          6       execPri = HighestPri();
          7       for i = 2 to MaxExceptionNum() // IPSR values of the exception handlers
          8           for j = 0 to 1             // Check both Non-secure and Secure exceptions
          9               secure = (j == 0);
         10               if IsActiveForState(i, secure) then
         11                   // PRIGROUP effect applied in ExceptionPriority
         12                   effectivePriority = ExceptionPriority(i, secure, TRUE);
         13                   if effectivePriority < execPri then
         14                       execPri = effectivePriority;
         15       assert execPri IN {-4 .. 256};
         16       return execPri;

E2.1.330 Replicate
          1   // Replicate()
          2   // ===========
          3
          4   bits(M*N) Replicate(bits(M) x, integer N);
          5
          6   bits(N) Replicate(bits(M) x)
          7       assert N MOD M == 0;
          8       return Replicate(x, N DIV M);

E2.1.331 ResetRegs
          1   //   ResetRegs
          2   //   ============
          3   //   Sets all registers that have architecturally-defined reset
          4   //   values to those values
          5
          6   ResetRegs();

E2.1.332 RestrictedNSPri
          1   // RestrictedNSPri()
          2   // =================
          3   // The priority to which Non-secure exceptions are restricted if AIRCR.PRIS is set
          4
          5   integer RestrictedNSPri()
          6       return 0x80;

E2.1.333 RF
          1   // RF[] - non-assignment form
          2   // ==========================
          3
          4   bits(32) RF[integer n]
          5       assert n >= 0 && n <= 15;
          6
          7        // Returns the selected general-purpose register for indices less than 15,
          8        // or the APSR Condition flags for the index 15.
          9
         10        if n < 15 then
         11             result = R[n];
         12        else
         13             result = APSR[31:28] : Zeros(28);
         14
         15       return result;
         16
         17   // RF[] - assignment form
         18   // ======================
         19
         20   RF[integer n] = bits(32) value
         21       assert n >= 0 && n <= 15;
         22
         23       // Assigns a value to the selected general-purpose register for indices
         24       // less than 15, or the APSR Condition flags for the index 15.
         25
         26       if n < 15 then
         27            R[n] = value;
         28       else
         29            APSR.N = value[31];
         30            APSR.Z = value[30];
         31            APSR.C = value[29];
         32            APSR.V = value[28];

E2.1.334 RFD
          1   // RFD[] - non-assignment form
          2   // ===========================
          3
          4   bits(64) RFD[integer n]
          5       assert n >= 0 && n <= 14;
          6       assert n[0] == '0';
          7
          8       // Returns the selected general-purpose register pair
          9       // Register pairs containing SP or PC are UNPREDICTABLE
         10       if n > 10 then UNPREDICTABLE;
         11
         12       result = R[n+1]:R[n];
         13       return result;
         14
         15   // RFD[] - assignment form
         16   // ======================
         17
         18   RFD[integer n] = bits(64) value
         19       assert n >= 0 && n <= 14;
         20       assert n[0] == '0';
         21
         22       // Assigns a value to the selected general-purpose register pair
         23       // Register pairs containing SP or PC are UNPREDICTABLE
         24       if n > 10 then UNPREDICTABLE;
         25
         26       R[n+1] = value[63:32];
         27       R[n]   = value[31:0];

E2.1.335 RName
          1   // RName[] - assignment form
          2   // =========================
          3
          4   RName[RNames reg] = bits(32) value
          5       case reg of
          6           when {RNamesSP_Main_NonSecure, RNamesSP_Process_NonSecure,
          7                 RNamesSP_Main_Secure,    RNamesSP_Process_Secure}
          8               // It is IMPLEMENTATION DEFINED whether stack pointer limit checking
          9               // is performed for instructions that were previously UNPREDICTABLE
         10               // when modifying the stack pointer.
         11               applyLimit = boolean IMPLEMENTATION_DEFINED "SPLim check UNPRED instructions";
         12               exc = _SP(reg, FALSE, !applyLimit, value);
         13               assert applyLimit || exc.fault == NoFault;
         14           when RNamesPC
         15               // Direct PC writes not supported, PC updates must go through
         16               // LoadWritePC(), BranchReturn() or similar function
         17               assert FALSE;
         18           otherwise
         19               _RName[reg] = value;
         20       return;
         21
         22   // RName[] - non-assignment form
         23   // =============================
         24
         25   bits(32) RName[RNames reg]
         26       bits(32) result;
         27       case reg of
         28           when {RNamesSP_Main_NonSecure, RNamesSP_Process_NonSecure,
         29                 RNamesSP_Main_Secure,    RNamesSP_Process_Secure}
         30               result = _RName[reg][31:2]:'00';
         31           when RNamesPC
         32               result = _RName[RNamesPC] + 4;
         33           otherwise
         34               result = _RName[reg];
         35       return result;

E2.1.336 RNames
          1   // The names of the core registers. SP is a Banked register.
          2
          3   enumeration RNames {RNames0, RNames1, RNames2, RNames3, RNames4, RNames5, RNames6,
          4                       RNames7, RNames8, RNames9, RNames10, RNames11, RNames12,
          5                       RNamesSP_Main_Secure, RNamesSP_Main_NonSecure,
          6                       RNamesLR, RNamesPC,
          7                       RNamesSP_Process_NonSecure, RNamesSP_Process_Secure};

E2.1.337 ROR
          1   // ROR()
          2   // =====
          3
          4   bits(N) ROR(bits(N) x, integer shift)
          5       if shift == 0 then
          6            result = x;
          7       else
          8            (result, -) = ROR_C(x, shift);
          9       return result;

E2.1.338 ROR_C
          1   // ROR_C()
          2   // =======
          3
          4   (bits(N), bit) ROR_C(bits(N) x, integer shift)
          5       assert shift != 0;
          6       m = shift MOD N;
          7       result = LSR(x,m) OR LSL(x,N-m);
          8       carry_out = result[N-1];
          9       return (result, carry_out);

E2.1.339 RotCell
          1   // RotCell()
          2   // =========
          3
          4   bits(4) RotCell(bits(4) inCell, integer amount)
          5       bits(8) tmp;
          6       bits(4) outCell;
          7
          8       // assert amount>3 || amount<1;
          9       tmp[7:0] = inCell[3:0]:inCell[3:0];
         10       outCell = tmp[7-amount:4-amount];
         11       return outCell;

E2.1.340 RoundDown
          1   // RoundDown()
          2   // ===========
          3
          4   integer RoundDown(real x);

E2.1.341 RoundTowardsZero
          1   // RoundTowardsZero()
          2   // ==================
          3
          4   integer RoundTowardsZero(real x)
          5       return if x == 0.0 then 0 else if x > 0.0 then RoundDown(x) else RoundUp(x);

E2.1.342 RoundUp
          1   // RoundUp()
          2   // =========
          3
          4   integer RoundUp(real x);

E2.1.343 RRX
          1   // RRX()
          2   // =====
          3
          4   bits(N) RRX(bits(N) x, bit carry_in)
          5       (result, -) = RRX_C(x, carry_in);
          6       return result;

E2.1.344 RRX_C
          1   // RRX_C()
          2   // =======
          3
          4   (bits(N), bit) RRX_C(bits(N) x, bit carry_in)
          5       result = carry_in : x[N-1:1];
          6       carry_out = x[0];
          7       return (result, carry_out);

E2.1.345 RSPCheck
          1   // RSPCheck[] - assignment form
          2   // ============================
          3
          4   RSPCheck[integer n] = bits(32) value
          5       if n == 13 then
          6            - = _SP(LookUpSP(), FALSE, FALSE, value);
          7       else
          8            R[n] = value;
          9       return;

E2.1.346 RZ
          1   // RZ[] -- Read R15 as zero
          2   // ========================
          3
          4   bits(32) RZ[integer n]
          5       assert n >= 0 && n <= 15;
          6       if n == 15 then
          7            return Zeros(32);
          8       else
          9            return R[n];

E2.1.347 S
          1   // S[]
          2   // ===
          3
          4   // Non-assignment form
          5
          6   bits(32) S[integer n]
          7       assert n >= 0 && n <= 31;
          8       return _S[n];
          9
         10   // Assignment form
         11
         12   S[integer n] = bits(32) value
         13       assert n >= 0 && n <= 31;
         14       _S[n] = value;
         15       return;

E2.1.348 Sat
          1   // Sat()
          2   // =====
          3
          4   bits(N) Sat(integer i, integer N, boolean unsigned)
          5       result = if unsigned then UnsignedSat(i, N) else SignedSat(i, N);
          6       return result;

E2.1.349 SatQ
          1   // SatQ()
          2   // ======
          3
          4   (bits(N), boolean) SatQ(integer i, integer N, boolean unsigned)
          5       (result, sat) = if unsigned then UnsignedSatQ(i, N) else SignedSatQ(i, N);
          6       return (result, sat);

E2.1.350 SAttributes
          1   // Security attributes associated with an address
          2
          3   type SAttributes is (
          4       boolean nsc,                //   Non-secure callability of an address. FALSE = not
          5                                   //   callable from the Non-secure state
          6       boolean   ns,               //   Security of an address FALSE = Secure, TRUE = Non-secure
          7       bits(8)   sregion,          //   The SAU region number
          8       boolean   srvalid,          //   Set to 1 if the SAU region number is valid
          9       bits(8)   iregion,          //   The IDAU region number
         10       boolean   irvalid           //   Set to 1 if the IDAU region number is valid
         11   )

E2.1.351 SCS_UpdateStatusRegs
          1   // SCS_UpdateStatusRegs()
          2   // ======================
          3   // Update status registers in the System Control Space (SCS)
          4
          5   SCS_UpdateStatusRegs();

E2.1.352 SecureDebugMonitorAllowed
          1   // SecureDebugMonitorAllowed()
          2   // ===========================
          3
          4   boolean SecureDebugMonitorAllowed()
          5       if DAUTHCTRL_S.FSDMA == '1' then
          6            return TRUE;
          7       elsif DAUTHCTRL_S.SPIDENSEL == '1' then
          8            return DAUTHCTRL_S.INTSPIDEN == '1';
          9       else
         10            return ExternalSecureSelfHostedDebugEnabled();

E2.1.353 SecureHaltingDebugAllowed
          1   // SecureHaltingDebugAllowed()
          2   // ===========================
          3
          4   boolean SecureHaltingDebugAllowed()
          5       if HaltingDebugAllowed() == FALSE then
          6            return FALSE;
          7       elsif DAUTHCTRL_S.SPIDENSEL == '1' then
          8            return DAUTHCTRL_S.INTSPIDEN == '1';
          9       else
         10            return ExternalSecureInvasiveDebugEnabled();

E2.1.354 SecureNoninvasiveDebugAllowed
          1   // SecureNoninvasiveDebugAllowed()
          2   // ===============================
          3
          4   boolean SecureNoninvasiveDebugAllowed(boolean isPriv)
          5       assert HaveSecurityExt();
          6       if DHCSR.S_SDE == '1' && (!HaveUDE() || DHCSR.S_SUIDE == '0') then
          7            return TRUE;
          8       elsif !isPriv && UnprivHaltingDebugEnabled(TRUE) then
          9            return TRUE;
         10       elsif !NoninvasiveDebugAllowed(isPriv) then
         11            return FALSE;
         12       elsif DAUTHCTRL_S.SPNIDENSEL == '1' then
         13            return DAUTHCTRL_S.INTSPNIDEN == '1';
         14       else
         15            return ExternalSecureNoninvasiveDebugEnabled();
         16
         17
         18   boolean SecureNoninvasiveDebugAllowed()
         19       return SecureNoninvasiveDebugAllowed(CurrentModeIsPrivileged());

E2.1.355 SecurityCheck
          1   // SecurityCheck()
          2   // ===============
          3
          4   SAttributes SecurityCheck(bits(32) address, boolean isinstrfetch, boolean isSecure)
          5       SAttributes result;
          6       addr = UInt(address);
          7
          8       // Setup default attributes
          9       result.ns          =   !HaveSecurityExt();
         10       result.nsc         =   FALSE;
         11       result.sregion     =   Zeros(8);
         12       result.srvalid     =   FALSE;
         13       result.iregion     =   Zeros(8);
         14       result.irvalid     =   FALSE;
         15       idauExempt         =   FALSE;
         16       idauNs             =   TRUE;
         17       idauNsc            =   TRUE;
         18
         19       //   If an IMPLEMENTATION DEFINED memory security attribution unit is present
         20       //   query it and override defaults set above. The IDAU is subject to the same
         21       //   32byte minimum region granularity as the SAU/MPU.
         22       //   NOTE: The defaults above are set such that the IDAU has no effect on the
         23       //         SAU.
         24       if   boolean IMPLEMENTATION_DEFINED "IDAU present" then
         25             (idauExempt,
         26              idauNs,
         27              idauNsc,
         28              result.iregion,
         29              result.irvalid) = IDAUCheck(address[31:5]:'00000');
         30
         31       // The 0xF0000000 -> 0xFFFFFFFF is always Secure for instruction fetches
         32       if isinstrfetch && (address[31:28] == '1111') then
         33           // Use default attributes defined above
         34
         35       // Check if the address is exempt from SAU/IDAU checking.
         36       elsif idauExempt                                     ||   // IDAU specified exemption
         37             (isinstrfetch && (address[31:28] == '1110'))   ||   // Whole 0xExxxxxxx range
         38                                                                 // exempt for IFetch
         39             ((addr >= 0xE0000000) && (addr <= 0xE0003FFF)) ||   // ITM, DWT, FPB, PMU
         40             ((addr >= 0xE0005000) && (addr <= 0xE0005FFF)) ||   // RAS error record registers
         41             ((addr >= 0xE000E000) && (addr <= 0xE000EFFF)) ||   // SCS
         42             ((addr >= 0xE002E000) && (addr <= 0xE002EFFF)) ||   // SCS NS alias
         43             ((addr >= 0xE0040000) && (addr <= 0xE0041FFF)) ||   // TPIU, ETM
         44             ((addr >= 0xE00FF000) && (addr <= 0xE00FFFFF)) then // ROM table
         45           // memory security reported as NS-Req, and no region information is supplied.
         46           result.ns      = !isSecure;
         47           result.irvalid = FALSE;
         48
         49       else
         50              // If the SAU is enabled check its regions
         51              if SAU_CTRL.ENABLE == '1' then
         52                  boolean multiRegionHit = FALSE;
         53                  for r = 0 to (UInt(SAU_TYPE.SREGION) - 1)
         54                      if SAU_REGION[r].ENABLE == '1' then
         55                          // SAU region enabled so perform checks
         56                          bits(32) base_address = SAU_REGION[r].BADDR:'00000';
         57                          bits(32) limit_address = SAU_REGION[r].LADDR:'11111';
         58                          if ((UInt(base_address) <= addr) &&
         59                              (UInt(limit_address) >= addr)) then
         60                              if result.srvalid then
         61                                  multiRegionHit = TRUE;
         62                              else
         63                                  result.ns       = SAU_REGION[r].NSC == '0';
         64                                  result.nsc      = SAU_REGION[r].NSC == '1';
         65                                  result.srvalid = TRUE;
         66                                  result.sregion = r[7:0];
         67
         68                 //   If multiple regions are hit then report memory as Secure and not
         69                 //   Non-secure callable. Also don't report any region number
         70                 //   information.
         71                 if   multiRegionHit then
         72                       result.ns      = FALSE;
         73                       result.nsc     = FALSE;
         74                       result.sregion = Zeros(8);
         75                       result.srvalid = FALSE;
         76
         77              // SAU disabled, check if whole address space should be marked as
         78             // Non-secure
         79             elsif SAU_CTRL.ALLNS == '1' then
         80                 result.ns = TRUE;
         81
         82             // Override the internal setting if the external attribution unit
         83             // reports more restrictive attributes.
         84             if !idauNs then
         85                 if result.ns || (!idauNsc && result.nsc) then
         86                     result.ns = FALSE;
         87                     result.nsc = idauNsc;
         88
         89        return result;

E2.1.356 SecurityState
          1   // Type and definition of the current Security state of PE
          2
          3   enumeration SecurityState {SecurityState_NonSecure, SecurityState_Secure};
          4   SecurityState CurrentState;

E2.1.357 SendEvent
          1   // SendEvent
          2   // =========
          3   // Performs a send event by setting the Event Register of every PE in multiprocessor system
          4
          5   SendEvent();

E2.1.358 SerializeVFP
          1   //   SerializeVFP
          2   //   ============
          3   //   Ensures that any exceptional conditions in previous floating-point
          4   //   instructions have been detected
          5
          6   SerializeVFP();

E2.1.359 SetActive
          1   // SetActive()
          2   // ===========
          3
          4   SetActive(integer exception, boolean isSecure, boolean setNotClear)
          5       if !HaveSecurityExt() then
          6            isSecure = FALSE;
          7       // If the exception target state is configurable there is only one active
          8       // bit. To represent this the Non-secure and Secure instances of the active
          9       // flags in the array are always set to the same value.
         10       if IsExceptionTargetConfigurable(exception) then
         11            if ExceptionTargetsSecure(exception, boolean UNKNOWN) == isSecure then
         12                ExceptionActive[exception] = if setNotClear then '11' else '00';
         13       else
         14            idx = if isSecure then 0 else 1;
         15            ExceptionActive[exception][idx] = if setNotClear then '1' else '0';

E2.1.360 SetDWTDebugEvent
          1   // SetDWTDebugEvent()
          2   // ==================
          3   // Set a pending debug event to the PE
          4
          5   boolean SetDWTDebugEvent(boolean secure_match, boolean priv_match)
          6       if CanHaltOnEvent(secure_match, priv_match) then
          7            DHCSR.C_HALT = '1';
          8            DFSR.DWTTRAP = '1';
          9            return TRUE;
         10       elsif (HaveMainExt() &&
         11               CanPendMonitorOnEvent(secure_match, TRUE, TRUE, priv_match, TRUE)) then
         12            DEMCR.MON_PEND = '1';
         13            DFSR.DWTTRAP = '1';
         14            return TRUE;
         15       else
         16            return FALSE;

E2.1.361 SetEventRegister
          1   // SetEventRegister()
          2   // ==================
          3   // Set the Event Register of the current PE
          4
          5   SetEventRegister();

E2.1.362 SetExclusiveMonitors
          1   // SetExclusiveMonitors()
          2   // ======================
          3
          4   SetExclusiveMonitors(bits(32) address, integer size)
          5
          6       boolean isSecure = CurrentState == SecurityState_Secure;
          7       if address != Align(address, size) then
          8            UFSR.UNALIGNED = '1';
          9            excInfo = CreateException(UsageFault, FALSE, isSecure);
         10       else
         11            (excInfo, memaddrdesc) = ValidateAddress(address, AccType_NORMAL, FindPriv(),
         12                                                     isSecure, FALSE, TRUE);
         13       HandleException(excInfo);
         14
         15       if memaddrdesc.memattrs.shareable then
         16           MarkExclusiveGlobal(memaddrdesc.paddress, ProcessorID(), size);
         17
         18       MarkExclusiveLocal(memaddrdesc.paddress, ProcessorID(), size);

E2.1.363 SetITSTATEAndCommit
          1   // SetITSTATEAndCommit()
          2   // =====================
          3
          4   SetITSTATEAndCommit(ITSTATEType it)
          5       // This function directly commits the change to the ITSTATE, so ThisInstrITSTATE()
          6       // and NextInstrITSTATE() both point to the target address.
          7       _NextInstrITState = it;
          8       _ITStateChanged   = TRUE;
          9       EPSR.IT           = it;
         10       return;

E2.1.364 SetPending
          1   // SetPending()
          2   // ============
          3
          4   SetPending(integer exception, boolean isSecure, boolean setNotClear)
          5       if !HaveSecurityExt() then
          6           isSecure = FALSE;
          7       // If the exception target state is configurable there is only one pending
          8       // bit. To represent this, the Non-secure and Secure instances of the pending
          9       // flags in the array are always set to the same value.
         10       if IsExceptionTargetConfigurable(exception) then
         11            ExceptionPending[exception] = if setNotClear then '11' else '00';
         12       else
         13            idx = if isSecure then 0 else 1;
         14            ExceptionPending[exception][idx] = if setNotClear then '1' else '0';

E2.1.365 SetThisInstrDetails
          1   // SetThisInstrDetails
          2   // ===================
          3
          4   SetThisInstrDetails(bits(32) opcode, integer len)
          5       // Insert the instruction into the queue at the first free slot. For
          6       // instruction with no beat behavior this should always be the first slot.
          7       // NOTE: MVE instructions in IT blocks do not have beat-wise execution.
          8       i          = 0;
          9       isBeatInst = IsMveBeatWiseInstruction(opcode) && !InITBlock();
         10       repeat
         11           emptySlot = !_InstInfo[i].Valid;
         12           if emptySlot && (isBeatInst || i == 0) then
         13               _InstInfo[i].Valid = TRUE;
         14               _InstInfo[i].Length = len;
         15               _InstInfo[i].Opcode = opcode;
         16           i = i + 1;
         17       until emptySlot || (!isBeatInst && i > 0) || (i >= MAX_OVERLAPPING_INSTRS);

E2.1.366 SetVPTMask
          1   // SetVPTMask()
          2   // ============
          3
          4   SetVPTMask(integer beat, bits(4) mask)
          5       // Only one mask field is available for each pair of beats.
          6       assert beat[0] == '1';
          7       Elem[VPR[23:16], beat DIV 2, 4] = mask;
          8       // Since the mask has been modified do not advance the VPT state after this
          9       // instruction beat.
         10       _AdvanceVPTState = FALSE;

E2.1.367 Shift
          1   // Shift()
          2   // =======
          3
          4   bits(N) Shift(bits(N) value, SRType sr_type, integer amount, bit carry_in)
          5       (result, -) = Shift_C(value, sr_type, amount, carry_in);
          6       return result;

E2.1.368 Shift_C
          1   // Shift_C()
          2   // =========
          3
          4   (bits(N), bit) Shift_C(bits(N) value, SRType sr_type, integer amount, bit carry_in)
          5       assert !(sr_type == SRType_RRX && amount != 1);
          6
          7       if amount == 0 then
          8            (result, carry_out) = (value, carry_in);
          9       else
         10            case sr_type of
         11                when SRType_LSL
         12                    (result, carry_out) = LSL_C(value, amount);
         13                when SRType_LSR
         14                    (result, carry_out) = LSR_C(value, amount);
         15                 when SRType_ASR
         16                     (result, carry_out) = ASR_C(value, amount);
         17                 when SRType_ROR
         18                     (result, carry_out) = ROR_C(value, amount);
         19                 when SRType_RRX
         20                     (result, carry_out) = RRX_C(value, carry_in);
         21
         22        return (result, carry_out);

E2.1.369 SignedSat
          1   // SignedSat()
          2   // ===========
          3
          4   bits(N) SignedSat(integer i, integer N)
          5       (result, -) = SignedSatQ(i, N);
          6       return result;

E2.1.370 SignedSatQ
          1   // SignedSatQ()
          2   // ============
          3
          4   (bits(N), boolean) SignedSatQ(integer i, integer N)
          5       if i > 2^(N-1) - 1 then
          6            result = 2^(N-1) - 1; saturated = TRUE;
          7       elsif i < -(2^(N-1)) then
          8            result = -(2^(N-1)); saturated = TRUE;
          9       else
         10            result = i; saturated = FALSE;
         11       return (result[N-1:0], saturated);

E2.1.371 SignExtend
          1   // SignExtend()
          2   // ============
          3
          4   bits(N) SignExtend(bits(M) x, integer N)
          5       assert N >= M;
          6       return Replicate(x[M-1], N-M) : x;
          7
          8   bits(N) SignExtend(bits(M) x)
          9       return SignExtend(x, N);

E2.1.372 Sleeping
          1   // Indicates the PE is sleeping
          2
          3   boolean Sleeping;

E2.1.373 SleepOnExit
          1   //   SleepOnExit()
          2   //   =============
          3   //   Optionally returns PE to a power-saving mode on return from the only
          4   //   active exception
          5
          6   SleepOnExit();

E2.1.374 SP
          1   // SP
          2   // ==
          3
          4   // Non-assignment form
          5
          6   bits(32) SP
          7       return R[13];
          8
          9   // Assignment form
         10
         11   SP = bits(32) value
         12       RSPCheck[13] = value;

E2.1.375 SP_Main
          1   // SP_Main
          2   // =======
          3
          4   // Non-assignment form
          5
          6   bits(32) SP_Main
          7       value = if IsSecure() then SP_Main_Secure else SP_Main_NonSecure;
          8       return value;
          9
         10   // Assignment form
         11
         12   SP_Main = bits(32) value
         13       if IsSecure() then
         14            SP_Main_Secure    = value;
         15       else
         16            SP_Main_NonSecure = value;

E2.1.376 SP_Main_NonSecure
          1   // SP_Main_NonSecure
          2   // =================
          3
          4   // Non-assignment form
          5
          6   bits(32) SP_Main_NonSecure
          7       return _SP(RNamesSP_Main_NonSecure);
          8
          9   // Assignment form
         10
         11   SP_Main_NonSecure = bits(32) value
         12       - = _SP(RNamesSP_Main_NonSecure, FALSE, FALSE, value);

E2.1.377 SP_Main_Secure
          1   // SP_Main_Secure
          2   // ==============
          3
          4   // Non-assignment form
          5
          6   bits(32) SP_Main_Secure
          7       return _SP(RNamesSP_Main_Secure);
          8
          9   // Assignment form
         10
         11   SP_Main_Secure = bits(32) value
         12       - = _SP(RNamesSP_Main_Secure, FALSE, FALSE, value);

E2.1.378 SP_Process
          1   // SP_Process
          2   // ==========
          3
          4   // Non-assignment form
          5
          6   bits(32) SP_Process
          7       value = if IsSecure()
          8               then SP_Process_Secure else SP_Process_NonSecure;
          9       return value;
         10
         11   // Assignment form
         12
         13   SP_Process = bits(32) value
         14       if IsSecure() then
         15            SP_Process_Secure    = value;
         16       else
         17            SP_Process_NonSecure = value;

E2.1.379 SP_Process_NonSecure
          1   // SP_Process_NonSecure
          2   // ====================
          3
          4   // Non-assignment form
          5
          6   bits(32) SP_Process_NonSecure
          7       return _SP(RNamesSP_Process_NonSecure);
          8
          9   // Assignment form
         10
         11   SP_Process_NonSecure = bits(32) value
         12       - = _SP(RNamesSP_Process_NonSecure, FALSE, FALSE, value);

E2.1.380 SP_Process_Secure
          1   // SP_Process_Secure
          2   // =================
          3
          4   // Non-assignment form
          5
          6   bits(32) SP_Process_Secure
          7       return _SP(RNamesSP_Process_Secure);
          8
          9   // Assignment form
         10
         11   SP_Process_Secure = bits(32) value
         12       - = _SP(RNamesSP_Process_Secure, FALSE, FALSE, value);

E2.1.381 SpeculativeSynchronizationBarrier
          1   // Speculative Synchronisation Barrier
          2   // ===================================
          3   // Perform a Speculative Synchronization Barrier
          4
          5   SpeculativeSynchronizationBarrier();

E2.1.382 SRType
          1   // Different types of shift and rotate operations
          2
          3   enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX};

E2.1.383 Stack
          1   // Stack
          2   // =====
          3
          4   // Assignment form
          5
          6   ExcInfo Stack(bits(32) frameptr, integer offset, RNames spreg, PEMode mode, bits(32) value)
          7       // This function is used to perform register stacking operations that are
          8       // done around exception handling. If the stack pointer is below the stack
          9       // pointer limit but the access itself is above the limit it is
         10       // IMPLEMENTATION DEFINED whether the write is performed. If the
         11       // address of access is below the limit the access is not performed
         12       // regardless of the stack pointer value.
         13       if !ViolatesSPLim(spreg, frameptr) then
         14            doAccess = TRUE;
         15       else
         16            doAccess = boolean IMPLEMENTATION_DEFINED "Push non-violating locations";
         17
         18       address = frameptr + offset;
         19       if doAccess && !ViolatesSPLim(spreg, address) then
         20            secure = ((spreg == RNamesSP_Main_Secure)    ||
         21                      (spreg == RNamesSP_Process_Secure));
         22            // Work out if the stack operations should be privileged or not
         23            if secure then
         24                isPriv = CONTROL_S.nPRIV == '0';
         25            else
         26                isPriv = CONTROL_NS.nPRIV == '0';
         27            isPriv = isPriv || (mode == PEMode_Handler);
         28            // Finally perform the memory operations
         29            excInfo = MemA_with_priv_security(address, 4, AccType_STACK,
         30                                              FindMemPriv(isPriv), secure, TRUE, value);
         31       else
         32            excInfo = DefaultExcInfo();
         33       return excInfo;
         34
         35   // Non-assignment form
         36
         37   (ExcInfo, bits(32)) Stack(bits(32) frameptr, integer offset, RNames spreg, PEMode mode)
         38       secure = ((spreg == RNamesSP_Main_Secure)    ||
         39                  (spreg == RNamesSP_Process_Secure));
         40       // Work out if the stack operations should be privileged or not
         41       if secure then
         42            isPriv = CONTROL_S.nPRIV == '0';
         43       else
         44            isPriv = CONTROL_NS.nPRIV == '0';
         45       isPriv = isPriv || (mode == PEMode_Handler);
         46       // Finally perform the memory operations
         47       address = frameptr + offset;
         48       (excInfo, value) = MemA_with_priv_security(address, 4, AccType_STACK,
         49                                                   FindMemPriv(isPriv), secure, TRUE);
         50       return (excInfo, value);

E2.1.384 StandardFPSCRValue
          1   // StandardFPSCRValue()
          2   // ====================
          3
          4   FPSCR_Type StandardFPSCRValue()
          5       return '00000' : FPSCR.AHP : '110000' : FPSCR.FZ16 : '0000000000000000000';

E2.1.385 SteppingDebug
          1   // SteppingDebug()
          2   // ===============
          3
          4   SteppingDebug(boolean isSecure, boolean isPriv)
          5       // Process step requests, stepping must be avoided if a pending event is
          6       // already in flight.
          7       if CanHaltOnEvent(isSecure, isPriv) && DHCSR.C_STEP == '1' && DHCSR.C_HALT == '0' then
          8           // If C_STEP is set then pend a debug halt for the next instruction.
          9           DHCSR.C_HALT   = '1';
         10           DFSR.HALTED    = '1';
         11       elsif (CanPendMonitorOnEvent(isSecure, TRUE, TRUE, isPriv, TRUE) &&
         12              DEMCR.MON_STEP == '1' && DEMCR.MON_PEND == '0') then
         13           // If MON_STEP is set then pend the an exception for the next instruction.
         14           DEMCR.MON_PEND = '1';
         15           DFSR.HALTED    = '1';

E2.1.386 SynchronizeBusFault
          1   // SynchronizeBusFault()
          2   // =====================
          3
          4   ExcInfo SynchronizeBusFault()
          5       return SynchronizeBusFault(FALSE);
          6
          7   ExcInfo SynchronizeBusFault(AccType acctype)
          8       return SynchronizeBusFault(acctype == AccType_LAZYFP);
          9
         10   ExcInfo SynchronizeBusFault(boolean isLazyStatePreservation)
         11       // Force any latent BusFaults to be recognised
         12       faultDetected = BusFaultBarrier();
         13       if faultDetected then
         14            if isLazyStatePreservation then
         15                BFSR.LSPERR      = '1';
         16            else
         17                BFSR.IMPRECISERR = '1';
         18            // To ensure errors are containable, asnychronous BusFaults escalate as if they were
         19            // synchronous if Implicit Error Synchronization Barriers are enabled.
         20            handleSync = AIRCR.IESB == '1';
         21            excInfo    = CreateException(BusFault, FALSE, IsSecure(), handleSync);
         22       else
         23            excInfo = DefaultExcInfo();
         24       return excInfo;

E2.1.387 T32ExpandImm
          1   // T32ExpandImm()
          2   // ==============
          3
          4   bits(32) T32ExpandImm(bits(12) imm12)
          5
          6       // APSR.C argument to following function call does not affect the imm32 result.
          7       (imm32, -) = T32ExpandImm_C(imm12, APSR.C);
          8
          9       return imm32;

E2.1.388 T32ExpandImm_C
          1   // T32ExpandImm_C()
          2   // ================
          3
          4   (bits(32), bit) T32ExpandImm_C(bits(12) imm12, bit carry_in)
          5
          6       if imm12[11:10] == '00' then
          7
          8           case imm12[9:8] of
          9               when '00'
         10                   imm32 = ZeroExtend(imm12[7:0], 32);
         11               when '01'
         12                   if imm12[7:0] == '00000000' then UNPREDICTABLE;
         13                   imm32 = '00000000' : imm12[7:0] : '00000000' : imm12[7:0];
         14               when '10'
         15                      if imm12[7:0] == '00000000' then UNPREDICTABLE;
         16                      imm32 = imm12[7:0] : '00000000' : imm12[7:0] : '00000000';
         17                  when '11'
         18                      if imm12[7:0] == '00000000' then UNPREDICTABLE;
         19                      imm32 = imm12[7:0] : imm12[7:0] : imm12[7:0] : imm12[7:0];
         20              carry_out = carry_in;
         21
         22       else
         23
         24              unrotated_value = ZeroExtend('1':imm12[6:0], 32);
         25              (imm32, carry_out) = ROR_C(unrotated_value, UInt(imm12[11:7]));
         26
         27       return (imm32, carry_out);

E2.1.389 TailChain
          1   // TailChain()
          2   // ===========
          3
          4   (ExcInfo, EXC_RETURN_Type) TailChain(integer exceptionNumber,
          5                                        boolean excIsSecure,
          6                                        EXC_RETURN_Type excReturn)
          7       // Refresh LR with the excReturn value, ready for the next exception
          8       if !HaveMveOrFPExt() then
          9           excReturn.FType = '1';
         10       excReturn.PREFIX = Ones(8);
         11
         12       return ExceptionTaken(exceptionNumber, TRUE, excIsSecure, IgnoreFaults_NONE, excReturn);

E2.1.390 TakePreserveFPException
          1   // TakePreserveFPException()
          2   // =========================
          3
          4   boolean TakePreserveFPException(ExcInfo excInfo)
          5       assert HaveMveOrFPExt();
          6       assert excInfo.origFault IN {DebugMonitor, SecureFault, MemManage, BusFault, UsageFault};
          7
          8       // Get the details of the original fault so that any escalation to HardFault / Lockup
          9       // based on the current execution priority is ignored. Escalation is performed manually
         10       // against the FPCCR.*RDY fields below.
         11       exception = excInfo.origFault;
         12       isSecure = excInfo.origFaultIsSecure;
         13       fpccr     = if isSecure then FPCCR_S else FPCCR_NS;
         14
         15       if   FPCCR_S.MONRDY == '1' && FPCCR_S.HFRDY == '0' then               UNPREDICTABLE;
         16       if   FPCCR_S.BFRDY == '1' && FPCCR_S.HFRDY == '0' then                UNPREDICTABLE;
         17       if   FPCCR_S.SFRDY == '1' && FPCCR_S.HFRDY == '0' then                UNPREDICTABLE;
         18       if   fpccr.UFRDY    == '1' && FPCCR_S.HFRDY == '0' then               UNPREDICTABLE;
         19       if   fpccr.MMRDY    == '1' && FPCCR_S.HFRDY == '0' then               UNPREDICTABLE;
         20       if   exception == DebugMonitor && FPCCR_S.MONRDY == '0'               then
         21             // ignore DebugMonitor exception
         22             return FALSE;
         23
         24       // Handle exception specific details like escalation and syndrome information
         25       case exception of
         26           when MemManage
         27               escalate = fpccr.MMRDY == '0';
         28           when UsageFault
         29               escalate = fpccr.UFRDY == '0';
         30           when BusFault
         31               escalate = FPCCR_S.BFRDY == '0';
         32           when SecureFault
         33               escalate = FPCCR_S.SFRDY == '0';
         34           otherwise
         35               escalate = FALSE;
         36       if escalate then
         37           exception   = HardFault;
         38           // Faults   that originally targeted the Secure state still target the
         39           // Secure   state even if HardFault normally targets Non-secure.
         40           isSecure    = isSecure || ExceptionTargetsSecure(HardFault, isSecure);
         41
         42       // Check if the exception is enabled and has sufficient priority to
         43       // preempt and be taken straight away.
         44       termInst = FALSE;
         45       if (ExceptionPriority(exception, isSecure, TRUE) < ExecutionPriority()) &&
         46            ExceptionEnabled(exception, isSecure) then
         47            if escalate then
         48                HFSR.FORCED = '1';
         49            // Set the exception pending and terminate the current instruction. This
         50            // leaves FP disabled (that is CONTROL.FPCA set to 0) and prevents the
         51            // preempting exception entry reserving space for a redundant FP state.
         52            SetPending(exception, isSecure, TRUE);
         53            termInst = TRUE;
         54       else
         55            // If the reason the exception cannot preempt is because of the fact that
         56            // HardFault could not be entered by the context the FP state belongs to
         57            // then enter the lockup state.
         58            if FPCCR_S.HFRDY == '0' then
         59                Lockup(FALSE); // Lockup at current priority, lock-up address = 0xEFFFFFFE
         60                termInst = TRUE;
         61            else
         62                if escalate then
         63                    HFSR.FORCED = '1';
         64                // Set the exception pending so it will be taken after the current
         65                // handler returns.
         66                SetPending(exception, isSecure, TRUE);
         67       return termInst;

E2.1.391 TakeReset
          1   // TakeReset()
          2   // ===========
          3
          4   TakeReset()
          5       // If the Security Extension is implemented the PE resets into Secure state.
          6       // If the Security Extension is not implemented the PE resets into Non-secure state.
          7       if HaveSecurityExt() then
          8            CurrentState = SecurityState_Secure;
          9       else
         10            CurrentState = SecurityState_NonSecure;
         11
         12       ResetRegs();                                  // Catch-all function for System Control Space reset
         13       if HaveMainExt() then
         14            LR = Ones(32);                           // Preset to an illegal exception return value
         15            SetITSTATEAndCommit(Zeros(8));           // IT/ICI bits cleared
         16       else
         17            LR = bits(32) UNKNOWN;                   // Value must be initialised by software
         18
         19       if HaveMve() then
         20           VPR = bits(32) UNKNOWN;
         21
         22       // Reset internal run state
         23       Halted   = FALSE;
         24       LockedUp = FALSE;
         25
         26       // Initialize the Floating Point Extn
         27       if HaveMveOrFPExt() then
         28           for i = 0 to 31
         29               S[i] = bits(32) UNKNOWN;
         30
         31       for i = 0 to MaxExceptionNum()      // All exceptions Inactive
         32           ExceptionActive[i] = '00';
         33       ClearExclusiveLocal(ProcessorID()); // Synchronization (LDREX* / STREX*) monitor support
         34       ClearEventRegister();               // See WFE instruction for more information
         35       ClearInFlightInstructions();
         36       for i = 0 to 12
         37           R[i] = bits(32) UNKNOWN;
         38
         39       // Clearing stack limit registers
         40       if HaveMainExt() then
         41           MSPLIM_NS = Zeros(32);
         42           PSPLIM_NS = Zeros(32);
         43       if HaveSecurityExt() then
         44           MSPLIM_S = Zeros(32);
         45           PSPLIM_S = Zeros(32);
         46
         47       // Load the initial value of the stack pointer and the reset value from the
         48       // vector table. The order of the loads is IMPLEMENTATION DEFINED
         49       (excSp, sp)     = Vector[0,     HaveSecurityExt()];
         50       (excRst, start) = Vector[Reset, HaveSecurityExt()];
         51       if excSp.fault != NoFault || excRst.fault != NoFault then
         52           SetActive(HardFault, HaveSecurityExt(), TRUE);
         53           Lockup(TRUE);
         54
         55       // Initialize the stack pointers and start execution at the reset vector
         56       if HaveSecurityExt() then
         57            SP_Main_Secure    = sp;
         58            SP_Main_NonSecure = ((bits(30) UNKNOWN):'00');
         59            SP_Process_Secure = ((bits(30) UNKNOWN):'00');
         60       else
         61            SP_Main_NonSecure = sp;
         62       SP_Process_NonSecure = ((bits(30) UNKNOWN):'00');
         63       EPSR.T = start[0];
         64       BranchTo(start, TRUE, FALSE);
         65
         66       // Trigger a debug event even if resetting into secure state
         67       if DHCSR.C_DEBUGEN == '1' && DEMCR.VC_CORERESET == '1' &&
         68          (HasArchVersion(Armv8p1) || CanHaltOnEvent(FALSE, TRUE)) then
         69           DHCSR.C_HALT = '1';
         70           DFSR.VCATCH = '1';

E2.1.392 ThisInstr
          1   // ThisInstr()
          2   // ===========
          3
          4   bits(32) ThisInstr()
          5       return ThisInstr(if HaveMve() then _InstID else 0);
          6
          7   bits(32) ThisInstr(integer instID)
          8       if !_InstInfo[instID].Valid then
          9           return bits(32) UNKNOWN;
         10       return _InstInfo[instID].Opcode;

E2.1.393 ThisInstrAddr
          1   // ThisInstrAddr()
          2   // ===============
          3
          4   bits(32) ThisInstrAddr()
          5       return _CurrentInstrExecState.FetchAddr;

E2.1.394 ThisInstrITState
          1   // ThisInstrITState()
          2   // ==================
          3
          4   ITSTATEType ThisInstrITState()
          5       if HaveMainExt() then
          6              value = _CurrentInstrExecState.ITState;
          7       else
          8           value = Zeros(8);
          9       return value;

E2.1.395 ThisInstrLength
          1   // ThisInstrLength()
          2   // =================
          3
          4   integer ThisInstrLength()
          5       return ThisInstrLength(if HaveMve() then _InstID else 0);
          6
          7   integer ThisInstrLength(integer instID)
          8       if !_InstInfo[instID].Valid then
          9           return 0;
         10       return _InstInfo[instID].Length;

E2.1.396 TopLevel
          1   // TopLevel()
          2   // ==========
          3
          4   // This function is called one time for each tick the PE is not in a sleep
          5   // state. It handles all instruction processing, including fetching the opcode,
          6   // decode and execute. It also handles pausing execution when in the lockup
          7   // state.
          8   TopLevel()
          9       // Process any pending reset.
         10       if AIRCR_S.SYSRESETREQ == '1' then
         11           TakeReset();
         12
         13       UpdateDebugEnable();
         14       isSecure = IsSecure();
         15       isPriv   = FindPriv();
         16
         17       // Reset some globals so that PC/ITSTATE changes can be detected
         18       _ITStateChanged = FALSE;
         19       _PCChanged      = FALSE;
         20
         21       // If the PE is halted then do nothing, otherwise process the next
         22       // instruction.
         23       if !IsDebugState() then
         24           // If not locked up, process the next instruction, or just the in flight
         25           // beats if a halt or monitor exception is pending.
         26           if !LockedUp then
         27               commitState = InstructionExecute(!PendingDebugHalt() &&
         28                                                !PendingDebugMonitor());
         29               // Advance the PC and commit instruction state if not locked up, an
         30               // exception return is not about to be performed, and the current
         31               // instruction has not been terminated by a fault.
         32               if commitState && !_PendingReturnOperation then
         33                   InstructionAdvance();
         34
         35              // If a debug halt was requested and there are no active vector chains
         36              // then halt if allowed to do so.
         37              if !InstructionsInFlight() && PendingDebugHalt() then
         38                  Halt();
         39
         40              // Process any debug step requests
         41              SteppingDebug(isSecure, isPriv);
         42
         43       elsif DHCSR.C_HALT == '0' then
         44           // Resume the PE if a resume from debug halt was requested.
         45           Halted             = FALSE;
         46           DHCSR.S_RESTART_ST = '1';
         47
         48       if !IsDebugState() then
         49           try
         50               // Process and take any pending exceptions.
         51               if HandleExceptionTransitions() then
         52                   // If an exception has been taken, process any step request now,
         53                   // not on the next instruction
         54                   SteppingDebug(isSecure, isPriv);
         55
         56                      // Pend vector catch debug state when needed
         57                      VectorCatchDebug(IsSecure(), FindPriv());
         58
         59                 // If the PC has moved away from the lockup address (for example,
         60                 // because an NMI has been taken) leave the lockup state.
         61                 if LockedUp && NextInstrAddr() != 0xEFFFFFFE[31:0] then
         62                     LockedUp = FALSE;
         63
         64           catch exn
         65               // Do not catch UNPREDICTABLE or internal errors.
         66               when IsExceptionTaken(exn)
         67                   // The correct architectural behavior for any exceptions is
         68                   // performed inside HandleExceptionTransitions. So no
         69                   // additional actions are required in this catch block.

E2.1.397 TTResp
          1   // TTResp()
          2   // ========
          3
          4   bits(32) TTResp(bits(32) address, boolean alt, boolean forceunpriv)
          5       TT_RESP_Type resp = Zeros();
          6
          7       // Only allow security checks if currently in Secure state
          8       if IsSecure() then
          9           sAttributes = SecurityCheck(address, FALSE, IsSecure());
         10           if sAttributes.srvalid then
         11               resp.SREGION = sAttributes.sregion;
         12               resp.SRVALID = '1';
         13           if sAttributes.irvalid then
         14               resp.IREGION = sAttributes.iregion;
         15               resp.IRVALID = '1';
         16           addrSecure = if sAttributes.ns then '0' else '1';
         17           resp.S     = addrSecure;
         18
         19       // MPU region information only available when privileged or when
         20       // inspecting the other MPU state.
         21       other_domain = (alt != IsSecure());
         22       if CurrentModeIsPrivileged() || alt then
         23           (write, read, region, hit) = IsAccessible(address, forceunpriv, other_domain);
         24           if hit then
         25               resp.MREGION = region;
         26               resp.MRVALID = '1';
         27           resp.R = read;
         28           resp.RW = write;
         29           if IsSecure() then
         30               resp.NSR = read AND NOT addrSecure;
         31               resp.NSRW = write AND NOT addrSecure;
         32
         33       return resp;

E2.1.398 TweakCellInvRot
          1   // TweakCellInvRot()
          2   // =================
          3
          4   bits(4) TweakCellInvRot(bits(4)inCell)
          5       bits(4) outCell;
          6       outCell[3] = inCell[2];
          7       outCell[2] = inCell[1];
          8       outCell[1] = inCell[0];
          9       outCell[0] = inCell[0] EOR inCell[3];
         10       return outCell;

E2.1.399 TweakCellRot
          1   // TweakCellRot()
          2   // ==============
          3
          4   bits(4) TweakCellRot(bits(4) inCell)
          5       bits(4) outCell;
          6       outCell[3] = inCell[0] EOR inCell[1];
          7       outCell[2] = inCell[3];
          8       outCell[1] = inCell[2];
          9       outCell[0] = inCell[1];
         10       return outCell;

E2.1.400 TweakInvShuffle
          1   // TweakInvShuffle()
          2   // =================
          3
          4   bits(64) TweakInvShuffle(bits(64)inData)
          5       bits(64) outData;
          6       outData[3:0] = TweakCellInvRot(inData[51:48]);
          7       outData[7:4] = inData[55:52];
          8       outData[11:8] = inData[23:20];
          9       outData[15:12] = inData[27:24];
         10       outData[19:16] = inData[3:0];
         11       outData[23:20] = inData[7:4];
         12       outData[27:24] = TweakCellInvRot(inData[11:8]);
         13       outData[31:28] = inData[15:12];
         14       outData[35:32] = TweakCellInvRot(inData[31:28]);
         15       outData[39:36] = TweakCellInvRot(inData[63:60]);
         16       outData[43:40] = TweakCellInvRot(inData[59:56]);
         17       outData[47:44] = TweakCellInvRot(inData[19:16]);
         18       outData[51:48] = inData[35:32];
         19       outData[55:52] = inData[39:36];
         20       outData[59:56] = inData[43:40];
         21       outData[63:60] = TweakCellInvRot(inData[47:44]);
         22       return outData;

E2.1.401 TweakShuffle
          1   // TweakShuffle()
          2   // ==============
          3
          4   bits(64) TweakShuffle(bits(64) inData)
          5       bits(64) outData;
          6       outData[3:0] = inData[19:16];
          7       outData[7:4] = inData[23:20];
          8       outData[11:8] = TweakCellRot(inData[27:24]);
          9       outData[15:12] = inData[31:28];
         10       outData[19:16] = TweakCellRot(inData[47:44]);
         11       outData[23:20] = inData[11:8];
         12       outData[27:24] = inData[15:12];
         13       outData[31:28] = TweakCellRot(inData[35:32]);
         14       outData[35:32] = inData[51:48];
         15       outData[39:36] = inData[55:52];
         16       outData[43:40] = inData[59:56];
         17       outData[47:44] = TweakCellRot(inData[63:60]);
         18       outData[51:48] = TweakCellRot(inData[3:0]);
         19       outData[55:52] = inData[7:4];
         20       outData[59:56] = TweakCellRot(inData[43:40]);
         21        outData[63:60] = TweakCellRot(inData[39:36]);
         22        return outData;

E2.1.402 UnprivHaltingDebugAllowed
          1   // UnprivHaltingDebugAllowed()
          2   // ===========================
          3
          4   boolean UnprivHaltingDebugAllowed(boolean isSecure)
          5       return UnprivHaltingDebugEnabled(isSecure) && !CurrentModeIsPrivileged(isSecure);

E2.1.403 UnprivHaltingDebugEnabled
          1   //   UnprivHaltingDebugEnabled()
          2   //   ===========================
          3   //   Returns TRUE if unprivileged halting debug is enabled for the indicated
          4   //   Security state, FALSE otherwise.
          5
          6   boolean UnprivHaltingDebugEnabled(boolean isSecure)
          7       if !HaveSecurityExt() then assert !isSecure;
          8
          9        if !HaveUDE() then
         10             return FALSE;
         11        elsif HaveSecurityExt() then
         12             uiden = DAUTHCTRL_S.UIDEN == '1';
         13             // Secure unprivileged debug also grants Non-secure unprivileged debug.
         14             if !isSecure then uiden = uiden || DAUTHCTRL_NS.UIDEN == '1';
         15             return uiden;
         16        else
         17             return DAUTHCTRL.UIDEN == '1';

E2.1.404 UnsignedSat
          1   // UnsignedSat()
          2   // =============
          3
          4   bits(N) UnsignedSat(integer i, integer N)
          5       (result, -) = UnsignedSatQ(i, N);
          6       return result;

E2.1.405 UnsignedSatQ
          1   // UnsignedSatQ()
          2   // ==============
          3
          4   (bits(N), boolean) UnsignedSatQ(integer i, integer N)
          5       if i > 2^N - 1 then
          6            result = 2^N - 1; saturated = TRUE;
          7       elsif i < 0 then
          8            result = 0; saturated = TRUE;
          9       else
         10            result = i; saturated = FALSE;
         11       return (result[N-1:0], saturated);

E2.1.406 UpdateDebugEnable
          1   // UpdateDebugEnable()
          2   // ===================
          3   // Update DHCSR.S_SDE, DEMCR.SDME, and unprivileged debug enables for each instruction
          4
          5   UpdateDebugEnable()
          6       // DHCSR.S_SDE and unprivileged debug enables are frozen if the PE is in Debug state
          7       if !Halted then
          8           nsUide             =   UnprivHaltingDebugAllowed(FALSE);
          9           sUide              =   UnprivHaltingDebugAllowed(TRUE);
         10           DHCSR.S_SDE        =   if sUide || SecureHaltingDebugAllowed() then '1' else '0';
         11           DHCSR.S_SUIDE      =   if sUide && !SecureHaltingDebugAllowed() then '1' else '0';
         12           DHCSR.S_NSUIDE     =   if nsUide && !HaltingDebugAllowed()      then '1' else '0';
         13
         14       // DEMCR.SDME is frozen if DebugMonitor is active or pending
         15       if HaveDebugMonitor()                     &&
         16           ExceptionActive[DebugMonitor] == '00' &&
         17           DEMCR.MON_PEND == '0' then
         18               DEMCR.SDME = if SecureDebugMonitorAllowed() then '1' else '0';

E2.1.407 UpdateFPCCR
          1   // UpdateFPCCR()
          2   // =============
          3
          4   UpdateFPCCR(bits(32) frameptr, boolean applySpLim)
          5       assert(HaveMveOrFPExt());
          6
          7       FPCAR.ADDRESS = frameptr[31:3];
          8       // Flag if the context address violates the stack pointer limit. If the
          9       // limit has been violated PreserveFPState() will zero the registers if
         10       // required, but will not save the context to the stack.
         11       if applySpLim && ViolatesSPLim(LookUpSP(), frameptr) then
         12            FPCCR.SPLIMVIOL = '1';
         13       else
         14            FPCCR.SPLIMVIOL = '0';
         15       FPCCR.LSPACT = '1';
         16
         17       execPri = ExecutionPriority();
         18       isSecure = IsSecure();
         19       FPCCR_S.S = if isSecure then '1' else '0';
         20       if CurrentModeIsPrivileged() then
         21            FPCCR.USER = '0';
         22       else
         23            FPCCR.USER = '1';
         24       if CurrentMode() == PEMode_Thread then
         25            FPCCR.THREAD = '1';
         26       else
         27            FPCCR.THREAD = '0';
         28       if execPri > -1 then
         29            FPCCR_S.HFRDY = '1';
         30       else
         31            FPCCR_S.HFRDY = '0';
         32       targetSecure = AIRCR.BFHFNMINS == '0';
         33       busfaultpri = ExceptionPriority(BusFault, targetSecure, FALSE);
         34       if SHCSR_S.BUSFAULTENA == '1' && execPri > busfaultpri then
         35            FPCCR_S.BFRDY = '1';
         36       else
         37            FPCCR_S.BFRDY = '0';
         38       memfaultpri = ExceptionPriority(MemManage, isSecure, FALSE);
         39       if SHCSR.MEMFAULTENA == '1' && execPri > memfaultpri then
         40            FPCCR.MMRDY = '1';
         41       else
         42            FPCCR.MMRDY = '0';
         43       usagefaultpri = ExceptionPriority(UsageFault, FALSE, FALSE);
         44       if SHCSR_NS.USGFAULTENA == '1' && execPri > usagefaultpri then
         45            FPCCR_NS.UFRDY = '1';
         46       else
         47            FPCCR_NS.UFRDY = '0';
         48       usagefaultpri = ExceptionPriority(UsageFault, TRUE, FALSE);
         49       if SHCSR_S.USGFAULTENA == '1' && execPri > usagefaultpri then
         50            FPCCR_S.UFRDY = '1';
         51       else
         52            FPCCR_S.UFRDY = '0';
         53       if HaveSecurityExt() then
         54            securefaultpri = ExceptionPriority(SecureFault, TRUE, FALSE);
         55            if SHCSR_S.SECUREFAULTENA == '1' && execPri > securefaultpri then
         56                FPCCR_S.SFRDY = '1';
         57            else
         58                FPCCR_S.SFRDY = '0';
         59       if CanPendMonitorOnEvent(isSecure, TRUE, TRUE, FindPriv(), TRUE) then
         60            FPCCR_S.MONRDY = '1';
         61       else
         62            FPCCR_S.MONRDY = '0';
         63       return;

E2.1.408 ValidateAddress
          1   // ValidateAddress()
          2   // =================
          3
          4   (ExcInfo, AddressDescriptor) ValidateAddress(bits(32) address, AccType acctype,
          5                                                boolean ispriv, boolean secure,
          6                                                boolean iswrite, boolean aligned)
          7       AddressDescriptor result;
          8       Permissions       perms;
          9       ns              = boolean UNKNOWN;
         10       excInfo         = DefaultExcInfo();
         11
         12       // Security checking and MPU bank selection if Security Extensions are present.
         13       if HaveSecurityExt() then
         14            // Check SAU/IDAU for given address.
         15            isInstrfetch = acctype == AccType_IFETCH;
         16            sAttrib      = SecurityCheck(address, isInstrfetch, secure);
         17            if isInstrfetch then
         18                ns        = sAttrib.ns;
         19                secureMpu = !sAttrib.ns;
         20                // Override the privilege flag supplied with the a value based on the
         21                // privilege associated with the current mode and the Security state
         22                // of the MPU being queried. This can be different from the value this
         23                // function is called with, because CONTROL.nPRIV is banked between
         24                // Security states.
         25                ispriv = CurrentModeIsPrivileged(secureMpu);
         26            else
         27                ns        = !secure || sAttrib.ns;
         28                secureMpu = secure;
         29       else
         30            ns        = TRUE;
         31            secureMpu = FALSE;
         32
         33       // Getting memory attribute information from MPU. Note that NS information
         34       // in the memory attribute is set by SAU/IDAU and is updated after getting
         35       // attribute values from MPU.
         36       (result.memattrs, perms) = MPUCheck(address, acctype, ispriv, secureMpu);
         37       // Updating NS information got from SAU/IDAU in memory attributes
         38       result.memattrs.NS       = ns;
         39
         40       // Generate UNALIGNED UsageFault exception if access to Device memory is unaligned.
         41       if !aligned && result.memattrs.memtype == MemType_Device && perms.apValid == TRUE then
         42           if acctype != AccType_DBG then
         43               if secure then
         44                    UFSR_S.UNALIGNED = '1';
         45               else
         46                    UFSR_NS.UNALIGNED = '1';
         47           excInfo = CreateException(UsageFault, FALSE, secure);
         48
         49       if excInfo.fault == NoFault && HaveSecurityExt() then
         50           // Check if there is a SAU/IDAU violation and, if so, update the fault syndrome
         51           case acctype of
         52               when AccType_IFETCH
         53                   if secure then
         54                       if sAttrib.ns then
         55                           // Invalid exit from the Secure state
         56                           SFSR.INVTRAN = '1';
         57                             excInfo      = CreateException(SecureFault);
         58                    else
         59                        if !sAttrib.ns && !sAttrib.nsc then
         60                             // Invalid entry to the Secure state
         61                             SFSR.INVEP   = '1';
         62                             excInfo      = CreateException(SecureFault);
         63                when AccType_VECTABLE
         64                    if !secure && !sAttrib.ns then
         65                        HFSR.VECTTBL = '1';
         66                        // Vector fetch faults raise a HardFault directly, but because this fault
         67                        // is caused by an SAU/IDAU violation it always targets the secure state.
         68                        excInfo       = CreateException(HardFault, TRUE, TRUE);
         69                when AccType_DBG
         70                    if !secure && !sAttrib.ns then
         71                        // DAP accesses result in a error being returned to the DAP without any
         72                        // syndrome being set.
         73                        excInfo         = CreateException(SecureFault);
         74                when AccType_NORMAL, AccType_MVE, AccType_ORDERED, AccType_STACK
         75                    if !secure && !sAttrib.ns then
         76                        SFSR.AUVIOL     = '1';
         77                        SFSR.SFARVALID = '1';
         78                        SFAR            = address;
         79                        excInfo         = CreateException(SecureFault);
         80                when AccType_LAZYFP
         81                    if !secure && !sAttrib.ns then
         82                        SFSR.LSPERR     = '1';
         83                        SFSR.SFARVALID = '1';
         84                        SFAR            = address;
         85                        excInfo         = CreateException(SecureFault);
         86                otherwise
         87                    assert(FALSE);
         88
         89       result.paddress               =   address;
         90       result.accattrs.iswrite       =   iswrite;
         91       result.accattrs.ispriv        =   ispriv;
         92       result.accattrs.acctype       =   acctype;
         93
         94       if excInfo.fault == NoFault then
         95           excInfo = CheckPermission(perms, address, acctype, iswrite, ispriv, secureMpu);
         96
         97       return (excInfo, result);

E2.1.409 ValidateExceptionReturn
          1   // ValidateExceptionReturn()
          2   // =========================
          3
          4   (ExcInfo, EXC_RETURN_Type) ValidateExceptionReturn(EXC_RETURN_Type excReturn,
          5                                                      integer returningExceptionNumber)
          6       boolean error         = FALSE;
          7       assert CurrentMode() == PEMode_Handler;
          8       if !IsOnes(excReturn[23:7]) || excReturn[1] != '0' then
          9           UNPREDICTABLE;
         10       if !HaveMveOrFPExt() && excReturn.FType == '0' then
         11           UNPREDICTABLE;
         12       if !HaveSecurityExt() && (excReturn.S    == '1' ||
         13                                 excReturn.ES   == '1' ||
         14                                 excReturn.DCRS == '0') then
         15           UNPREDICTABLE;
         16
         17       // Security specific validation
         18       if HaveSecurityExt() then
         19           // If exception return is an invalid attempt to return from Non-secure
         20           // state with EXC_RETURN.ES set as '1', then a SecureFault is raised
         21           exceptionWasSecure = excReturn.ES == '1';
         22           if CurrentState == SecurityState_NonSecure && excReturn.ES == '1' then
         23               error              = TRUE;
         24               // excReturn.ES is used below to control which exception to
         25                  // deactivate, and which CONTROL.SPSEL to update. Force it to the
         26                  // correct value so the code below functions correctly even if the
         27                  // Non-secure state returned an invalid excReturn value.
         28                  // Similarly the exception to deactivate below is actually Non-secure
         29                  excReturn.ES       = '0';
         30                  exceptionWasSecure = FALSE;
         31
         32               // Check DCRS bit not used in for Non-secure exceptions
         33               if !exceptionWasSecure && excReturn.DCRS == '0' then
         34                   error = TRUE;
         35
         36               if error then
         37                   SFSR.INVER      = '1';
         38                   exceptionNumber = SecureFault;
         39        else
         40               exceptionWasSecure = FALSE;
         41
         42        // check returning from an inactive handler
         43        if !error then
         44            if !IsActiveForState(returningExceptionNumber, exceptionWasSecure) then
         45                error = TRUE;
         46                if HaveMainExt() then
         47                     UFSR.INVPC      = '1';
         48                     exceptionNumber = UsageFault;
         49                else
         50                     exceptionNumber = HardFault;
         51
         52        if error then
         53             DeActivate(returningExceptionNumber, exceptionWasSecure);
         54             if HaveSecurityExt() && exceptionWasSecure then
         55                 CONTROL_S.SPSEL = excReturn.SPSEL;
         56             else
         57                 CONTROL_NS.SPSEL = excReturn.SPSEL;
         58             // Escalates to HardFault if requested fault is disabled, or has
         59             // insufficient priority, or if Main Extension is not implemented
         60             excInfo = CreateException(exceptionNumber, FALSE, IsSecure());
         61        else
         62             excInfo = DefaultExcInfo();
         63        return (excInfo, excReturn);

E2.1.410 ValidatePAC
          1   //   ValidatePAC()
          2   //   =============
          3   //   Returns TRUE if the pointer authentication code in Z matches the pointer authentication
          4   //   code derived using a cryptographic algorithm as a combination of X, Y and the
          5   //   cryptographic key. The correct cryptographic key is selected in CreatePAC(), on the
          6   //   basis of the current security state and privilege level.
          7
          8   boolean ValidatePAC(bits(32) X, bits(32) Y, bits(32) Z)
          9       return Z == CreatePAC(X, Y);

E2.1.411 VCX_op0
          1   // VCX_op0
          2   // =======
          3
          4   bits(size) VCX_op0(bits(32) instr, integer size)
          5       return VCX_op0(instr, size, FALSE, integer UNKNOWN, bits(4) UNKNOWN);
          6
          7   bits(size) VCX_op0(bits(32) instr, integer size, boolean isBeatWise, integer curBeat,
          8                      bits(4) elmtMask)
          9       assert size IN {32, 64};
         10
         11        // Custom data path returning IMPLEMENTATION DEFINED value based on
         12        // instruction opcode only.
         13        if isBeatWise then
         14              return CdeImpDefValue(instr, curBeat, elmtMask);
         15       else
         16              return CdeImpDefValue(instr);

E2.1.412 VCX_op1
          1   // VCX_op1
          2   // =======
          3
          4   bits(size) VCX_op1(bits(32) instr, bits(N) opa, integer size)
          5       return VCX_op1(instr, opa, size, FALSE, integer UNKNOWN, bits(4) UNKNOWN);
          6
          7   bits(size) VCX_op1(bits(32) instr, bits(N) opa, integer size, boolean isBeatWise,
          8                      integer curBeat, bits(4) elmtMask)
          9       assert N    IN {32, 64, 128};
         10       assert size IN {32, 64, 128};
         11
         12       // Custom data path returning IMPLEMENTATION DEFINED value based on instruction
         13       // opcode and single 32-bit, 64-bit, or 128-bit operand, opa, only.
         14       if isBeatWise then
         15            return CdeImpDefValue(instr, opa, curBeat, elmtMask);
         16       else
         17            return CdeImpDefValue(instr, opa);

E2.1.413 VCX_op2
          1   // VCX_op2
          2   // ======
          3
          4   bits(size) VCX_op2(bits(32) instr, bits(N) opa, bits(N) opb, integer size)
          5       return VCX_op2(instr, opa, opb, size, FALSE, integer UNKNOWN, bits(4) UNKNOWN);
          6
          7   bits(size) VCX_op2(bits(32) instr, bits(N) opa, bits(N) opb, integer size,
          8                      boolean isBeatWise, integer curBeat, bits(4) elmtMask)
          9       assert N    IN {32, 64, 128};
         10       assert size IN {32, 64, 128};
         11
         12       // Custom data path returning IMPLEMENTATION DEFINED value based on instruction
         13       // opcode and two 32-bit or 64-bit operands, opa and opb, only.
         14       if isBeatWise then
         15            return CdeImpDefValue(instr, opa, opb, curBeat, elmtMask);
         16       else
         17            return CdeImpDefValue(instr, opa, opb);

E2.1.414 VCX_op3
          1   // VCX_op3
          2   // =======
          3
          4   bits(size) VCX_op3(bits(32) instr, bits(N) opa, bits(N) opb, bits(N) opc, integer size)
          5       return VCX_op3(instr, opa, opb, opc, size, FALSE, integer UNKNOWN, bits(4) UNKNOWN);
          6
          7   bits(size) VCX_op3(bits(32) instr, bits(N) opa, bits(N) opb, bits(N) opc, integer size,
          8                      boolean isBeatWise, integer curBeat, bits(4) elmtMask)
          9       assert N    IN {32, 64, 128};
         10       assert size IN {32, 64, 128};
         11
         12       // Custom data path returning IMPLEMENTATION DEFINED value based on instruction
         13       // opcode and three 32-bit, 64-bit, or 128-bit operands, opa, opb and opc, only.
         14       if isBeatWise then
         15            return CdeImpDefValue(instr, opa, opb, opc, curBeat, elmtMask);
         16       else
         17            return CdeImpDefValue(instr, opa, opb, opc);

E2.1.415 Vector
          1   // Vector[]
          2   // ========
          3
          4   (ExcInfo, bits(32)) Vector[integer exceptionNumber, boolean isSecure]
          5       // Calculate the address of the entry in the vector table
          6       vtor = if isSecure then VTOR_S else VTOR_NS;
          7       addr = (vtor.TBLOFF:'0000000') + 4 * exceptionNumber;
          8       // Fetch the vector with the correct privilege and security
          9       (exc, vector) = MemA_with_priv_security(addr, 4, AccType_VECTABLE,
         10                           Privilege_Priv, isSecure, TRUE);
         11       // Faults that prevent the vector being fetched are terminal and prevent
         12       // the exception being entered.
         13       if exc.fault != NoFault then
         14           exc.isTerminal = TRUE;
         15       return (exc, vector);

E2.1.416 VectorCatchDebug
          1   // VectorCatchDebug()
          2   // ==================
          3
          4   VectorCatchDebug(boolean isSecure, boolean isPriv)
          5       vectorEvt = FALSE;
          6
          7       if CanHaltOnEvent(isSecure, isPriv) then
          8           case UInt(IPSR.Exception) of
          9               when HardFault
         10                   vectorEvt = ((DEMCR.VC_HARDERR == '1' && (HFSR.FORCED                       == '1'   ||
         11                                                             HFSR.DEBUGEVT                     == '1')) ||
         12                                (DEMCR.VC_INTERR == '1' && (HFSR.VECTTBL                       == '1')));
         13
         14                 when MemManage
         15                     vectorEvt = ((DEMCR.VC_MMERR             == '1' && (MMFSR.IACCVIOL        ==   '1'   ||
         16                                                                         MMFSR.DACCVIOL        ==   '1')) ||
         17                                      (DEMCR.VC_INTERR        == '1' && (MMFSR.MSTKERR         ==   '1'   ||
         18                                                                         MMFSR.MUNSTKERR       ==   '1'   ||
         19                                                                         MMFSR.MLSPERR         ==   '1')));
         20
         21                 when BusFault
         22                     vectorEvt = ((DEMCR.VC_BUSERR            == '1' && (BFSR.IBUSERR          ==   '1'   ||
         23                                                                         BFSR.PRECISERR        ==   '1'   ||
         24                                                                         BFSR.IMPRECISERR      ==   '1')) ||
         25                                      (DEMCR.VC_INTERR        == '1' && (BFSR.STKERR           ==   '1'   ||
         26                                                                         BFSR.UNSTKERR         ==   '1'   ||
         27                                                                         BFSR.LSPERR           ==   '1')));
         28
         29                 when UsageFault
         30                     vectorEvt = ((DEMCR.VC_STATERR == '1' && (UFSR.UNDEFINSTR                 ==   '1'   ||
         31                                                               UFSR.INVPC                      ==   '1'   ||
         32                                                               UFSR.INVSTATE                   ==   '1')) ||
         33                                  (DEMCR.VC_CHKERR == '1' && (UFSR.UNALIGNED                   ==   '1'   ||
         34                                                               UFSR.DIVBYZERO                  ==   '1')) ||
         35                                  (DEMCR.VC_INTERR == '1' && (UFSR.STKOF                       ==   '1')) ||
         36                                  (DEMCR.VC_NOCPERR == '1' && (UFSR.NOCP                       ==   '1')));
         37
         38                 when SecureFault
         39                     vectorEvt = ((DEMCR.VC_SFERR             == '1' && (SFSR.INVEP            ==   '1'   ||
         40                                                                         SFSR.INVIS            ==   '1'   ||
         41                                                                         SFSR.INVER            ==   '1'   ||
         42                                                                         SFSR.AUVIOL           ==   '1'   ||
         43                                                                         SFSR.INVTRAN          ==   '1'   ||
         44                                                                         SFSR.LSPERR           ==   '1'   ||
         45                                                                         SFSR.LSERR            ==   '1')));
         46
         47                 otherwise
         48                     // No other exceptions trigger vector catch
         49
         50           if vectorEvt then
         51                 DHCSR.C_HALT = '1';
         52                 DFSR.VCATCH = '1';

E2.1.417 VFPExcBarrier
          1   // VFPExcBarrier
          2   // =============
          3   // Ensures that all floating-point exception processing has completed
          4
          5   VFPExcBarrier();

E2.1.418 VFPExpandImm
          1   // VFPExpandImm()
          2   // ==============
          3
          4   bits(N) VFPExpandImm(bits(8) imm8, integer N)
          5       assert N IN {16,32,64};
          6       integer E = if N == 16 then 5 elsif N == 32 then 8 else 11;
          7       constant integer F = N - E - 1;
          8       bits(E-2) exp;
          9       bits(F+2) frac;
         10       sign = imm8[7];
         11       exp = NOT(imm8[6]):Replicate(imm8[6],E-3);
         12       frac = imm8[5:0]:Zeros(F-4);
         13       return sign : exp : frac;

E2.1.419 VFPNegMul
          1   // Different types of floating-point multiply and negate operations
          2
          3   enumeration VFPNegMul {VFPNegMul_VNMLA, VFPNegMul_VNMLS, VFPNegMul_VNMUL};

E2.1.420 VFPSmallRegisterBank
          1   //   VFPSmallRegisterBank()
          2   //   ======================
          3   //   Returns TRUE because the Floating Point implementation only provides access to
          4   //   16 double-precision registers
          5
          6   boolean VFPSmallRegisterBank()
          7       return TRUE;

E2.1.421 ViolatesSPLim
          1   // ViolatesSPLim()
          2   // ===============
          3
          4   boolean ViolatesSPLim(RNames spreg, bits(32) value)
          5       isSecure = ((spreg == RNamesSP_Main_Secure) || (spreg == RNamesSP_Process_Secure));
          6
          7        // Check CCR.STKOFHFNMIGN to determine if the limit should actually be
          8        // applied. When checking if CCR.STKOFHFNMIGN should apply the requested
          9        // execution priority is considered, and AIRCR.PRIS is ignored.
         10        assert (!isSecure || HaveSecurityExt());
         11        if HaveMainExt() && IsReqExcPriNeg(isSecure) then
         12             ignLimit   = if isSecure then CCR_S.STKOFHFNMIGN else CCR_NS.STKOFHFNMIGN;
         13             applylimit = (ignLimit == '0');
         14        else
         15             applylimit = TRUE;
         16
         17        return applylimit && (UInt(value) < UInt(LookUpSPLim(spreg)));

E2.1.422 VPTActive
          1   // VPTActive()
          2   // ===========
          3
          4   boolean VPTActive()
          5       return VPTActive(_BeatID);
          6
          7   boolean VPTActive(integer beat)
          8       return Elem[VPR[23:16], beat DIV 2, 4] != Zeros(4);

E2.1.423 VPTAdvance
          1   // VPTAdvance()
          2   // ============
          3
          4   VPTAdvance(integer beat)
          5       maskID   = beat DIV 2;
          6       vptState = Elem[VPR[23:16], maskID, 4];
          7       if vptState == '1000' then
          8           vptState = Zeros(4);
          9       elsif vptState != '0000' then
         10           (vptState, inv) = LSL_C(vptState, 1);
         11           // Invert the predicate flags for this beat if the bit shifted out of
         12           // the VPT state was 1.
         13           if inv == '1' then
         14               Elem[VPR.P0, beat, 4] = NOT Elem[VPR.P0, beat, 4];
         15       // Since the mask fields are grouped in pairs only update the mask on every
         16       // odd numbered beat.
         17       if beat[0] == '1' then
         18           Elem[VPR[23:16], maskID, 4] = vptState;

E2.1.424 WaitForEvent
          1   //   WaitForEvent
          2   //   ============
          3   //   Optionally suspends execution until a WFE wakeup event or reset occurs,
          4   //   or until some earlier time if the implementation chooses
          5
          6   WaitForEvent();

E2.1.425 WaitForInterrupt
          1   //   WaitForInterrupt
          2   //   ================
          3   //   Optionally suspends execution until a WFI wakeup event or reset occurs, or 4   //   until some earlier time if the implementation chooses
          5
          6   WaitForInterrupt();

E2.1.426 ZeroExtend
          1   // ZeroExtend()
          2   // ============
          3
          4   bits(N) ZeroExtend(bits(M) x, integer N)
          5       assert N >= M;
          6       return Zeros(N-M) : x;
          7
          8   bits(N) ZeroExtend(bits(M) x)
          9       return ZeroExtend(x, N);

E2.1.427 Zeros
          1   // Zeros()
          2   // =======
          3
          4   bits(N) Zeros(integer N)
          5       return Replicate('0',N);
          6
          7   bits(N) Zeros()
          8       return Zeros(N);
